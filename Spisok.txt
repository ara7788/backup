
#########
#English
#########

#######
#LINUX
#######
===============
L1.SETUP
===============
-----------------------------------------------------------------------------
yum
-----------------------------------------------------------------------------
apt/deb/dpkg
-----------------------------------------------------------------------------
rpm
-----------------------------------------------------------------------------
systemd
-----------------------------------------------------------------------------
syslog
-----------------------------------------------------------------------------
cron/crontab/anacron
-----------------------------------------------------------------------------
date/hwclock/timedatectl/ntp/chrony
-----------------------------------------------------------------------------
===============
L2.SECURITY
===============
-----------------------------------------------------------------------------
restore_passwd
-----------------------------------------------------------------------------
attributs
-----------------------------------------------------------------------------
setuid
-----------------------------------------------------------------------------
setgid
-----------------------------------------------------------------------------
sticky bit
-----------------------------------------------------------------------------
selinux
-----------------------------------------------------------------------------
aparmore
-----------------------------------------------------------------------------
su/sudo
-----------------------------------------------------------------------------
acl
-----------------------------------------------------------------------------
user management	useradd/del,groupadd/del,chmod/chown
-----------------------------------------------------------------------------
===============
L3.LAN
===============
-----------------------------------------------------------------------------
IPv4, IPv6
-----------------------------------------------------------------------------
hostname
-----------------------------------------------------------------------------
networks
-----------------------------------------------------------------------------
dns
-----------------------------------------------------------------------------
dhcp
-----------------------------------------------------------------------------
route
-----------------------------------------------------------------------------
ssh/sftp
-----------------------------------------------------------------------------
firewalld
-----------------------------------------------------------------------------
iptables
-----------------------------------------------------------------------------
fail2ban
-----------------------------------------------------------------------------
nmap
-----------------------------------------------------------------------------
===============
L4.HDD
===============
-----------------------------------------------------------------------------
raid_0_60
-----------------------------------------------------------------------------
lvm
-----------------------------------------------------------------------------
lvm и fsck
-----------------------------------------------------------------------------
fdisk
-----------------------------------------------------------------------------
swap
-----------------------------------------------------------------------------
format
-----------------------------------------------------------------------------
file sistems
-----------------------------------------------------------------------------
zfs
-----------------------------------------------------------------------------
ext4
-----------------------------------------------------------------------------
mount
-----------------------------------------------------------------------------
fstab
-----------------------------------------------------------------------------
===============
L5.COMMANDS
===============
-----------------------------------------------------------------------------
curl
-----------------------------------------------------------------------------
whois
-----------------------------------------------------------------------------
dig
-----------------------------------------------------------------------------
nslookup
-----------------------------------------------------------------------------
traceroute
-----------------------------------------------------------------------------
find,grep/sed,tail/less/more/cat/tac/head,locate,whereis,which
-----------------------------------------------------------------------------
tar,zip
-----------------------------------------------------------------------------
man -f name == whatis, man -k name == apropos, info,whereis
-----------------------------------------------------------------------------
vi,vim
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------

-----------------------------------------------------------------------------

===============
L6.LAEMP
===============
-----------------------------------------------------------------------------
MySQL/phpMyAdmin
-----------------------------------------------------------------------------
PHP5/7/alternatives
-----------------------------------------------------------------------------
Apache
-----------------------------------------------------------------------------
Nginx
-----------------------------------------------------------------------------
SSL
-----------------------------------------------------------------------------
Keepalived
-----------------------------------------------------------------------------
DRBD
-----------------------------------------------------------------------------
RabbitMQ
-----------------------------------------------------------------------------
APCu
-----------------------------------------------------------------------------
Memcached
-----------------------------------------------------------------------------
===============		
L7.SERVICES
===============
-----------------------------------------------------------------------------
Nfs
-----------------------------------------------------------------------------
iSCSI
-----------------------------------------------------------------------------
OpenVPN 
-----------------------------------------------------------------------------
ProFTPd
-----------------------------------------------------------------------------
PureFTP
-----------------------------------------------------------------------------
VSftpd
-----------------------------------------------------------------------------
Samba
-----------------------------------------------------------------------------
telnet ftp,smtp,imap,pop3
-----------------------------------------------------------------------------
Exim
-----------------------------------------------------------------------------
SPF, DKIM, DMARC
-----------------------------------------------------------------------------
Postfix
-----------------------------------------------------------------------------
Devecot
-----------------------------------------------------------------------------
Spamassasing
-----------------------------------------------------------------------------
ClamAV
-----------------------------------------------------------------------------
===============
L8.UPDATE
===============
-----------------------------------------------------------------------------
kernel
-----------------------------------------------------------------------------
php/mysql
-----------------------------------------------------------------------------
alternatives
-----------------------------------------------------------------------------
===============
L9.MONITORING
===============
-----------------------------------------------------------------------------
Nagios (Check_MK)
-----------------------------------------------------------------------------
Supervisord
-----------------------------------------------------------------------------
backup сайта по ssh
-----------------------------------------------------------------------------
rsync
-----------------------------------------------------------------------------
Veeam
-----------------------------------------------------------------------------
Мониторинг Сети
-----------------------------------------------------------------------------
===============
L10.SCRIPTING
===============
-----------------------------------------------------------------------------
Bash
-----------------------------------------------------------------------------
Python
-----------------------------------------------------------------------------

########
#DevOps
########
======================
D1.CI/CD
======================
-----------------------------------------------------------------------------
Teamcity
-----------------------------------------------------------------------------
Jenkins
-----------------------------------------------------------------------------
======================
D2.Automatisation
======================
-----------------------------------------------------------------------------
Ansible
-----------------------------------------------------------------------------
Chef
-----------------------------------------------------------------------------
======================
D3.Repositariy
======================
-----------------------------------------------------------------------------
Git
-----------------------------------------------------------------------------
SVN
-----------------------------------------------------------------------------
============================================
D4.Container orchestration and clustering
============================================
-----------------------------------------------------------------------------
Docker
-----------------------------------------------------------------------------
Mesos, Kubernetes, Swarm
-----------------------------------------------------------------------------
OpenVZ
-----------------------------------------------------------------------------
===========
D5.ELK stack 
===========
-----------------------------------------------------------------------------
ElasticSearch
-----------------------------------------------------------------------------
Logstash
-----------------------------------------------------------------------------
Kibana
-----------------------------------------------------------------------------
======================
D6.Atlassian
======================
-----------------------------------------------------------------------------
JIRA
-----------------------------------------------------------------------------
Confluence
-----------------------------------------------------------------------------
Bamboo
-----------------------------------------------------------------------------
Stash(Bitbucket)
-----------------------------------------------------------------------------

######
#AWS	
######



###############################
#Switch, Routing and Telephony
###############################
=============
SR1.Microtik
=============
-----------------------------------------------------------------------------
https://habrahabr.ru/post/265387/
-----------------------------------------------------------------------------
http://www.technotrade.com.ua/Articles/mikrotik_router_setup.php
-----------------------------------------------------------------------------
Командная строка
-----------------------------------------------------------------------------
Боитесь командной строки, но понимаете, что с ней работать удобнее? Научитесь
работать и в командной строке, и в графическом интерфейсе.
----------------------------------------------------------------------------- 
Подбор модели

Научитесь выбирать оборудование MikroTik по вашим требованиям: установка в
офисе или на улице, будет или не будет VPN, нужен ли Wi-Fi и др.
----------------------------------------------------------------------------- 
Стабильная телефония

Вы научитесь настраивать приоритезацию трафика так, что IP-телефония больше
не будет "крякать".
----------------------------------------------------------------------------- 
Управление трафиком

Кто-то качает торрент, а остальные без интернета? Настройте трафик гибко, в
зависимости от количества пользователей и приоритета их задач.
----------------------------------------------------------------------------- 
Брандмауэр

Защититесь от атак, настройте файервол по схемам «нормально открытый» или
«нормально закрытый».
----------------------------------------------------------------------------- 
Настройка VPN

Трафик будет не ходить, а бегать ;) Научитесь настраивать VPN разными способами.
----------------------------------------------------------------------------- 
Резервный интернет

Регулярно "отваливается" интернет? Настройте автоматическое переключение
с основного канала на резервный и обратно.
----------------------------------------------------------------------------- 
Беспроводные сети

Потерялись в настройках Wi-Fi? Научитесь настраивать сети в диапазона 2,4 и 5 ГГц.
Делайте гостевые сети. Ставьте ограничение скорости wi-fi сети.
-----------------------------------------------------------------------------


=============
SR2.Cisco
=============
-----------------------------------------------------------------------------
terminal
restore_password
update/restore os
-----------------------------------------------------------------------------
cdp
-----------------------------------------------------------------------------
port security
-----------------------------------------------------------------------------
ether channale
lasp
-----------------------------------------------------------------------------
trunc
vlan
vtp
-----------------------------------------------------------------------------
stp
-----------------------------------------------------------------------------
nat
-----------------------------------------------------------------------------
acl
-----------------------------------------------------------------------------
hsrp
-----------------------------------------------------------------------------
rip
-----------------------------------------------------------------------------
ospf
-----------------------------------------------------------------------------
vpn
-----------------------------------------------------------------------------
https://linkmeup.ru/tag/%D1%81%D0%B5%D1%82%D0%B8%20%D0%B4%D0%BB%D1%8F%20%D1%81%D0%B0%D0%BC%D1%8B%D1%85%20%D0%BC%D0%B0%D0%BB%D0%B5%D0%BD%D1%8C%D0%BA%D0%B8%D1%85/
-----------------------------------------------------------------------------
============
T1.Asterisk
============ 
-----------------------------------------------------------------------------
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


#########
#English
#########

#######
#LINUX
#######
===============
L1.SETUP
===============
-----------------------------------------------------------------------------
Подключение репозиториев в CentOS
-----------------------------------------------------------------------------
Добавить репозиторий в CentOS можно тремя разными способами:
-----------------------------------------------------------------------------
    Добавив секцию [repository] в файл /etc/yum.conf
    Создав .repo файл в директории /etc/yum.repos.d
    Установив rpm пакет с информацией о репозитории
-----------------------------------------------------------------------------
Как уже было сказано ранее, первый способ использовать не рекомендуется самими
разработчиками. Наиболее быстрый и удобный третий способ. Если rpm пакета
для добавления репозитория не существует, то используется вручную второй способ.
-----------------------------------------------------------------------------
	epel
-----------------------------------------------------------------------------
Extra Packages for Enterprise Linux. Пакеты из epel репозитория никогда 
======================================
не конфликтуют и не переустанавливают
======================================
базовые пакеты RHEL. Поддерживаются пакеты для следующих операционных систем:
-----------------------------------------------------------------------------
	# yum -y install epel-release
-----------------------------------------------------------------------------
/etc/yum.repos.d/epel.repo
-----------------------------------------------------------------------------
	remi
-----------------------------------------------------------------------------
Les RPM de Remi repository поддерживает последние версии MySQL и PHP
(бэкпорты федоровских rpm). Пакеты этого репозитория необходимо
======================================
использовать с осторожностью
======================================
, так как они заменяют базовые пакеты.
-----------------------------------------------------------------------------
	# wget http://rpms.remirepo.net/enterprise/remi-release-7.rpm
	# rpm -Uvh remi-release-7*.rpm
-----------------------------------------------------------------------------
список активных репозиториев в centos
-----------------------------------------------------------------------------
# yum repolist
-----------------------------------------------------------------------------
Удалить репозиторий в CentOS
-----------------------------------------------------------------------------
# yum -y install yum-utils
# yum-config-manager --disable remi-safe
-----------------------------------------------------------------------------
Для того, чтобы обновить кэш yum после изменения репозиториев,
можно воспользоваться следующими командами:
-----------------------------------------------------------------------------
# yum clean all
# yum makecache
-----------------------------------------------------------------------------
Минимальное содержание файла /etc/yum.repos.d/*.repo следующее:
-----------------------------------------------------------------------------
[repository]
name=repository_name
baseurl=repository_url
-----------------------------------------------------------------------------
name 	имя, описывающее репозиторий, может быть любым

baseurl 	ссылка на расположение репозитория, может быть в виде http, ftp
или file ссылки
-----------------------------------------------------------------------------
Другие ползные параметры, которые могут быть указаны в repo файле:
-----------------------------------------------------------------------------
enabled 	принимает значение 1 или 0, 1 — репозиторий подключен, 0 — отключен

async 	управляет загрузкой пакетов, auto — использует при возможности
параллельную загрузку, on — использует только параллельную загрузку, off —
параллельная загрузка отключена

mirrorlist 	вместо ссылки на конкретный адрес репозитория может быть
указана ссылка на список адресов, из которых при установке будет выбран
наиболее подходящий

gpgcheck 	принимает значение 1 или 0, 1- осуществлять проверку GPG
подписи пакета из репозитория, 0 — не проверять

gpgkey 	ссылка на GPG ключ репозитория

-----------------------------------------------------------------------------
===============
#yum
===============

/etc/yum.conf
/etc/yum.repos.d/
/var/log/yum.log
-----------------------------------------------------------------------------
Настрока репозитория актвного
dir:/etc/yum.repos.d/repolist_name
repolist_name:
enabled=1 - active
-----------------------------------------------------------------------------
Выбор из какого репозитория ставить:
yum -y remove php
yum -y --enablerepo=remi-php70 install php70-php
-----------------------------------------------------------------------------
Обновление репозитария
yum upgrade

Проверка на доступные обновления
#yum check-update
список подключенных репозиториев
#yum repolist
информация об определенном репозитории
#yum repoinfo epel
информация о пакетах в указанном репозитории
#yum repo-pkgs epel list
удалить пакеты сохраненные в кэше
#yum clean packages
удалить все пакеты и метаданные
#yum clean all
создать кэш
#yum makecache
установить пакет
#yum install httpd
удаление пакета
установить из локальной директории (поиск/установка зависимостей будут
произведены из подключенных репозиториев)
#yum localinstall httpd.rpm
или
#yum install httpd.rpm
установить с http
#yum localinstall http://server/repo/httpd.rpm
#yum remove httpd
обновить пакет
#yum update httpd
откатиться к предыдущей версии пакета
#yum downgrade
переустановка пакета (восстановление удаленных файлов)
#yum reinstall httpd
удаление ненужных более пакетов
#yum autoremove
обновить все пакеты
#yum update
обновить до определенной версии
#yum update-to
проверить локальную базу rpm (поддерживаются параметры dependencies,
duplicates, obsoletes, provides)
#yum check
#yum check dependencies
список названий пакетов из репозиторий
#yum list
список всех доступных пакетов
#yum list available
список всех установленных пакетов
#yum list installed
установлен ли указанный пакет
#yum list installed httpd
список установленных и доступных пакетов
#yum list all
список пакетов, относящихся к ядру
#yum list kernel
отображение информации о пакете
#yum info httpd
список зависимостей и необходимых пакетов
#yum deplist httpd
найти пакет, который содержит файл
#yum provides "*bin/top"
поиск пакета по имени и описанию
#yum search httpd
получить информацию о доступных обновлениях безопасности
#yum updateinfo list security
вывести список групп
#yum grouplist
просмотр yum истории (вывод списка транзакций)
#yum history list
просмотр информации определенной транзакции (установленные пакеты,
установленные зависимости)
#yum history info 9
отмена транзакции
#yum history undo 9
повторить
#yum history redo 9

создание локальных репозиториев (createrepo ставится отдельно)
#createrepo
включить отключенный репозиторий
#yum update -y --enablerepo=epel
отключить репозиторий
#yum update -y --disablerepo=epel
-----------------------------------------------------------------------------
Выбор из какого репозитория ставить:
yum -y remove php
yum -y --enablerepo=remi-php70 install php70-php php70-php-pear
php70-php-bcmath php70-php-pecl-jsond-devel php70-php-mysqlnd php70-php-gd
php70-php-common php70-php-fpm php70-php-intl php70-php-cli php70-php
php70-php-xml php70-php-opcache php70-php-pecl-apcu php70-php-pecl-jsond
php70-php-pdo php70-php-gmp php70-php-process php70-php-pecl-imagick
php70-php-devel php70-php-mbstring
rm -f /usr/bin/php
ln -s /usr/bin/php70 /usr/bin/php
service httpd restart
service php70-php-fpm start


-----------------------------------------------------------------------------
===============
#apt/deb/dpkg
===============
/etc/apt/apt.conf
/etc/apt/sources.list
умеет работать с предпочтениями только через файл 
/etc/apt/preferences
/var/log/dpkg.log
кеш deb-пакетов 
/var/cache/apt/archives/


Обновление базы доступных пакетов:
apt-get update		обновление метаданных локального архива пакетов
apt-get upgrade		установить актуальные на данный момент версии имеющихся в системе пакетов без удаления существующих
apt-get -V upgrade	Обновление всех пакетов (с подробностями)
apt-get dist-upgrade 	установить актуальные на данный момент версии имеющихся в системе пакетов с удалением существующих, если это необходимо
apt-cache search mysql | less		Пакеты можно искать через веб-интерфейс или с помощь команды
apt-cache show mysql-server		Просмотр дополнительной информации о пакете
apt-cache madison postgresql		Получения списка доступных версий пакета
apt-file list 	<шаблон_имен_файлов> список содержимого пакетов из архива, в названии которых имеется совпадение с шаблоном
dpkg —audit 	 Анализ системы на предмет частично установленных пакетов
dpkg —configure -a 		перенастроить распакованный пакет. Вместе с опцией -а все распакованные, но не настроенные пакеты будут настроены
apt-cache policy <имя_двоичного_пакета>		проверяет статус пакетов
apt-cache showsrc <имя_двоичного_пакета> 	показывает исходную информацию о пакете
apt-get build-dep <имя_пакета> 	установка пакетов, необходимых для компиляции пакетов исходных кодов 15
aptitude build-dep <имя_пакета> 	install required packages to build package
apt-get source <имя_пакета> 	скачивание пакета исходного кода 16	

apt-get install имя_пакета		Установка пакета
dpkg -i dropbox_1.4.0_i386.deb	… или, в случае всяких там Dropbox, Skype и тп
apt-get install --reinstall имя_пакета		Переустановка пакета
apt-get install имя_пакета=версия		Даунгрейд или установка определенной версии

Если не переустанавливается, можно попробовать так (осторожно, временно ломаются зависимости):
sudo dpkg --purge --force-depends имя_пакета
sudo apt-get install имя_пакета

Запретить/разрешить обновление конкретного пакета:
sudo apt-mark hold имя_пакета
sudo apt-mark unhold имя_пакета

dpkg --get-selections | grep hold		Посмотреть список пакетов на холде
dpkg --verify					Проверка контрольных сумм установленных пакетов

Список установленных пакетов и поиск по нему:
dpkg -l | grep firefox

sudo apt-get remove firefox	Удаление пакета
sudo apt-get purge firefox	Удаление вместе с файлами конфигурации
sudo apt-get autoremove # --purge для удаления конфигов		Удаление пакетов, которые были установлены в качестве зависимостей и более не требуются
sudo apt-get clean	Чистка кэша deb-пакетов (каталог /var/cache/apt/archives/)

/var/log/dpkg.*			Просмотр логов — что и когда ставилось
dpkg -S /usr/bin/pstree		Иногда нужно определить, к какому пакету относится файл.
dpkg-query -L package_name	А еще можно получить список всех файлов, содержащихся в пакете
dpkg -r debian-cd		Полное удаление пакета debian-cd
dpkg -P debian-cd		Вычищаются файлы настройки пакета

В общем, все легко и просто, если не считать пары моментов.

Во-первых,
иногда требуется установить какой-нибудь экспериментальный пакет (из ветки sid).
Для этого нужно открыть файл /etc/apt/sources.list и дописать в него строчку:
deb http://ftp.ru.debian.org/debian sid main

… после чего говорим «sudo apt-get update», 
ставим нужный пакет, удаляем строчку из sources.list
и вновь говорим «sudo apt-get update».

Во-вторых,
некоторые пакеты тянут за собой слишком много лишнего софта.
Например, mail-notifications тянет за собой postfix и требует его настроить. Для решения это проблемы следует прописать в /etc/apt/apt.conf следующее:
APT::Install-Recommends "0";

После чего все должно пройти как по маслу:
sudo apt-get update
sudo apt-get install mail-notification

sudo apt-get --no-install-recommends install mail-notification		Альтернативное решение, не требующее правки apt.conf

Бывает еще так, что нужно создать резервную копию уже установленного пакета.
Например, если он по каким-то причинам был удален из репозитория.
Такое иногда бывает в случае со внутренними репозиториями компании.
Решается эта проблема так:
sudo apt-get install dpkg-repack
sudo dpkg-repack имя_пакета

-----------------------------------------------------------------------------
===============
#rpm
===============

rpm -ivh foo-1.0-1.i386.rpm bar-2.0.20-3.i386.rpm	Установка
rpm -e foo						Удаление
rpm -Uvh foo.rpm					Обновление
rpm -Fvh foo-1.2-1.i386.rpm				Освежение пакета похоже на его обновление
rpm -q	foo						выводит название пакета, версию и номер выпуска установленного пакета foo

Параметрами выбора пакета.
	-a 		запрашивает все установленные пакеты
	-f <file> 	запрашивает пакет, к которому относится файл <file>. Указывая файл, вы должны определить полный путь к файлу (например, /bin/ls).
	-p <packagefile> запрашивает пакет <packagefile>. 

Параметрами запроса информации.

    -i 	отображает информацию о пакете, включая имя, описание,
	выпуск, размер, дату сборки, дату установки,
	производителя и другую разнообразную информацию.

    -l выводит список файлов, содержащихся в пакете.

    -s выводит состояние всех файлов в пакете.

    -d выводит список файлов, помеченных как документация
	(страницы man, info, файлы README, и т.д.).

    -c выводит список файлов, помеченных как файлы конфигурации.
	Таковыми считаются файлы, изменяемые вами после установки
	при настройке пакета в вашей системе
	(например, sendmail.cf, passwd, inittab и т.д.). 

Добавьте для параметров, выводящих списки файлов, команду -v и вы получите списки в знакомом формате ls -l. 

rpm -Vf /usr/bin/vim		Чтобы проверить пакет, содержащий конкретный файл, выполните
rpm -Va				Чтобы проверить ВСЕ установленные пакеты
rpm -Vp foo-1.0-1.i386.rpm	Чтобы сравнить установленный пакет с файлом RPM-пакета

rpm -ivh --replacepkgs foo-1.0-1.i386.rpm	Если версия пакета, который вы пытаетесь установить,
						совпадает с версией уже установленного, но вы, тем не 													менее, хотите установить пакет, вы можете указать
						параметр --replacepkgs и RPM проигнорирует эту ошибку

rpm -q --redhatprovides bar.so.2	Если система не предлагает пакет для разрешения зависимости,
					вы можете попробовать параметр --redhatprovides, чтобы определить, какой пакет содержит 					требуемый файл. Для использования этого параметра вам потребуется установить пакет rpmdb-redhat.
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
===============
#systemd
===============


Systemd приносит концепцию юнитов systemd. Юниты представлены конфигурационными файлами, размещенными в одной из директорий:

    /usr/lib/systemd/system/ – юниты из установленных пакетов RPM.
    /run/systemd/system/ — юниты, созданные в рантайме. Этот каталог приоритетнее каталога с установленными юнитами из пакетов.
    /etc/systemd/system/ — юниты, созданные и управляемые системным администратором. Этот каталог приоритетнее каталога юнитов, созданных в рантайме.


Юниты содержат информацию о системных сервисах, прослушиваемых сокетах, сохраненных снапшотах состояний системы и других обьектах, относящихся к системе инициализации.

Типы юнитов systemd:

    .service – системный сервис
    .target — группа юнитов systemd
    .automount – точка автомонтирования файловой системы
    .device – файл устройства, распознанного ядром
    .mount – точка монтирования файловой системы
    .path – файл или директория в файловой системе
    .scope – процесс, созданный извне
    .slice – группа иерархически организованных юнитов, управляющая системными процессами
    .snapshot – сохраненное состояние менеджера systemd
    .socket – сокет межпроцессного взаимодействия
    .swap – Свап-устройство или свап-файл (файл подкачки)
    .timer – таймер systemd

systemctl

По способу использования сервисные юниты .service напоминают скрипты инициализации.
Для просмотра, старта, остановки, перезагрузки, включения или выключения системных сервисов используется команда systemctl.
Команды service и chkconfig по-прежнему включены в систему, но только по соображениям совместимости.

Ниже представлены основные команды systemctl:
    systemctl start name.service – запуск сервиса.
    systemctl stop name.service — остановка сервиса
    systemctl restart name.service — перезапуск сервиса
    systemctl try-restart name.service — перезапуск сервиса только, если он запущен
    systemctl reload name.service — перезагрузка конфигурации сервиса
    systemctl status name.service — проверка, запущен ли сервис с детальным выводом состояния сервиса
    systemctl is-active name.service — проверка, запущен ли сервис с простым ответом: active или inactive
    systemctl list-units --type service --all – отображение статуса всех сервисов
    systemctl enable name.service – активирует сервис (позволяет стартовать во время запуска системы)
    systemctl disable name.service – деактивирует сервис
    systemctl reenable name.service – деактивирует сервис и сразу активирует его
    systemctl is–enabled name.service – проверяет, активирован ли сервис
    systemctl list-unit-files - список установленных файлов юнитов 
    systemctl list-unit-files --type service – отображает все сервисы и проверяет, какие из них активированы
    systemctl mask name.service – заменяет файл сервиса симлинком на /dev/null, делая юнит недоступным для systemd
    systemctl unmask name.service – возвращает файл сервиса, делая юнит доступным для systemd

Работаем с целями (targets) Systemd

Предыдущие версии CentOS с SysV init или Upstart включали
предопределенный набор уровней запуска (runlevels),
которые представляли специфичные режимы для операций,
пронумерованные от 0 до 6. В CentOS 7 концепция уровней
запуска была заменена целями systemd.

Файлы целей systemd .target предназначены для группировки
вместе других юнитов systemd через цепочку зависимостей.
graphical.target, использующийся для старта графической сессии,
запускает системные сервисы GNOME Display Manager (gdm.service)
и Accounts Service (accounts–daemon.service) и активирует
multi–user.target. В свою очередь multi–user.target запускает другие
системные сервисы, такие как Network Manager (NetworkManager.service)
или D-Bus (dbus.service) и активирует другие целевые юниты basic.target.

    poweroff.target (runlevel0.target) – завершение работы и отключение системы
    rescue.target (runlevel1.target) – настройка оболочки восстановления
    multi–user.target (runlevel2.target, runlevel3.target, runlevel4.target) – настройка неграфической многопользовательской системы
    graphical.target (runlevel5.target) – настройка графической многопользовательской системы
    reboot.target (runlevel6.target) – выключение и перезагрузка системы

	systemctl get–default				Для определения, какой целевой юнит используется по умолчанию, полезна следующая команда
	systemctl list-units --type target		Для просмотра всех загруженных целевых юнитов воспользуйтесь командой 
	systemctl list-units --type target --all	для просмотра вообще всех целевых юнитов командой
	systemctl set-default name.target		Для изменения цели по умолчанию поможет команда
	systemctl isolate name.target			Для изменения текущей цели. Команда запустит целевой юнит
						и все его зависимости и немедленно остановит все остальные.
Выключение и перезагрузка системы

	systemctl halt – останавливает систему
	systemctl poweroff – выключает систему
	systemctl reboot – перезагружает систему

Управление systemd на удаленной машине
	systemctl --host user_name@host_name command

Перезагрузка сервисов
	systemctl daemon-reload

-------------------------------------------
Типичный systemd .service
-------------------------------------------
[Unit]
Description=Daemon to detect crashing apps
After=syslog.target

[Service]
ExecStart=/usr/sbin/abrtd
Type=forking

[Install]
WantedBy=multi-user.target
-------------------------------------------

[Unit]		содержит общую информацию о сервисе и After указывает
		на то, что демон должен быть запущен после Syslog.

[Service]	ExecStart указывает на исполняемый файл нашего сервиса.
		Type мы указываем, как сервис уведомляет systemd об окончании запуска.

[Install]	содержит информацию о цели, в которой сервис должен стартовать,
		когда будет активирована цель multi–user.target.

Это минимальный работающий файл сервиса systemd.
Написав свой, для тестирования скопируйте его в /etc/systemd/system/имя_сервиса.service.
Выполните команды systemctl daemon-reload.
-------------------------------------------
Журнал
-------------------------------------------
# journalctl		Для чтения логов используйте команду
			systemd имеет собственную систему ведения логов,
			названную журналом (journal). В связи с этим больше
			не требуется запускать демон syslog.

/etc/systemd/journald.conf 	Если	параметр Storage= имеет значение auto,
				журнал записывается именно в /var/log/journal/.

Если вы или какая-то программа удалит этот каталог,
systemd не пересоздаст его автоматически и вместо этого
будет писать свои журналы по непостоянному пути /run/systemd/journal.

Однако, папка будет пересоздана, когда вы установите Storage=persistent
и выполните systemctl restart systemd-journald (или перезагрузитесь). 

Перезапуск журналирования
	systemctl restart systemd-journald

Поскольку журнал хранится в двоичном формате,
содержимое его сообщений не меняется. Это означает,
что их можно просматривать при помощи strings,
например, в окружении, в котором не установлен systemd. Пример:

$ strings /mnt/arch/var/log/journal/af4967d77fba44c6b093d0e9862f6ddd/system.journal | grep -i сообщение
-----------------------------------------------------------------------------

journalctl -b		Показать все сообщения с момента текущей загрузки системы:
ournalctl -b -0		покажет сообщения с момента текущей загрузки
journalctl -b -1	предыдущей загрузки
journalctl -b -2	следующей за предыдущей, и т.д.

journalctl --list-boots		Просмотреть список предыдущих загрузок

journalctl ---since yesterday
journalctl -u nginx.service --since yesterday
journalctl -u nginx.service -u php-fpm.service —since today	C опцией -u также используется фильтрация по дате и времени


id -u www-data
33

journalctl _UID=33	можно просмотреть логи всех процессов, запущенных от имени этого пользователя
journalctl -F _UID	Вывести на консоль список пользователей, о которых имеются записи в логах
journalctl -F _GUID	Для просмотра аналогичного списка пользовательских групп

journalctl -p err -b	Просмотреть сообщения обо всех ошибках, имевших место в системе, можно с помощью опции -p
    0 — EMERG (система неработоспособна);
    1 — ALERT (требуется немедленное вмешательство);
    2 — CRIT (критическое состояние);
    3 — ERR (ошибка);
    4 — WARNING (предупреждение);
    5 — NOTICE (всё нормально, но следует обратить внимание);
    6 — INFO (информационное сообщение);
    7 —DEBUG (отложенная печать).
-----------------------------------------------------------------------------
Запись логов в стандартный вывод
-----------------------------------------------------------------------------
По умолчанию journalctl использует для вывода сообщений логов внешнюю утилиту less.
В этом случае к ним невозможно применять стандартные утилиты для обработки текстовых
данных (например, grep). Эта проблема легко решается: достаточно воспользоваться
опцией −−no-pager, и все сообщения будут записываться в стандартный вывод:

$ journalctl --no-pager
-----------------------------------------------------------------------------
Выбор формата вывода
-----------------------------------------------------------------------------
$ journalctl  -u nginx.service -o json
$ journalctl -u nginx.service -o json-pretty или json-sse
Помимо JSON данные логов могут быть преобразованы в следующие форматы:

    cat — только сообщения из логов без служебных полей;
    export — бинарный формат, подходит для экспорта или резервного копирования логов;
    short — формат вывода syslog;
    short-iso — формат вывода syslog с метками времени в формате ISO 8601;
    short-monotonic — формат вывода syslog c метками монотонного времени (monotonic timestamp);
    short-precise — формат вывода syslog с метками точного времени (время событий указывается с точностью до микросекунд);
    verbose — максимально подробный формат представления данных (включает даже те поля, которые в других форматах не отображаются).

-----------------------------------------------------------------------------
Просмотр информации о недавних событиях
-----------------------------------------------------------------------------
По умолчанию на консоль выводится информация о последних 10 событиях.
С опцией -n можно указать необходимое число событий:

$ journalctl -n 20

-----------------------------------------------------------------------------
journalctl --since="2012-10-30 18:17:16"	Показать все сообщения, начиная с какой-либо даты (и, если хотите, времени)
journalctl --since "20 min ago"			Показать все сообщения за последние 20 минут
journalctl -f					Показывать новые сообщения
journalctl /usr/lib/systemd/systemd		Показать все сообщения для конкретного исполняемого файла
journalctl _PID=1				Показать все сообщения для конкретного процесса
journalctl -u netcfg				Показать все сообщения для конкретного юнита
journalctl -k					Показать кольцевой буфер ядра
journalctl -f -l SYSLOG_FACILITY=10		Показать auth.log эквивалентно фильтрации syslog facility
-----------------------------------------------------------------------------
Управление логгированием
-----------------------------------------------------------------------------
journalctl --disk-usage
journalctl --vacuum-size=100M			Remove archived journal files until the disk space they use falls below 100M
journalctl --vacuum-time=2weeks			Make all journal files contain no data older than 2 weeks

/еtc/systemd/journald.conf

    SystemMaxUse= максимальный объём, который логи могут занимать на диске;
    SystemKeepFree= объём свободного места, которое должно оставаться на диске после сохранения логов;
    SystemMaxFileSize= объём файла лога, по достижении которого он должен быть удален с диска;
    RuntimeMaxUse= максимальный объём, который логи могут занимать в файловой системе /run;
    RuntimeKeepFree= объём свободного места, которое должно оставаться в файловой системе /run после сохранения логов;
    RuntimeMaxFileSize= объём файла лога, по достижении которого он должен быть удален из файловой системы /run.

-----------------------------------------------------------------------------
Перенаправить журнал на /dev/tty12
-----------------------------------------------------------------------------
Создайте drop-in каталог /etc/systemd/journald.conf.d и создайте файл fw-tty12.conf с содержимым:

/etc/systemd/journald.conf.d/fw-tty12.conf

[Journal]
ForwardToConsole=yes
TTYPath=/dev/tty12
MaxLevelConsole=info

Затем перезапустите systemd-journald.
-----------------------------------------------------------------------------
Команда просмотра другого журнала
-----------------------------------------------------------------------------
Если появилась необходимость проверить логи другой системы, которая неисправна,
загрузитесь с работоспособной системы, чтобы восстановить неисправную систему. Примонтируйте диск неисправной системы, например в /mnt и укажите путь
 журнала через -D/--directory, например так:

	$ journalctl -D /mnt/var/log/journal -xe
-----------------------------------------------------------------------------
Централизованное хранение логов
-----------------------------------------------------------------------------

Одной из самых распространённых задач в работе системного администратора является
настройка сбора логов с нескольких машин с последующим помещением в централизованное хранилище.
В systemd предусмотрены специальные компоненты для решения этой задачи:
	systemd-journal-remote
	systemd-journal-upload
	systemd-journal-gatewayd.

С помощью команды systemd-journal-remote можно принимать логи с удалённых хостов и сохранять их
(на каждом их этих хостов должен быть запущен демон systemd-journal-gatewayd), например:

	$ systemd-journal-remote −−url https://some.host:19531/

В результате выполнения приведённой команды логи с хоста some.host будут сохранены в директории
	var/log/journal/some.host/remote-some~host.journal.

С помощью команды systemd-journal-remote можно также складывать имеющиеся на локальной
машине логи в отдельную директорию, например:

	$ journalctl -o export | systemd-journal-remote -o /tmp/dir -



Команда systemd-journal-upload используется для загрузки логов с локальной
машины в удалённое хранилище:

	$ systemd-journal-upload --url https://some.host:19531/



-----------------------------------------------------------------------------
Анализ процесса загрузки
-----------------------------------------------------------------------------
Использование systemd-analyze

Systemd предоставляет инструмент под названием systemd-analyze, позволяющий проанализировать процесс загрузки вашей системы, чтобы можно было увидеть, какие файлы юнитов тормозят загрузку. Соответственно, вы можете оптимизировать вашу систему. Для использования данного инструмента вам потребуется установить пакеты python2-cairo и python2-gobject.

Чтобы увидеть, сколько времени было потрачено на подготовку пространства ядра и пространства пользователя во время загрузки, просто выполните команду:

	$ systemd-analyze

Чтобы увидеть список запускаемых файлов юнитов, отсортированный по потраченному каждым из них на загрузку времени, выполните команду:

	$ systemd-analyze blame

Вы также можете создать файл SVG, показывающий процесс загрузки в графическом виде, наподобие Bootchart:

	$ systemd-analyze plot > plot.svg

-----------------------------------------------------------------------------
Изучение ошибок systemd
-----------------------------------------------------------------------------
	$ systemctl --failed	Давайте найдем службы systemd, которые не смогли запуститься
systemd-modules-load.service   loaded failed failed  Load Kernel Modules

	$ systemctl status systemd-modules-load

Если вы не увидите в списке Process ID, просто перезапустите службу при помощи команды 
	$ systemctl restart systemd-modules-load

	$ journalctl _PID=15630
Aug 25 11:48:13 mypc systemd-modules-load[15630]: Failed to find module 'blacklist usblp'
Aug 25 11:48:13 mypc systemd-modules-load[15630]: Failed to find module 'install usblp /bin/false'

Мы видим, что некоторые конфигурационные файлы модулей ядра имеют неверные настройки.
В этом случае мы взглянем на эти настройки в каталоге /etc/modules-load.d/:

	$ ls -Al /etc/modules-load.d/

...
-rw-r--r--   1 root root    79  1. Dez 2012  blacklist.conf
-rw-r--r--   1 root root     1  2. Mär 14:30 encrypt.conf

 Сообщение об ошибке Failed to find module 'blacklist usblp' должно относиться к
неправильной настройке в файле blacklist.conf. Давайте закомментируем настройку,
вставив хэш-символ # перед каждой опцией, найденной на шаге 3:

/etc/modules-load.d/blacklist.conf
# blacklist usblp


	$ systemctl restart systemd-modules-load
	$ systemctl status systemd-modules-load

-----------------------------------------------------------------------------
Диагностика проблем с загрузкой системы
-----------------------------------------------------------------------------
Загрузитесь с этими параметрами ядра:

systemd.log_level=debug systemd.log_target=kmsg log_buf_len=1M 
-----------------------------------------------------------------------------
Диагностика проблем в работе определенной службы
-----------------------------------------------------------------------------
Если какая-либо служба systemd ведет себя не так, как ожидается, 
и вы хотите получить дополнительную информацию о том, что происходит,
присвойте переменной окружения SYSTEMD_LOG_LEVEL значение debug.
Например, чтобы запустить демон systemd-networkd в режиме отладки:

# systemctl stop systemd-networkd
# SYSTEMD_LOG_LEVEL=debug /lib/systemd/systemd-networkd

В качестве альтернативы можно временно отредактировать файл
службы для получения подробного вывода. Например:

/usr/lib/systemd/system/systemd-networkd.service

[Service]
...
Environment=SYSTEMD_LOG_LEVEL=debug
....

Если вы знаете, что в дальнейшем вам по-прежнему будет нужна эта
отладочная информация, добавьте переменную обычным способом. 
-----------------------------------------------------------------------------
Управлением питанием ACPI
-----------------------------------------------------------------------------

Для управления питанием, например действие при закрытой крышки ноутбука,
нужно отредактировать файл /etc/systemd/logind.conf:

    HandlePowerKey: действия при нажатии кнопки питания.
    HandleSuspendKey: действия при нажатии кнопки спящего режима.
    HandleHibernateKey: действия при нажатии кнопки ждущего режимаs.
    HandleLidSwitch: действия при закрытии крышки ноутбука.

Эти переменные могут принимать следующие значения:

    ignore (пропустить).
    poweroff (выключить питание).
    reboot (перезагрузка).
    halt (завершить работу).
    suspend (спящий режим).
    hibernate (ждущий режим).
    hybrid-sleep (гибридный сон).
    lock (блокировка).
    kexec (оперативное переключение между ядрами).

По умолчанию systemd использует следующие значения:

    HandlePowerKey=poweroff
    HandleSuspendKey=suspend
    HandleHibernateKey=hibernate
    HandleLidSwitch=suspend

Для вступления изменений в силу, выполним команду:

# systemctl restart systemd-logind
-----------------------------------------------------------------------------
===============
#syslog
===============
-----------------------------------------------------------------------------
/etc/syslog.conf  - набор правил.
или
/etc/rsyslog.conf
служба
syslogd или rsyslogd
получает входную информацию при помощи сокета
/dev/log (локально)
или с udp-порта 514 (с удаленных машин).
Логи
/var/log/messages
-----------------------------------------------------------------------------
Каждое правило есть - строка, состоящая из селектора и действия, разделенных пробелом или табуляцией.
Селектор представляет собой запись в виде источник.приоритет.
(источник иногда именуют - категорией)
Селектор может состоять из нескольких записей источник.приоритет, разделенных символом ";" .
Можно указывать несколько источников в одном селекторе (через запятую).
Поле действие - устанавливает журналируемое действие для селектора.

Сообщения с уровнем, равным или выше указанного в селекторе, и источником, равным указанному в селекторе, считается подходящим. Звездочка перед точкой соответствует любому источнику, после точки - любому уровню. Слово none после точки - никакому уровню для данного источника. Можно указывать несколько источников в одном селекторе (через запятую).
-----------------------------------------------------------------------------
Источник (он же категория) может быть следующим:
-----------------------------------------------------------------------------
    0 - kern -  Сообщения ядра
    1 - user -  Сообщения пользовательских программ
    2 - mail -  Сообщения от почтовой системы.
    3 - daemon - Сообщения от тех системных демонов, которые в отличие от FTP или LPR не имеют выделенных специально для них категорий.
    4 - auth - Все что связано с авторизацией пользователей, вроде login и su (безопасность/права доступа)
    5 - syslog - Система протоколирования может протоколировать сообщения от самой себя.
    6 - lpr - Сообщения от системы печати.
    7 - news - Сообщения от сервера новостей. (в настоящее время не используется)
    8 - uucp - Сообщения от UNIX-to-UNIX Copy Protocol. Это часть истории UNIX и вероятнее всего она вам никогда не понадобится (хотя до сих пор определенная часть почтовых сообщений доставляется через UUCP).
    9 - cron - Сообщения от системного планировщика.
    10 - authpriv - То же самое, что и auth, однако сообщения этой категории записываются в файл, который могут читать лишь некоторые пользователи (возможно, эта категория выделена потому, что принадлежащие ей сообщения могут содержать открытые пароли пользователей, которые не должны попадать на глаза посторонним людям, и следовательно файлы протоколов должны иметь соответствующие права доступа).
    11 - ftp - При помощи этой категории вы сможете сконфигурировать ваш FTP сервер, что бы он записывал свои действия.
    12 - NTP - сообщения сервера времени
    13 - log audit
    14 - log alert
    15 - clock daemon - сообщения демона времени
    с 16 по 23   local0 - local7 Зарезервированные категории для использования администратором системы. Категория local7 обычно используется для сообщений, генерируемых на этапе загрузки системы.
    mark (не имеющая цифрового эквивалента) - присваивается отдельным сообщениям, формируемым самим демоном syslogd
-----------------------------------------------------------------------------
Под приоритет (степени важности) сообщений заданы 8 уровней важности, которые кодируются числами от 0 до 7:
-----------------------------------------------------------------------------

    0 - emerg (старое название PANIC) - Чрезвычайная ситуация. Система неработоспособна.
    1 - alert - Тревога! Требуется немедленное вмешательство.
    2 - crit - Критическая ошибка (критическое состояние).
    3 - err (старое название ERROR) - Сообщение об ошибке.
    4 - warning (старое название WARN) - Предупреждение.
    5 - notice - Информация о каком-то нормальном, но важном событии.
    6 - info - Информационное сообщение.
    7 - debug - Сообщения, формируемые в процессе отладки.

-----------------------------------------------------------------------------
Согласно действию, указанному в правиле, сообщение может быть записано в следующие назначения:
-----------------------------------------------------------------------------

	Обычный файл

Задается полным путем, начиная со слеша (/). Поставьте перед ним дефис (-), чтобы отменить синхронизацию файла после каждой записи. Это может привести к потере информации, но повысить производительность.

	Именованные каналы

Размещение перед именем файла символа канала (|) позволит использовать fifo (first in — first out, первый пришел — первый вышел) или именованный канал (named pipe) в качестве приемника для сообщений. Прежде чем запускать (или перезапускать) syslogd, необходимо создать fifo при помощи команды mkfifo. Иногда fifo используются для отладки.

	Терминал и консоль

Терминал, такой как /dev/console.

	Удаленная машина

Чтобы сообщения пересылались на другой хост, поместите перед именем хоста символ (@). Обратите внимание, что сообщения не пересылаются с принимающего хоста. (для работы данного назначения на клиенте и сервере в файле /etc/services должна быть прописана строчка syslog 514/udp, и открыт UTP-порт 514)

	Список пользователей

Разделенный запятыми список пользователей, получающих сообщения (если пользователь зарегистрирован в системе). Сюда часто включается пользователь root.

	Все зарегистрированные пользователи

Чтобы известить всех зарегистрированных пользователей при помощи команды wall, используйте символ звездочки (*).
-----------------------------------------------------------------------------
Пример несложного syslog.conf:
-----------------------------------------------------------------------------
# Все сообщения ядра выдавать на консоль.
#kern.*                                                 /dev/console

# Все логи уровня info или выше, кроме сообщений электронной почты, а так же
# не логировать сообщения аутентификации и сообщений сервиса cron!
*.info;mail.none;authpriv.none;cron.none                /var/log/messages

# Записывать в отдельный файл сообщения, содержащие конфиденциальную
# информацию аутентификации, независимо от их уровня.
authpriv.*                                              /var/log/secure

# Все сообщения почтовой системы тоже записывать в отдельный файл.
mail.*                                                  -/var/log/maillog

# Логировать сообщения планировщика в файл /var/log/cron
cron.*                                                  /var/log/cron

# Сообщения о чрезвычайных ситуациях должны немедленно получить
# все пользователи системы
*.emerg                                                 *

# Сохранять сообщения новостей уровня crit и выше в отдельный файл.
uucp,news.crit                                          /var/log/spooler

# Сохранять сообщения загрузки в boot.log
local7.*                                                /var/log/boot.log
-----------------------------------------------------------------------------
В синтаксисе конфигурационного файла можно поставить перед приоритетом знак !,
чтобы показать, что действие не должно применяться, начиная с этого уровня и выше.
Подобным образом, перед приоритетом можно поставить знак =, чтобы показать,
что правило применяется только к этому уровню, или !=, чтобы показать, что правило
применяется ко всем уровням, кроме этого. Ниже показано несколько примеров
(man syslog.conf можно найти множество других примеров):
-----------------------------------------------------------------------------
# Посылать все сообщения ядра в /var/log/kernel.
# Посылать все сообщения уровня critical и higher на удаленную машину sysloger и на консоль
# Посыласть все сообщения уровня  info, notice и warning в /var/log/kernel-info
#
kern.*                       /var/log/kernel
kern.crit                    @sysloger
kern.crit                    /dev/console
kern.info;kern.!err          /var/log/kernel-info

# Посылать все сообщения почтовой системы, кроме уровня info в /var/log/mail.
mail.*;mail.!=info           /var/log/mail
-----------------------------------------------------------------------------
Запуск syslogd
-----------------------------------------------------------------------------
Запуск сервиса протоколирования запускаются на этапе инициализации системы посредством скрипта
/etc/rc.d/init.d/syslog, однако для того, чтобы задать параметры запуска, нет необходимости
корректировать этот скрипт - начиная с версии 7.2, опции запуска считываются из отдельного
конфигурационного файла /etc/sysconfig/syslog (/etc/default/syslog в debian).

Вот некоторые возможные параметры запуска сервиса syslogd:

    -a /folder/socket - указание дополнительного слушающего сокета
	(не забудьте предварительно создать сокет)
    -d - отладочный режим. При этом сервис не переходит в фоновый режим
	и выдает все сообщения на текущий терминал;
    -f имя-конфигурационного-файла. Задает имя альтернативного конфигурационного файла,
	который будет использоваться вместо заданного по умолчанию /etc/syslog.conf;
    -l список-хостов - задание списка хостов, имена которых не должны записываться с
	указанием полного доменного имени (FQDN - Full Qwalified Domain Name);
    -m минут - запущенный без этой опции sysklogd через каждые 20 минут записывает
	в протокол сообщения категории mark (временные отметки). С помощью опции -m можно
	либо изменить интервал между отметками, либо вовсе отменить выдачу таких сообщений;
    -p socket - задание альтернативного сокета UNIX (вместо прослушиваемого по умолчанию /dev/log);
    -r - разрешение принимать сообщения от удаленных хостов;
    -x - запрет определения имени хоста по его адресу для предотвращения зависания при работе
	на одном хосте с сервером DNS.
    -v - показать версию и закончить работу
-----------------------------------------------------------------------------
После запуска сервиса syslogd создается файл статуса /var/lock/subsys/syslog нулевой длины,
и файл с идентификационным номером процесса /var/run/syslogd.pid.
-----------------------------------------------------------------------------
С помощью команды
kill -SIGNAL `cat /var/run/syslogd.pid`

можно послать сервису syslogd один из следующих сигналов:
SIGHUP - перезапуск сервиса;
SIGTERM - завершение работы;
SIGUSR1 - включить/выключить режим отладки.
-----------------------------------------------------------------------------
Вообще-то в системе запускаются два сервиса протоколирования - syslogd и klogd.
Оба сервиса входят в состав пакета sysklogd.

сервис klogd отвечает за журналирование событий, происходящих в ядре системы. Необходимость в отдельном сервисе klogd объясняется тем, что ядро не может использовать стандартную функцию syslog. Дело в том, что стандартные библиотеки С (включая ту библиотеку, в которой находится функция syslog) предназначены для использования только обычными приложениями. Поскольку ядро тоже нуждается в функциях журналирования, в него включены свои библиотеки, недоступные приложениям. Поэтому ядро использует свой собственный механизм генерации сообщений.

сервис klogd предназначен для организации обработки этих сообщений. В принципе он может производить такую обработку полностью самостоятельно и независимо от syslogd, например, записывая эти сообщения в файл, но в большинстве случаев используется принятая по умолчанию настройка klogd, при которой все сообщения от ядра пересылаются тому же сервису syslogd.

-----------------------------------------------------------------------------
Автоматическая ротация (обновление заполненных файлов) и архивирование журналов
-----------------------------------------------------------------------------
Это делается при помощи команды logrotate, которая обычно выполняется сервисом cron,
чтобы периодически создавать резервные копии журналов и создавать новые чистые журналы.

/etc/logrotate.conf
-----------------------------------------------------------------------------
пример файла /etc/logrotate.conf:
# сначала заданы параметры "по-умолчанию" (глобальные опции)
# обновлять файлы журнала еженедельно
weekly

# хранить архив логов за 4 последние недели
rotate 4

# создавать новый (пустой) файл после ротации (обновления)
create

# раскомментируйте, если желаете, чтобы сохраненные файлы сжимались
#compress

# включить настройки ротации из указанного каталога
include /etc/logrotate.d

# не хранить wtmp, или btmp -- настройки ротации данных журналов следующие:
# хранящие информацию о удачных и неудачных попытках входя в систему,
ротация которых происходит ежемесячно
/var/log/wtmp {
 missingok
 monthly
 create 0664 root utmp
 rotate 1
}

/var/log/btmp {
 missingok
 monthly
 create 0664 root utmp
 rotate 1
}

# специфичные системные журналы могут быть настроены ниже
-----------------------------------------------------------------------------
Резервные копии журналов могут также создаваться, когда журналы достигают определенного
размера, и могут быть созданы скрипты из наборов команд для выполнения до или после
операции резервного копирования. Пример:

/var/log/messages {
 rotate 5
 mail logadmin@sysloger
 size 100k
 postrotate
 /usr/bin/killall -HUP syslogd
 endscript
 }

В этом примере ротация /var/log/messages производится по достижении им размера 100 КБ.
Накапливается пять резервных копий, и когда истекает срок жизни самой старой резервной
копии, она отсылается по почте на адрес logadmin@sysloger. Командное слово postrotate
включает скрипт, перезапускающий демон syslogd после завершения ротации путем отправки
сигнала HUP. Командное слово endscript необходимо для завершения скрипта, а также в случае,
если имеется скрипт prerotate. Более полную информацию см. в страницах руководства man для logrotate.
-----------------------------------------------------------------------------
Параметры, задаваемые в конфигурационном файле logrotate.conf:

    compress | nocompress (старые версии сжимаются или не сжимаются с помощью gzip)
    compresscmd (задает программу сжатия, по умолчанию - gzip)
    uncompresscmd (задает программу разжатия, по умолчанию - ungzip)
    compressext (задает суффикс для сжатых файлов)
    compressoptions (задает параметры программы сжатия; по умолчанию - "-9", т.е. максимальное сжатие для gzip)
    copytruncate | nocopytruncate (обычно старая версия переименовывается и создается новая версия журнала; при задании этого параметра logrotate копирует журнал в новый файл, а затем обрезает старый; используется, если программа, создающая журнал, не умеет его закрывать; теряются записи, сделанные в промежутке между копированием и обрезанием; а поможет ли, если создающая журнал программа вместо режима append просто пишет в файл, используя внутренний указатель?)
    create [права-доступа владелец группа] | nocreate (сразу после переименования старой версии журнала и до вызова postrotate создается новый журнал с указанными атрибутами - права доступа задаются в восьмеричном виде, как в chmod.2; если атрибуты не указаны, то берутся от старого журнала)
    daily (смена версий в серии происходит ежедневно)
    delaycompress | nodelaycompress (некоторые программы не сразу закрывают журнал, в этом случае сжатие надо отложить до следующего цикла)
    errors email (кому направлять сообщения об ошибках)
    extension суффикс (задается суффикс, добавляемый к именам файлов при ротации перед суффиксом сжатия)
    ifempty | notifempty (смена версий даже если файл пуст; действует по умолчанию)
    include имя-файла | имя-директории (текстуально подставить файл или все файлы из указанной директории; не включаются поддиректории, специальные файлы и файлы с суффиксами из списка исключений; нельзя использовать внутри секции)
    mail адрес | nomail (когда смена версий приводит к необходимости удалить старый журнал, то послать его по указанному адресу)
    mailfirst (посылать не удаляемую версию журнала, а первую)
    maillast (посылать удаляемую версию журнала; действует по умолчанию)
    missingok | nomissingok (не посылать сообщения об ошибке, если журнал отсутствует)
    monthly (смена версий происходит ежемесячно)
    olddir директория | noolddir (во время смены версий журнал перемещается в указанную директорию; д.б. на том же физическом устройстве)
    postrotate (все дальнейшие строчки до строки endscript исполняются как команды shell после процесса смены версии)
    prerotate (все дальнейшие строчки до строки endscript исполняются перед процессом смены версии)
    rotate число (сколько старых версий хранить; если 0, то ни одной)
    size байт (смена версии происходит, если размер журнала превысил указанное число; можно использовать суффиксы "k" - килобайт - и "M" - мегабайт)
    sharedscripts | nosharedscripts (выполнять команды prerotate и postrotate только один раз для всех файлов, описанных в секции)
    tabooext [+] список-суффиксов (задание списка суффиксов-исключений для include; если указан знак "плюс", то дополнение, иначе замена; по умолчанию: .rpmorig, .rpmsave, .rpmnew, ",v", .swp и "~")
    weekly (смена версий происходит еженедельно)

-----------------------------------------------------------------------------
Изучение и мониторинг журналов
-----------------------------------------------------------------------------
	less /var/log/messages
	grep "ppp" /var/log/messages | tail

	tail -f /var/log/messages | grep syslog-server

Кроме файлов-журналов, указанных в /etc/syslog.conf, существуют так же и другие файлы,
например файл /var/log/dmesg,  который хранит информацию о процессе загрузки системы
до запуска syslogd, а так же файлы /var/log/lastlog, /var/log/wtmp, /var/log/btmp, имеющие
двоичный формат и и хранящие информацию о последнем входе пользователя в систему, о всех
удачных входах пользователей в систему и о всех неудачных входах пользователей в систему соответственно. 
-----------------------------------------------------------------------------
=======================
#cron/crontab/anacron
=======================
----------------------------------------------------------------------------------
Основной конфиг
/etc/crontab

По периодам
/etc/cron.hourly
/etc/cron.daily
/etc/cron.weekly
/etc/cron.monthly

запускать команды по особому расписанию
/etc/cron.d

/var/spool/cron - RedHat
/var/spool/cron/crontabs - debian,ubuntu
/var/spool/cron/tabs - SUSE
----------------------------------------------------------------------------------
#cat /etc/crontab

SHELL=/bin/bash
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root
HOME=/
# run-parts
01 * * * * root run-parts /etc/cron.hourly
02 4 * * * root run-parts /etc/cron.daily
22 4 * * 0 root run-parts /etc/cron.weekly
42 4 1 * * root run-parts /etc/cron.monthly
----------------------------------------------------------------------------------
systemctl status cron
systemctl restart cron
service crond restart
----------------------------------------------------------------------------------
минута час день месяц день_недели пользователь команда
* * * * * {пользователь} выполняемая_команда
- - - - -
| | | | |
| | | | ----- День недели (0 - 7) (Воскресенье =0 или =7)
| | | ------- Месяц (1 - 12) (можно три буквы из названия месяца,
| | |                        регистр не имеет значения от jan до dec)
| | --------- День (1 - 31)
| ----------- Час (0 - 23)
------------- Минута (0 - 59)

Команда - строка в формате командного интерпретатора которая будет исполнена,
допускается запись типа команда1 && команда2 для запуска нескольких команд подряд.
----------------------------------------------------------------------------------
начения минут, часов, дней можно указывать следующим образом:
    Значение - число обозначающее дату или время, допускается подстановочный знак *
	допускающий полный диапазон значений
    Несколько значений - допускается указывать несколько значений через запятую, например 2,14,22
    Диапазон значений - указывается через дефис, например 2-10
    Шаг значений - указывается через дробь, в знаменатель которой ставится шаг,
	например */3 - каждое третье значение 0, 3, 6, 9 и т.д. В качестве числителя 	должен быть диапазон значений либо звездочка.
----------------------------------------------------------------------------------
Рассмотрим следующий пример записи:
0 8-19/2 * * 1 /home/ivanov/test

Она означает что каждый второй час с 8 до 19 (8, 10,12,14,16) по понедельникам запускать скрипт test в
домашнем каталоге Иванова.

Сразу хотим предостеречь вас от распространенной ошибки, при указании периодического исполнения
все даты должны быть указаны явно, звездочка обозначает полный диапазон значений, а не их отсутствие.
Например если вам требуется исполнять некий скрипт каждый час с 10 до 15 неправильно будет:

* 10-15 * * * /home/ivanov/test
Данная строка приведет к запуску скрипта каждую минуту в диапазоне с 10 до 15 часов. Правильно будет:

0 10-15 * * * /home/ivanov/test
Данная запись позволит запускать скрипт в начале каждого часа указанного диапазона.
----------------------------------------------------------------------------------
Кроме даты можно использовать ряд специальных строк:

    @reboot - выполнять команду при перезагрузке
    @yearly или @annually - выполнять 1 января, аналогично записи: "0 0 1 1 * "
    @monthly - выполнять 1 числа каждого месяца, аналогично "0 0 1 * * "
    @weekly - выполнять каждое воскресенье, равносильно "0 0 * * 0"
    @daily или @midnight - ежедневно в полночь,"0 0 * * * "
    @hourly - раз в час, "0 * * * * "

Так для ежедневного исполнения нашего скрипта каждую полночь можно написать:

@midnight /home/ivanov/test
----------------------------------------------------------------------------------
Если необходимо запретить пользователю создавать и редактировать crontab-файлы сделать 
это можно записав, имя его учетной записи в файл /etc/cron.deny.
Если файла нет, то его нужно создать самому. Имена учетных записей записываются по одному в строке.
Можно также использовать файл /etc/cron.allow. Подробнее описано в man crontab.
----------------------------------------------------------------------------------
-------------------------
crontab -u user_name file     -создание файла crontab из файла "file" для юзера "user_name"
-------------------------
-------------------------
crontab -u user_name -l       -просмотр файла crontab юзера "user_name"
-------------------------
-------------------------
crontab -u user_name -r       -удаление файла crontab юзера "user_name"
-------------------------
-------------------------
crontab -u user_name -e       -редактирование файла crontab юзера "user_name" используя редактор,
				 ый переменной окружения VISUAL или EDITOR
-------------------------

----------------------------------------------------------------------------------
Перезагрузка Linux по расписанию внесите в консоль следующее:
    cd /etc
    cat > shutdown.sh << EOF
    shutdown -r now
    EOF
    chmod +x shutdown.sh
    crontab -e
в открывшемся редакторе внести:

    00 04 * * * /etc/shutdown.sh
если нужно несколько раз в сутки перезагружать нужно добавить несколько строчек
в этот файл с указанием времени запуска команды перезагрузки
----------------------------------------------------------------------------------
Задача: запускать каждую минуту файл /home/user/mail, который будет отправлять почту

#содержимое файла mail (файл должен быть с правами на запуск! например -rwxr-xr-x)
#!/bin/bash
mess="test cron"
echo "$mess" |mutt -s "subj" -m application/octet-stream bob@server.ru

1.Создаем временный файл /home/user/test содержимое файла test такое:

SHELL=/bin/bash
MAILTO=user
0-59 * * * * /home/user/mail

2. Запускаем в терминале команду crontab /home/user/test

Все. После этого в каталоге /var/spool/cron будет создан файл "user" примерно с таким содержимым

# DO NOT EDIT THIS FILE - edit the master and reinstall.
# (/home/user/test installed on Mon Mar 29 02:31:34 2004)
# (Cron version -- $Id: crontab.c,v 2.13 1994/01/17 03:20:37 vixie Exp $)
SHELL=/bin/bash
MAILTO=user
0-59 * * * * /home/user/mail

и файл /home/user/mail будет запускаться демоном cron каждую минуту. 
----------------------------------------------------------------------------------
По мимо cron есть ещё комманда at которая позволяет заплпнировать комманду на выполнение один раз
	touch 1.txt | at 10:00
-----------------------------------------------------------------------------
anacron
-----------------------------------------------------------------------------
anacron — (англ. anachronistic cron) асинхронный или анахроничный cron.
Anacron в отличие от cron не поддерживает запуск заданий по расписанию, вместо
этого задания запускаются с заданным интервалом времени. Это очень удобно для
систем которые работают не регулярно, например домашние рабочие станции или ноутбуки.
Anacron хранит метки времени файлов в /var/spool/anacron, чтобы записывать время
выполнения заданий. При запуске anacron проверяет, прошло ли необходимое количество
дней с тех пор, как задача была выполнена в последний раз, и при необходимости
запускает ее. Задачи anacron хранятся в конфигурационном файле /etc/anacrontab.
Синтаксис данного файла аналогичен /etc/crontab, за исключением полей таблиц:
-----------------------------------------------------------------------------
* * * выполняемая_команда
- - -
| | |
| | --------- идентификатор
| ----------- задержка
------------- период
-----------------------------------------------------------------------------
Период — период выполнения в днях. Задержка — задержка запуска в минутах.
Идентификатор задания — любой непустой символ, кроме / \.
Задержка чаще всего используется для того чтобы позволить системе полностью загрузиться.
-----------------------------------------------------------------------------
Debian включение логов cron
-----------------------------------------------------------------------------

С удивлением на днях обнаружил, что в Debian по-умолчанию нет отдельного файла
логов cron. Он все пишет в общий файл логов /var/log/syslog Мне показалось
это неудобным, когда нужно было отладить работу нескольких скриптов,
работающих по расписанию.
-----------------------------------------------------------------------------
Для исправления ситуации и вынесения логов в отдельный файл нужно сделать
следующее. Открываем и редактируем файл /etc/rsyslog.conf
-----------------------------------------------------------------------------
# mcedit /etc/rsyslog.conf
-----------------------------------------------------------------------------
Ищем строку:
-----------------------------------------------------------------------------
cron.*                                  /var/log/cron.log
-----------------------------------------------------------------------------
И раскомментируем ее. Если такой нет, то добавляем. Чтобы логи не писались
в общий файл, ищем строку с
-----------------------------------------------------------------------------
*.*
-----------------------------------------------------------------------------
и добавляем туда cron.none. Должно получиться так:
-----------------------------------------------------------------------------
*.*;auth,authpriv.none,cron.none        -/var/log/syslog
-----------------------------------------------------------------------------
После этого перезапускаем rsyslog:
-----------------------------------------------------------------------------
# service rsyslog restart
-----------------------------------------------------------------------------
Проверяем, создался ли файл:
-----------------------------------------------------------------------------
# cd /var/log
# ls -l | grep cron
-rw-r----- 1 root        adm     140479 Апр 20 17:20 cron.log
-----------------------------------------------------------------------------
Все в порядке, теперь надо настроить ротацию этого файла. Редактируем
файл /etc/logrotate.d/rsyslog
-----------------------------------------------------------------------------
# mcedit /etc/logrotate.d/rsyslog
-----------------------------------------------------------------------------
Раскомментируем или добавим, если у вас нет строчку /var/log/cron.log
Файл должен выглядеть примерно так:
-----------------------------------------------------------------------------
/var/log/syslog
{
        rotate 7
        daily
        missingok
        notifempty
        delaycompress
        compress
        postrotate
                invoke-rc.d rsyslog rotate > /dev/null
        endscript
}

/var/log/mail.info
/var/log/mail.warn
/var/log/mail.err
/var/log/mail.log
/var/log/daemon.log
/var/log/kern.log
/var/log/auth.log
/var/log/user.log
/var/log/lpr.log
/var/log/cron.log
/var/log/debug
/var/log/messages
{
        rotate 4
        weekly
        missingok
        notifempty
        compress
        delaycompress
        sharedscripts
        postrotate
                invoke-rc.d rsyslog rotate > /dev/null
        endscript
}
-----------------------------------------------------------------------------
Теперь файл логов cron будет ротироваться как и все остальные
системные логи. На этом настройка логов cron на Debian закончена.

-----------------------------------------------------------------------------
==============================
#date/hwclock/timedatectl/ntp/chrony
==============================
-----------------------------------------------------------------------------
ls -l /etc/localtime
date
-----------------------------------------------------------------------------
$ date
# hwclock -r
# hwclock --show --utc
-----------------------------------------------------------------------------
# date -s "2 OCT 2006 18:00:00"
# date --set="2 OCT 2006 18:00:00"
# date +%Y%m%d -s "20081128"
# date +%T -s "10:13:13"
Set the Hardware Clock to the current System Time
# hwclock --systohc
# hwclock -w
-----------------------------------------------------------------------------
$ timedatectl
$ timedatectl status
# timedatectl set-time YYYY-MM-DD
$ sudo timedatectl set-time YYYY-MM-DD
# timedatectl set-time HH:MM:SS
# timedatectl set-time '10:42:43'
$ timedatectl list-timezones			Просмотреть список часовых поясов можно при помощи команды
$ timedatectl list-timezones | more
$ timedatectl list-timezones | grep -i asia
$ timedatectl list-timezones | grep America/New
$ timedatectl set-timezone <часовой пояс>	Установка нужного часового пояса осуществляется так
# timedatectl set-ntp yes
-----------------------------------------------------------------------------	
# timedatectl --help
timedatectl [OPTIONS...] COMMAND ...
 
Query or change system time and date settings.
 
  -h --help                Show this help message
     --version             Show package version
     --no-pager            Do not pipe output into a pager
     --no-ask-password     Do not prompt for password
  -H --host=[USER@]HOST    Operate on remote host
  -M --machine=CONTAINER   Operate on local container
     --adjust-system-clock Adjust system clock when changing local RTC mode
 
Commands:
  status                   Show current time settings
  set-time TIME            Set system time
  set-timezone ZONE        Set system time zone
  list-timezones           Show known time zones
  set-local-rtc BOOL       Control whether RTC is in local time
  set-ntp BOOL             Control whether NTP is enabled
-----------------------------------------------------------------------------
ntp
-----------------------------------------------------------------------------
yum install -y ntp
firewall-cmd --permanent --add-service=ntp
systemctl enable ntpd
systemctl start ntpd
/etc/ntp.conf -> server
# ntpq -p
# ntpstat
-----------------------------------------------------------------------------
To quickly synchronize a server, type:
# systemctl stop ntpd
# ntpdate pool.ntp.org
# systemctl start ntpd
-----------------------------------------------------------------------------
chrony
-----------------------------------------------------------------------------
timedatectl
...
NTP enabled: n/a
NTP synchronized: no
...
-----------------------------------------------------------------------------
yum install chrony
/etc/chrony.conf -> server
systemctl start chronyd && systemctl enable chronyd
firewall-cmd --permanent --add-service=ntp
-----------------------------------------------------------------------------
timedatectl
...
NTP enabled: yes
NTP synchronized: yes

# chronyc tracking
# chronyc sources -v
# ntpdate pool.ntp.org
-----------------------------------------------------------------------------
===============
L2.SECURITY
===============
-----------------------------------------------------------------------------
restore_passwd
-----------------------------------------------------------------------------
	Debian
-----------------------------------------------------------------------------
'e'
linux (linux16, linuxefi) -> rw, init=/bin/bash (plymouth.enable = 0)
F10 или Ctrl+x
# passwd
# mount -n -o remount,rw /
# /sbin/reboot -f
-----------------------------------------------------------------------------
После перезагрузки, в момент появления на экране меню загрузчика GRUB, 
выделяем нужную нам операционную систему и нажимаем 'e'.

Далее находим строку, которая начинается с linux (linux16, linuxefi),
в конце этой строки ищем ro (только чтение), меняет на rw (чтение и запись)
и дописываем init=/bin/bash. Если диск зашифрован, тогда необходимо дописать
plymouth.enable = 0. Все эти изменения действительны только в этом сеансе,
после перезагрузки пропадут.

Нажимаем F10 или Ctrl+x и загружаем командную строку.
Вводим новый password, через команду passwd:
root@(none):/# passwd

Вводим новый пароль, повторяем и если видим следующею ошибку: passwd:
Authentication token manipulation error — это означает, что каталог доступен
только для чтения ('ro' см.выше). Это можно исправить следующим обзором, пишем:
root@(none):/# mount -n -o remount,rw /

Перезагружаем компьютер:
root@(none):/# /sbin/reboot -f
-----------------------------------------------------------------------------
	CentOS 7
-----------------------------------------------------------------------------
'e'
linux16 -> (Ctrl + e) -> пишем - init=/bin/bash, удаляем rhgb quet, ro на rw
Ctrl + x
# passwd root
# touch /.autorelabel
# exec /sbin/init
-----------------------------------------------------------------------------
    Загружаемся, нажимаем e
    Находим строку linux16 ... переходим в конец строки (Ctrl + e), пишем - init=/bin/bash, удаляем rhgb quet
	На втором действии в той же строке надо поменять ro на rw, чтобы файловая система подмонтировалась в режиме записи.
	Раньше требовалось
		Выберите строку ядра. Добавьте 'single' в конец строки. Нажмите 'b' для загрузки. 
			Если система продолжает запрашивать пароль рута, добавьте в конец строки
			 init=/bin/bash Снова нажмите 'b' для загрузки
    Продолжаем загрузку Ctrl + x
    После появления интерпритатора с версией, в моем случае bash-4.2#
    Меняем пароль используя - passwd root
    Создаем файл touch /.autorelabel
	обновим информацию selinux, переазметка маркеров ФС
    Выполняем - exec /sbin/init
    Ждем пока завершатся оставшиеся загрузочные дйствия

Радуемся )
-----------------------------------------------------------------------------
	live CD
-----------------------------------------------------------------------------
fdisk -l
/dev/sda1
mkdir /media/linx_part
mount /dev/sda1 /media/linx_part
sudo chroot /media/sda1		Измените рута в примонтированном разделе
passwd
reboot

-----------------------------------------------------------------------------
attributs / umask
-----------------------------------------------------------------------------
lsattr		просмотра дополнительных атрибутов 
chattr		изменения дополнительных атрибутов

chattr +A file.txt
-----------------------------------------------------------------------------
A - не обновлять время доступа к объекту. Теоретически установка этого атрибута
	должна повысить производительность файловой системы и соответственно
	системы в целом.
а - указывает, что в файл можно добавлять информацию, но нельзя удалять.

d - указывает на то, что не нужно делать резервные копии файла.
	Файл будет проигнорирован командой dump.

i - указывает на то, что файл нельзя удалять и модифицировать.

s - указывает, что при удалении файла место где был размещен файл будет
	перезаписано нулями.
u - указывает на то, что при удалении файла его нужно куда-то сохранить.
-----------------------------------------------------------------------------
umask=0022	777-022=755, 666-022=644
-----------------------------------------------------------------------------
setuid
для исполняемых файлов
chmod u+s file1 - устанавливаем setuserid-бит
-----------------------------------------------------------------------------
Если бит setuid установлен для исполняемого файла (процесса), то работать
этот процесс будет не с правами пользователя, а с правами установленными для
процесса. Хорошим примером здесь служит команда passwd и файл passwd.
Выполнив команду ls -l /usr/bin/passwd увидим следующий результат:

igor@adm-ubuntu:~/linux/dir$ ls -l /usr/bin/passwd
-rwsr-xr-x 1 root root 41292 2009-07-31 16:55 /usr/bin/passwd

В первой тройке прав видим не rwx, а rws.
s - означает, что бит setuid установлен.

Теперь выполним команду ls -l /etc/passwd и посмотрим права на
текстовый файл passwd

igor@adm-ubuntu:~/linux/dir$ ls -l /etc/passwd
-rw-r–r– 1 root root 1785 2009-10-16 09:01 /etc/passwd

Видим, что право записи в этот файл имеет только пользователь root. Для
всех остальных есть право только на чтение. Если бы бит setuid не был бы
установлен для программы passwd, то обычный пользователь не смог бы изменить
свой пароль, так как программа passwd работала бы с правами пользователя,
который ее запустил. Но бит setuid установлен, а это значит, что программа
будет работать с правами своего владельца, а не пользователя запустившего
программу. Владелец у программы passwd - пользователь root, значит обычный
пользователь запустивший программу passwd сможет изменить свой пароль
(внести изменения в файл /etc/passwd).
-----------------------------------------------------------------------------
setgid
для каталога
chmod g+s file1 - устанавливаем setgroupid-бит
-----------------------------------------------------------------------------
Установленное свойство setgid для каталога означает, что все создаваемые
объекты внутри каталога будут в качестве группы владельца принимать группу
владельца каталога, а не пользователя создающего объект. Этот бит
используется для организации общедоступных каталогов для пользователей.
-----------------------------------------------------------------------------
sticky bit
для каталога
-----------------------------------------------------------------------------
sticky bit установленный для каталога, разрешает удалять и переименовывать
файлы этого каталога только для владельца и пользователя root, даже если
право записи будет установлено и для остальных пользователей.
-----------------------------------------------------------------------------
selinux
-----------------------------------------------------------------------------
/etc/selinux/config
-----------------------------------------------------------------------------
selinuxenabled с параметром 1 (включить SELinux) или 0 (выключить SELinux)
или
SELinux=disable/permissive/enforcing
# reboot
-----------------------------------------------------------------------------
Журналирование SELinux (аудит)
-----------------------------------------------------------------------------
    настройка auditallow - журналировать события.
    настройка dontaudit - не журналировать события.
-----------------------------------------------------------------------------
Логика работы:

    если операция allow, то она журналируется лишь в случае auditallow;
    если операция disallow, то она НЕ журналируется лишь в случае dontaudit.
-----------------------------------------------------------------------------

Security Enhanced Linux) это система безопасности основанная на моделях
мандатного и ролевого доступа.
-----------------------------------------------------------------------------
SELinux работает "после" DAC. То есть операции, запрещенные в DAC не могут
быть разрешены в SELinux.
-----------------------------------------------------------------------------
Субъекты и объекты
-----------------------------------------------------------------------------
Когда говорят о SELinux всегда упоминаются субъекты и объекты. То есть SELinux
это разрешения и запреты которые применяются в действиях между
субъектами и объектами.
-----------------------------------------------------------------------------
Субъекты - это пользователи. Под субъектами чаще всего подразумеваются 
программы (процессы). Иначе говоря субъекты это те кто выполняет некие действия.

Объекты - это то, над чем действия выполняются. Чаще всего под объектами
подразумеваются файлы данных. Но это могут быть и устройства и даже программы.
-----------------------------------------------------------------------------
Пример:
cat /var/log/syslog | grep SELinux
в этой команде программа grep объект для программы cat. И соответственно
программа cat субъект по отношению к программе grep.
-----------------------------------------------------------------------------
Контекст безопасности (метка, label) SELinux
-----------------------------------------------------------------------------
1. Типа данных или домена процесса— правила определяющие действия, разрешенные процессу.
2. Роль — список доменов.
3. Типа пользователя — действия, разрешенные применять к объекту. Применяется к каталогам,
файлам или сокетам.
4. Уровней и категорий (используется только в специальных политиках MLS/MCS,
в общих политиках эти значения установлены в полный доступ)
-----------------------------------------------------------------------------
Контекст безопасности записывается в атрибуты файла (в файловой системе) и
создается при установке SELinux (операция labeling). Уже присвоенный контекст
безопасности может быть впоследствии изменен - операция transition.
-----------------------------------------------------------------------------
Метка файла может оказаться неверной даже в случае если файловая система
поддерживает запись таких меток, но к файлу были неправильно применены операции
копирования или перемещения внутри файловой системы. Например при копировании
в другую папку файл может получить метку установленную для этой папки
(наследование меток), вместо той метки, которая у него была раньше. Поэтому
важно правильно выполнять операции копирования и перемещения файлов при
использовании SELinux.
-----------------------------------------------------------------------------
Пользователь SELinux
-----------------------------------------------------------------------------
Это описательный тип пользователя, а не какой-то конкретный пользователь с
логином и паролем. Принципиально это то же самое что и группа пользователей в
"старой" системе безопасности DAC. При добавлении, в систему, каждого нового
пользователя он по умолчанию (или явным образом) сопоставляется с каким-либо
типом пользователя SELinux и в дальнейшем будет иметь те разрешения или
запреты, которые указаны для его типа пользователя. 
-----------------------------------------------------------------------------
Роль
-----------------------------------------------------------------------------
Перечень разрешенных действий. Возможен переход из одной роли в другую, для
изменения полномочий. При этом идентичность пользователя не изменяется (в
отличии от команд su/sudo). Роли не совмещаются, они заменяют одна другую.

Политика безопасности определяет допустимые переходы из одной роли в другую.
То есть невозможно перейти из любой роли в любую роль. Поскольку роли всегда
связаны с типами (доменами), то часто говорят не о смене ролей, а о смене
домена (Domain Transition).
-----------------------------------------------------------------------------
Типы (домены) SELinux
-----------------------------------------------------------------------------
Также известны как SELinux sandbox. Объединяют субъекты и объекты в группы,
внутри этих групп определяют разрешенные действия субъектов над объектами.
Для субъектов вместо термина тип используется термин домен.
Упрощенно можно сказать так:
тип SELinux - для данных;
домен SELinux - для процессов.
В SELinux, в общих политиках, используется механизм принудительного присвоения типов - Type Enforcement. То есть каждый объект и субъект должен быть обязательно приведен к какому-либо типу (или домену).
-----------------------------------------------------------------------------
Режимы работы SELinux
-----------------------------------------------------------------------------
Enforcing — действия, нарушающие политику безопасности системы, блокируются,
и фиксируются в журнале безопасности.

Permissive — действия записываются в журнал безопасности, но не блокируются.

Disabled — действия не фиксируются и не блокируются.

-----------------------------------------------------------------------------
Policy
-----------------------------------------------------------------------------
 - Type Enforcment (TE) - Roles Based Access Control (RBAC).
Targeted и strict - наиболее широко используемые TE - RBAC политики SELinux.

 - Bell-La Padula Model Multi-Level Security (MLS) - Multi-Category
Security (MCS).

-----------------------------------------------------------------------------
targeted - все процессы не внесенные в специальные ограниченные домены,
работают в неограниченном домене unconfined_t. Таким образом осуществляется
возможность выполнения процессов которые еще не описаны в политике. Но такие
процессы фактически выполняются почти с административными правами. В этом
слабое место политики targeted.
-----------------------------------------------------------------------------
strict - все процессы работают в специальных ограниченных доменах, в
неограниченном домене unconfined_t никто не работает. Политика strict
используется узкоспециально, поскольку требуется ее ручная настройка для
каждого конкретного случая. Ведь процессы не описанные в этой политике просто
не будут работать. Но зато эта политика обеспечивает полную защиту в рамках
тех возможностей которые есть в SELinux.
-----------------------------------------------------------------------------
MLS
-----------------------------------------------------------------------------
Специальная политика основанная на механизме мандатного доступа. Всем
субъектам и объектам присваиваются уровни доступа. В дальнейшем разрешение
или запрет на операцию выдается по соотношению уровней доступа у субъекта и объекта.
Предмет разрешения только две операции - чтение из файла и запись в файл.
Важное отличие этой схемы заключается в том, что разрешения выдаются не на
файлы, а на потоки данных связанных с этими файлами.
-----------------------------------------------------------------------------
Правило такое - поток данных не может проходить в направлении понижения уровня
доступа. То есть от более высокого уровня к более низкому уровню. 
-----------------------------------------------------------------------------
Это приводит, на первый взгляд, к нелогичному запрету чтения или доступа в случае если
субъект и объект имеют разные уровни доступа. Например субъект с уровнем
доступа "секретно" не может писать в файл с уровнем "несекретно". И этот же
субъект с правом доступа "секретно" не может читать из файла с уровнем
"совершенно секретно", но может писать в этот файл.
-----------------------------------------------------------------------------
Странно?
-----------------------------------------------------------------------------
Однако, логика тут есть, просто она другая. Если субъект, имеющий уровень
"секретно", запишет данные в файл с уровнем "несекретно" то этот файл станет
(потенциально) содержать данные уровня "секретно", но при этом будет доступен
субъектам уровня "несекретно". То есть станет возможна утечка информации.
Поэтому в MLS запись в файлы разрешена только с нижних уровней на верхние.
-----------------------------------------------------------------------------
Эту особенность нужно понимать при присвоении меток уровней доступа.
-----------------------------------------------------------------------------
Помимо уровней, доступ дополнительно регулируется категориями. 
-----------------------------------------------------------------------------
Субъект не имеющий права доступа к категории "ВМС", не может получить доступ
к данным которые имеют метку этой категории. Даже если этот субъект имеет
самый высокий уровень доступа.
-----------------------------------------------------------------------------
В контексте SELinux запись об уровнях и категориях выглядит так:
"s0-s0:c0.c1023" 
где "s0-s0" допустимые уровни, а "c0.c1023" допустимые категории. Конкретно
такая запись - "s0-s0:c0.c1023" означает высший уровень доступа к любой
категории объектов.
-----------------------------------------------------------------------------
Эта часть контекста используется только в специальных политиках MLS/MCS. В
общих политиках типа targeted или strict эта часть контекста просто
установлена в максимальный уровень разрешений и таким образом не влияет на
доступ.
-----------------------------------------------------------------------------
Максимальную защиту SELinux дает когда переключен в режим enforced и при этом
используется политика strict или политика MLS/MCS.

Если SELinux работает в режиме permissive, то фактически никакой защиты нет -
только лишь фиксируются нарушения текущей политики.

Если SELinux переключен в режим enforced, но используется политика targeted,
то защита осуществляется только применительно к "известным" программам, для которых в политике определены разрешения и запреты. "Неизвестная" программа
фактически имеет административные привилегии.
-----------------------------------------------------------------------------
Команды
-----------------------------------------------------------------------------
# selinuxenabled 1	1 (включить SELinux) или 0 (выключить SELinux)
# sestatus		позволяется узнать текущий режим работы SELinux.
# setenforce 1		1 (включить enforced) или 0 (включить permissive)
-----------------------------------------------------------------------------
Узнать контексты SELinux можно используя стандартные команды с ключом -Z:
-----------------------------------------------------------------------------
    ps -eZ [| gerp имя_программы] : контекст SELinux для работающих программ
				(или для конкретной программы).
	Просмотр контекста безопасности SELinux для процесса ‘nginx’:
    ps axZ | grep nginxsystem_u:system_r:httpd_t:s0	
    ls -Z : контекст SELinux для файлов.
    ls -dZ : контекст SELinux для каталогов.
    id -Z : контекст SELinux для текущего пользователя.
-----------------------------------------------------------------------------
seinfo
-----------------------------------------------------------------------------
seinfo [OPTIONS] [EXPRESSION] [POLICY ...]

seinfo /path/to/policy
seinfo [options] /path/to/policy
-----------------------------------------------------------------------------
allows the user to query the components of a SELinux policy. 
-----------------------------------------------------------------------------
Expressions
-----------------------------------------------------------------------------

-c[NAME], --class[=NAME]
    Print a list of object classes or, if NAME is provided, print the object
class NAME. With -x, print a list of permissions for each displayed object class. 
--sensitivity[=NAME]
    Print a list of sensitivities or, if NAME is provided, print the
sensitivity NAME. With -x, print the corresponding level statement for each
displayed sensitivity. 
--category[=NAME]
    Print a list of categories or, if NAME is provided, print the category
NAME. With -x, print a list of sensitivities with which each displayed
category may be associated. 
-t[NAME], --type[=NAME]
    Print a list of types (not including aliases or attributes) or, if NAME
is provided, print the type NAME. With -x, print a list of attributes which
include each displayed type. 
-a[NAME], --attribute[=NAME]
    Print a list of type attributes or, if NAME is provided, print the
attribute NAME. With -x, print a list of types assigned to each displayed
attribute. 
-r[NAME], --role[=NAME]
    Print a list of roles or, if NAME is provided, print the role NAME.
With -x, print a list of types assigned to each displayed role. 
-u[NAME], --user[=NAME]
    Print a list of users or, if NAME is provided, print the user NAME.
With -x, print a list of roles assigned to each displayed user. 
-b[NAME], --bool[=NAME]
    Print a list of conditional booleans or, if NAME is provided, print
the boolean NAME. With -x, print the default state of each displayed
conditional boolean. 
--initialsid[=NAME]
    Print a list of initial SIDs or, if NAME is provided, print the initial
SID NAME. With -x, print the context assigned to each displayed SID. 
--fs_use[=TYPE]
    Print a list of fs_use statements or, if TYPE is provided, print the
statement for filesystem TYPE. There is no expanded information for this
component. 
--genfscon[=TYPE]
    Print a list of genfscon statements or, if TYPE is provided, print the
statement for the filesystem TYPE. There is no expanded information for this
component. 
--netifcon[=NAME]
    Print a list of netif contexts or, if NAME is provided, print the
statement for interface NAME. There is no expanded information for this
component. 
--nodecon[=ADDR]
    Print a list of node contexts or, if ADDR is provided, print the
statement for the node with address ADDR. There is no expanded information
for this component. 
--portcon[=PORT]
    Print a list of port contexts or, if PORT is provided, print the
statement for port PORT. There is no expanded information for this component. 
--protocol=PROTO
    Print only portcon statements for the protocol PROTO. This option is
ignored if portcon statements are not printed or if no statement exists
for the requested port. 
--constrain
    Print a list of constraints. There is no expanded information for
this component. 
--all
    Print all components.
-----------------------------------------------------------------------------
Options

-x, --expand
    Print additional details for each component matching the expression.
These details include the types assigned to an attribute or role and the
permissions for an object class. This option is not available for all
component types; see the description of each component for the details this
option will provide. 
--stats
    Print policy statistics including policy type and version information and
counts of all components and rules. 
-l
    Print line breaks when displaying constraint statements. 
-h, --help
    Print help information and exit. 
-V, --version
    Print version information and exit.
-----------------------------------------------------------------------------
# yum install setools-console

-----------------------------------------------------------------------------
Get information about /etc/selinux/targeted/policy/policy.24 policy, enter:
-----------------------------------------------------------------------------
# seinfo /etc/selinux/targeted/policy/policy.24 
-----------------------------------------------------------------------------
To list the number of types with the domain attribute, enter:
-----------------------------------------------------------------------------
# seinfo -adomain -x | less
-----------------------------------------------------------------------------
To print a list of user, enter:
-----------------------------------------------------------------------------
# seinfo -adomain -u
-----------------------------------------------------------------------------
To print a list of roles, enter:
-----------------------------------------------------------------------------
# seinfo -r
# seinfo -adomain -r
# seinfo -rsysadm_r -x | grep initrc_t 
-----------------------------------------------------------------------------
To print a list of conditional booleans:
-----------------------------------------------------------------------------
# seinfo -adomain -b
# seinfo -adomain -b | less
# seinfo -adomain -bssh_sysadm_login -x
-----------------------------------------------------------------------------
For more information read seinfo man page:
-----------------------------------------------------------------------------
# man seinfo
-----------------------------------------------------------------------------
# seinfo -x --type=httpd_log_t /etc/selinux/default/policy/policy.26
-----------------------------------------------------------------------------
# seinfo $SELINUX_SRC/policy.conf
-----------------------------------------------------------------------------
 Операции доступа и операции преобразования
-----------------------------------------------------------------------------
access - система выполняет чаще всего, например, открытие и чтение данных из
	файла.
-----------------------------------------------------------------------------
transition — операции, связанные с изменением контекста безопасности объектов.
-----------------------------------------------------------------------------
Список политик SELinux (вариантов защиты):
# getsebool -a	покажет вам все варианты защиты, которые вы можете изменить

# yum install policycoreutils-python
# semanage boolean -l
-----------------------------------------------------------------------------
Включить/выключить политику SELinux
-----------------------------------------------------------------------------
setsebool -P  on
setsebool -P  off
setsebool -P httpd_enable_homedirs on
setsebool -P httpd_can_network_connect on
-----------------------------------------------------------------------------
Узнать разметку файлов
-----------------------------------------------------------------------------
semanage fcontext -l | grep httpd
-----------------------------------------------------------------------------
Установить временные разрешения (будут работать до перезагрузки) для папки
-----------------------------------------------------------------------------
chcon -R -t httpd_sys_content_t /path/to/www
chcon -R -t httpd_sys_rw_content_t /path/to/www
-----------------------------------------------------------------------------
для файла
-----------------------------------------------------------------------------
chcon -t тип имя-файла
-----------------------------------------------------------------------------
Установить постоянные разрешения.
-----------------------------------------------------------------------------
Команда semanage fcontext -a -t не назначает контекст, а определяет
дальнейший способ маркировки, после нее необходимо выполнить restorecon для
восстановления контекста безопасности.
-----------------------------------------------------------------------------
semanage fcontext -a -t httpd_sys_content_t "/path/to/www(/.*)?"
semanage fcontext -a -t httpd_sys_rw_content_t "/path/to/www(/.*)?"
-----------------------------------------------------------------------------
Или
semanage fcontext --add --type httpd_log_t "/path/to/www/[^/]*/logdir(/.*)?"
-----------------------------------------------------------------------------
Затем
-----------------------------------------------------------------------------
restorecon -R /path/to/www
-----------------------------------------------------------------------------
system-config-selinux	показывает все политики, которые могут быть
			использованы в зависимости от установленных пакетов

system-config-selinux - графический интерфейс для управления настройками
			политик SELinux, если у вас имеется GUI (графический
			интерфейс пользователя).
Это можно сделать следующим образом:
# yum install policycoreutils-gui      
-----------------------------------------------------------------------------
Изменение контекста безопасности:
-----------------------------------------------------------------------------
# chcon -v --type=httpd_sys_content_t /var/www 
context of /var/www changed to user_u:object_r:httpd_sys_content_t
-----------------------------------------------------------------------------
Рекурсивное изменение контекста безопасности:
-----------------------------------------------------------------------------
# chcon -Rv --type=httpd_sys_content_t /var/www
-----------------------------------------------------------------------------
Сброс всех правил и восстановление дефолтного контекста безопасности для
определенного каталога:
-----------------------------------------------------------------------------
# restorecon -v /var/www
-----------------------------------------------------------------------------
Посмотреть список портов открытых для доступа:
-----------------------------------------------------------------------------
# semanage port -l
-----------------------------------------------------------------------------
Открыть доступ к портам:
-----------------------------------------------------------------------------
# semanage port -a -t http_port_t -p tcp 81
-----------------------------------------------------------------------------
Изменить любой параметр безопасности:
-----------------------------------------------------------------------------
# setsebool -P httpd_can_network_connect on
-----------------------------------------------------------------------------
Установить утилиты в CentOS
-----------------------------------------------------------------------------
# yum install policycoreutils-python
-----------------------------------------------------------------------------
Установить утилиты в Debian
-----------------------------------------------------------------------------
# sudo apt-get install selinux-utils
-----------------------------------------------------------------------------
Посмотреть состояние переменных в SELinux
-----------------------------------------------------------------------------
# getsebool -a | grep http
-----------------------------------------------------------------------------
Ограничить/разрешить отправку через sendmail
-----------------------------------------------------------------------------
# setsebool -P httpd_can_sendmail off
-----------------------------------------------------------------------------
Ограничить/разрешить внешние коннекты по сети
-----------------------------------------------------------------------------
# setsebool -P httpd_can_network_connect off
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
Дать права апачу на запись в каталог:
-----------------------------------------------------------------------------
# semanage fcontext -a -t httpd_sys_rw_content_t '/var/www(/.*)?/uploads(/.*)?'
# restorecon -R -v /var/www/
-----------------------------------------------------------------------------
Добавить нестандартный порт в число разрешенных
-----------------------------------------------------------------------------
Посмотреть какие порты сейчас разрешены:
-----------------------------------------------------------------------------
# semanage port -l | grep http_port_t
-----------------------------------------------------------------------------
Добавить порт:
-----------------------------------------------------------------------------
# semanage port -a -t http_port_t  -p tcp 10061
-----------------------------------------------------------------------------
Для работы wp-cron требуются права domain_kernel_load_modules
-----------------------------------------------------------------------------
# setsebool -P domain_kernel_load_modules on
-----------------------------------------------------------------------------
Создание политики с нуля:
-----------------------------------------------------------------------------
Для того, что бы сделать политику на основе ошибок аудита в логах или узнать
какие переменные нужно выставить можно использовать утилиту audit2allow для
этого следует поставить пакет policycoreutils-python
-----------------------------------------------------------------------------
# yum install policycoreutils-python
# grep ftpd /var/log/audit/audit.log | audit2allow -v
-----------------------------------------------------------------------------
 Настройка SELinux для пользователей
-----------------------------------------------------------------------------
Чтобы просмотреть состояние пользователей используйте команду :
-----------------------------------------------------------------------------
semanage login -l
-----------------------------------------------------------------------------
Пример добавления (-a) специфической роли (-s) user_u для пользователя user_name:
-----------------------------------------------------------------------------
semanage login -a -s user_u user_name
-----------------------------------------------------------------------------
Чтобы удалить политику SELinux у конкретного пользователя воспользуйтесь командой:
-----------------------------------------------------------------------------
semanage -d user_name
-----------------------------------------------------------------------------
Для того чтобы изменить политику SELinux для всех новых пользователей нужно
изменить политику у пользователя по умолчанию. После этого все вновь
создаваемые пользователи сразу будут иметь нужную вам политику. Например :
-----------------------------------------------------------------------------
semanage login -m -S targeted -s "user_u" -r s0 __default__
-----------------------------------------------------------------------------
     -m - модификация
    -S targeted - целевой политики
    -s "user_u" - пользователь SELinux
    -r s0 - диапазон MLS
    __default__ - для пользователя по умолчанию. 
-----------------------------------------------------------------------------
Таблица выбора пользовательских ролей SELinux 
-----------------------------------------------------------------------------
Роль 		Имеющиеся права
guest_u 	Нет GUI, нет сети, нет доступа к su или sudo команд
xguest_u 	Есть GUI, сеть только через веб браузер Firefox
user_u 		Полный доступ к GUI и сети
staff_u 	Полный доступ к GUI, сети и выполнение команд sudo
unconfined_u 	Полный доступ к системе 
-----------------------------------------------------------------------------
Пример команды для полного доступа пользователям по умолчанию :
-----------------------------------------------------------------------------
semanage login -m -S targeted -s "unconfined_u" -r s0-s0:c0.c1023 __default__

    где s0-s0:c0.c1023 - полный доступ по MLS 
-----------------------------------------------------------------------------
 Управление SELinux через переключатели
-----------------------------------------------------------------------------
Команда показывает можно ли пользователям выполнять(on) или нельзя(off)
скрипты в своей директории или в директории /tmp
-----------------------------------------------------------------------------
getsebool allow_user_exec_content
-----------------------------------------------------------------------------
Запрещение выполнение скриптов для пользователей:
-----------------------------------------------------------------------------
setsebool allow_user_exec_content off
-----------------------------------------------------------------------------
    Эти изменения действуют только до перегрузки системы, если нужны
постоянные изменения то используйте флаг -P 
-----------------------------------------------------------------------------
Для поле полной справки по командам используйте:
-----------------------------------------------------------------------------
semanage boolean -l
-----------------------------------------------------------------------------
Просмотр и переопределение контекста SELinux для файлов 
-----------------------------------------------------------------------------
Таблица соответсвия пользователей и SELinux 
-----------------------------------------------------------------------------
Пользователь SELinux 	Соответствие
user_u 			обычные пользователи
system_u 		пользователи системы
unconfined_u 		неограниченные пользователи
-----------------------------------------------------------------------------
Список текущего SELinux контекста для файла :
-----------------------------------------------------------------------------
# ls -Z
# getfattr -n security.selinux &lt;file_name&gt;
-----------------------------------------------------------------------------
В выводе видно четыре элемента SELinux :
user(пользователь), role(роль), type(тип), и уровень MLS.
Причем основной контекст для файлов это тип. Например вывод :
-----------------------------------------------------------------------------
# ls -Z /var/ftp/
drwxr-xr-x root root system_u:object_r:public_content_t pub
-----------------------------------------------------------------------------
    system_u - системный пользователь
    object_r - системный объект
    public_content_t - для раздачи всем 
-----------------------------------------------------------------------------
Если вы создали свой каталог ftp и хотите чтобы работал доступ для всех
пользователей вы должны исправить на этом каталог контекст SELinux:
-----------------------------------------------------------------------------
chcon -R -u system_u -t public_content_t /opt/ftp

    флаг -R указывает что нужно применять на всех файлах внутри каталога. 
-----------------------------------------------------------------------------
Для создания на ftp сервера каталога куда можно загружать файлы используйте
команду:
-----------------------------------------------------------------------------
    chcon -R -u system_u -t public_content_rw_t /opt/ftp 
-----------------------------------------------------------------------------
Чтобы клонировать права SELinux можно использовать ключ:
-----------------------------------------------------------------------------
chcon -R --reference-/var/ftp /opt/ftp
-----------------------------------------------------------------------------
По умолчанию контексты для файлов находятся в файле
/etc/selinux/targeted/contexts/files/file_contexts Для востановления
контекста по умолчанию используйте команду:
-----------------------------------------------------------------------------
restorecon -F /каталог
-----------------------------------------------------------------------------
Или например:
-----------------------------------------------------------------------------
restorecon -v -R /var/www/
-----------------------------------------------------------------------------
Написание собственой политики 
-----------------------------------------------------------------------------
ВНИМАНИЕ:
«Прежде чем дать права доступа домену, следует немного подумать. Простая
прогонка сообщений об отказе через audit2allow часто приводит к чрезмерно
попустительской политике. Добавляйте только те разрешения, которые считаете
действительно необходимыми, и обязательно затем проверяйте, работает ли
приложение правильно. Используйте dontaudit для прав доступа, которые не
нужны домену.» Дэвид Капланко [David Caplanco], соавтор SELinux By Example
(Prentice Hall, 2007)
-----------------------------------------------------------------------------
Для начала нужно установить дополнительные утилиты:
-----------------------------------------------------------------------------
yum install -y setools-console policycoreutils-python
-----------------------------------------------------------------------------
После этого обнулим лог:
-----------------------------------------------------------------------------
cat /dev/null > /var/log/audit/audit.log
-----------------------------------------------------------------------------
Запустим свое приложение и дождемся возникновения ошибки. Проанализируем
ошибку и сгенерим свое правило:
-----------------------------------------------------------------------------
# grep smtpd_t /var/log/audit/audit.log | audit2allow -m postgreylocal > postgreylocal.te
# cat postgreylocal.te

# grep smtpd_t /var/log/audit/audit.log | audit2allow -M postgreylocal 
# cat /var/log/audit/audit.log | audit2allow -M appfirst
-----------------------------------------------------------------------------
Можно обойтись и без чистки лога но нужно знать какую ошибку ищем, пример:
-----------------------------------------------------------------------------
grep appfirst /var/log/audit/audit.log | audit2allow -M appfirst
-----------------------------------------------------------------------------
ПРИМЕЧАНИЕ:
При генерации нового правила создается текстовый файл, и командой
cat appfirst.te
можно просмотреть добавлемое правило.
-----------------------------------------------------------------------------
Активируем полученное правило правило:
-----------------------------------------------------------------------------
# semodule -i postgreylocal.pp 
# semodule -i appfirst.pp
-----------------------------------------------------------------------------
вывести список всех загруженных модулей при помощи команды 
-----------------------------------------------------------------------------
# semodule -l
-----------------------------------------------------------------------------
Проверим лог на возникновение ошибок.
-----------------------------------------------------------------------------
seaudit-report /var/log/audit/audit.log
-----------------------------------------------------------------------------
DONTAUDIT
-----------------------------------------------------------------------------
# grep postdrop /var/log/audit/audit.log | audit2allow -M postfixlocal
# cat postfixlocal.te
    module postfixlocal 1.0;
    require {
            type httpd_log_t;
            type postfix_postdrop_t;
            class dir getattr;
            class file { read getattr };
    }
    #============= postfix_postdrop_t ==============
    allow postfix_postdrop_t httpd_log_t:file getattr; -----------------------------------------------------------------------------
Сразу же возникает вопрос, зачем PostDrop пытается получить доступ к /var/log/httpd/error_log? Это не то действие, которое мы могли бы ожидать от этой программы, так что теперь только нам решать позволять это действие или нет.
-----------------------------------------------------------------------------
У нас есть несколько путей решения этой проблемы.

— Мы можем игнорировать эту ошибку и позволить SELinux блокировать доступ к файлу.

— Мы можем позволить это действие, создав соответствующий модуль политики при помощи audit2allow.
— Мы можем вручную отредактировать файл этого модуля, чтобы определить нужную нам реакцию SELinux на попытку доступа к файлу. Например, мы можем запретить аудит этого события, блокируя в тоже время доступ. Для этого мы должны изменить значение «allow» в соответствующей строке на «dontaudit»:
-----------------------------------------------------------------------------
#============= postfix_postdrop_t ==============
dontaudit postfix_postdrop_t httpd_log_t:file getattr;

-----------------------------------------------------------------------------
Теперь мы должны вручную скомпилировать и загрузить отредактированный модуль политики:

# checkmodule -M -m -o postfixlocal.mod postfixlocal.te
# semodule_package -o postfixlocal.pp -m postfixlocal.mod
# semodule -i postfixlocal.pp 
-----------------------------------------------------------------------------
Таким образом доступ к файлу /var/log/httpd/error_log блокируется, но мы не получаем постоянных предупреждений об этом от SELinux.
-----------------------------------------------------------------------------
Ошибки/Блокировки
-----------------------------------------------------------------------------
— Неправильно маркированный файл.
— Предоставление доступа к портам.
— Процесс работает в неправильном контексте
— Ошибка в политике. Процесс требует доступ к файлу, который не был учтен при создании политики.
— Возможные причины блокировок без оповещения
— Разрешающие домены
— Поиск и просмотр блокировок
-----------------------------------------------------------------------------
Изменение меток контекста безопасности файлов
-----------------------------------------------------------------------------
# sealert -a /var/log/audit/audit.log > /path/to/mylogfile.txt
# ls -dZ /srv/myweb

# chcon -v --type=httpd_sys_content_t /srv/myweb	Действует до перезагрузки
или
Корректно работает даже после изменения меток файловых систем
# /usr/sbin/semanage fcontext -a -t httpd_sys_content_t "/srv/myweb(/.*)?"
и
# /sbin/restorecon -R -v /srv/myweb
или
Изменение меток для всей файловой системы
# touch /.autorelabel
# reboot 
-----------------------------------------------------------------------------
 Как определить правильный контекст?
-----------------------------------------------------------------------------
# /usr/sbin/matchpathcon -V /var/www/html/*
-----------------------------------------------------------------------------
Как работают ограниченные службы?
-----------------------------------------------------------------------------
# /usr/sbin/getsebool -a | grep httpd
# /usr/sbin/setsebool -P httpd_can_network_connect_db on
-----------------------------------------------------------------------------
Предоставление доступа к портам
-----------------------------------------------------------------------------
# semanage port -l
# semanage port -l | grep http
# semanage port -a -t http_port_t -p tcp 81
-----------------------------------------------------------------------------
Возможные причины блокировок без оповещения
-----------------------------------------------------------------------------
В некоторых ситуациях, блокировки AVC могут не журналироваться, когда SELinux блокирует доступ. Приложения и функции системных библиотек часто требуют большего доступа, чем нужно, для выполнения своих задач. Для поддержки минимальных доступов без заполнения журналов аудита, блокировками AVC о безвредных запросах приложений, политика может выполнять блокировки AVC без сообщений, не разрешая доступ, используя правила dontaudit. Эти правила общие в стандартной политике. Плохая сторона dontaudit заключается в том, что, хотя SELinux блокирует доступ, сообщения о блокировке не журналируются, таким образом, делая разбор и устранение ошибок сложным. 
-----------------------------------------------------------------------------
# /usr/sbin/semodule -DB	Для временного отключения правил dontaudit

Опция -D отключает правила dontaudit; опция -B перестраивает политику
-----------------------------------------------------------------------------
# /usr/sbin/semodule -B		 Для перестройки политики и включения правил dontaudit
-----------------------------------------------------------------------------
# sesearch --dontaudit -s smbd_t | grep squid	Для вывода всех правил dontaudit

Сузить поиск можно с использованием опции -s domain и команды grep.
-----------------------------------------------------------------------------
Разрешающие домены
semanage permissive -a domain
-----------------------------------------------------------------------------
# /usr/sbin/semanage permissive -a httpd_t	чтобы сделать домен разрешающим
-----------------------------------------------------------------------------
# /usr/sbin/semodule -l | grep permissive	Для просмотра доменов в
						разрешающем режиме
-----------------------------------------------------------------------------
# /usr/sbin/semanage permissive -d httpd_t	чтобы домен стал enforcment
-----------------------------------------------------------------------------
Поиск и просмотр блокировок
-----------------------------------------------------------------------------
пакеты setroubleshoot, setroubleshoot-server, dbus и audit установлены, и сервисы 
auditd, rsyslogd и setroubleshootd запущены
-----------------------------------------------------------------------------
ausearch
-----------------------------------------------------------------------------
The ausearch tool accesses /var/log/audit/audit.log
-----------------------------------------------------------------------------
все блокировки				/sbin/ausearch -m avc
блокировки за сегодняшний день		/sbin/ausearch -m avc -ts today
блокировки за последние 10 минут	/sbin/ausearch -m avc -ts recent

Для поиска блокировок SELinux для определенной службы, используется опция
-c comm-name, где comm-name "исполняемое имя файла"[15], например, httpd 
для Apache HTTP Server и smbd для Samba:

# /sbin/ausearch -m avc -c httpd
# /sbin/ausearch -m avc -c smbd 
-----------------------------------------------------------------------------
aureport
-----------------------------------------------------------------------------
aureport is a tool that produces summary reports of the audit system logs
The aureport tool accesses /var/log/audit/audit.log
-----------------------------------------------------------------------------
# /sbin/aureport -a
-----------------------------------------------------------------------------
sealert
-----------------------------------------------------------------------------
setroubleshoot-server предоставляет sealert, которая читает сообщения о блокировках, транслированные setroubleshoot-server. Блокировкам назначаются ID, как показано в /var/log/messages
-----------------------------------------------------------------------------
# sealert -l \*		для просмотра детального анализа всех блокировок. 
-----------------------------------------------------------------------------
# sealert -l 84e0b04d-d0ad-4347-8317-22e74f6cd020

покажет детальный анализ причины, почему SELinux блокировал доступ и возможное решение предоставления доступа.
-----------------------------------------------------------------------------
# sealert -a /var/log/audit/audit.log -H > audit.html

для создания HTML версии анализа sealert
-----------------------------------------------------------------------------
aparmore
-----------------------------------------------------------------------------
1. sudo apparmor_status
-----------------------------------------------------------------------------
8. AppArmor можно отключить, а модуль ядра выгрузить следующей командой:

sudo /etc/init.d/apparmor stop
sudo update-rc.d -f apparmor remove
aptitude remove apparmor apparmor-utils
-----------------------------------------------------------------------------
9. Для повторной активации AppArmor введите:

sudo /etc/init.d/apparmor start
sudo update-rc.d apparmor defaults
-----------------------------------------------------------------------------
su/sudo
-----------------------------------------------------------------------------
Создание пользователя sudo в CentOS/Debian
-----------------------------------------------------------------------------
# adduser username
# passwd username
# usermod -aG wheel username
# usermod -aG sudo username
# su - username
# sudo command_to_run
-----------------------------------------------------------------------------
1. Использование команды: su
-----------------------------------------------------------------------------
Многие команды могут быть запущены только суперпользователем, поэтому мы
должны знать, как становится им (root-ом). Чтобы сделать это, мы можем
использовать команду: su (смена пользователя). Команда su принимает следующие
форматы:
-----------------------------------------------------------------------------
su - 

или

su 
-----------------------------------------------------------------------------
но чаще всего мы будем использовать su для того, чтобы стать пользователем root:
-----------------------------------------------------------------------------
su - root

или

su root
-----------------------------------------------------------------------------
если имя пользователя в строке не указано, то автоматически предпологается
пользователь root, поэтому команду можно сократить:
-----------------------------------------------------------------------------
su -

или

su
-----------------------------------------------------------------------------
но обе команды ведут себя различно. 'su ' дает текущему пользователю личность
, тогда, как 'su - ' дает текущему пользователю личность вместе с окружением,
которое можно было бы получить, зарегистрировавшись в качестве .

Зачастую пользователи используют 'su' для перехода в root. Попробовав
запустить команду (например - ifconfig), вы получите: 'command not found' error.
-----------------------------------------------------------------------------
Пример:

su
Password:
ifconfig
bash: ifconfig: command not found
-----------------------------------------------------------------------------
Причина заключается в том, что обычные пользователи системы и root
пользователь имеют различные переменные окружения PATH (вы можете посмотреть
PATH пользователя при помощи "echo $PATH). После ввода команды Linux, оболочка
будет искать пользовательский PATH, чтобы попытаться найти команду для запуска.
Она начинает поиск в каждой директории указанной в PATH, пока цель не будет
найдена.
-----------------------------------------------------------------------------
Команды обычных пользователей обычно расположены в /usr/local/bin, /usr/bin
и /bin. А команды пользователя root распологаются в основном в /usr/local/sbin,
/usr/sbin, /sbin и корневой PATH это отражает. Поэтому, когда вы становитесь
суперпользователем при помощи "su -", то вы также принимаете и новый путь
PATH к основным командам. А используя только 'su', сохраняется пользовательский
путь PATH по умолчанию, следовательно, при попытке выполнить программу
расположенную в /usr/local/sbin, /usr/sbin, /sbin выдаст результат: 'command
not found' error. Для более детального объяснения, смотрите справочную страницу
(man bash), особенно раздел login shells.
-----------------------------------------------------------------------------
Таким образом, вы или должны указывать полный путь к команде
(пример - /sbin/ifconfig) при использовании 'su', либо использовать 'su -',
когда становитесь root-ом.
-----------------------------------------------------------------------------
2. Использование Sudo:	visudo
-----------------------------------------------------------------------------
Вам не нужно быть суперпользователем каждый раз, когда вы хотите запустить
некоторые конкретные административные функции. Благодаря Sudo, вы можете
запустить некоторые или все команды как под root-ом. Когда Sudo установлен
(пакет: Sudo), вы можете настроить его при помощи команды 'visudo' под
root-ом. В основном он редактирует (Vim по умолчанию) /etc/sudoers, но это
не рекомендуется делать вручную.
-----------------------------------------------------------------------------
Таким образом, быстрый и нерекомендуемый способ использования Sudo, это
добавить в конце файла sudoers:
-----------------------------------------------------------------------------
alex ALL=(ALL)ALL
-----------------------------------------------------------------------------
Alex - имя пользователя. Сохраните (нажать escape, затем ввести wq), и все
готово. Войдите как alex, и запустите например:
-----------------------------------------------------------------------------
$sudo yum update
-----------------------------------------------------------------------------
Sudo запросит пароль. Это пароль alex-а, а не пользователя root. Так что
будте осторожны, когда вы даете права пользователя с Sudo.
-----------------------------------------------------------------------------
Но Sudo может сделать не только это, а гораздо больше. Мы можем позволить
пользователю или группе пользователей запускать только одну команду или
группу команд. Давайте вернемся к нашему sudoers файлу. Начнем с alex и alisa,
членов группы administrator. Если мы хотим, чтобы все пользователи из
группы"administrator" были в состоянии запустить каждую команду в качестве
суперпользователя, мы должны изменить наш пример:
-----------------------------------------------------------------------------
%admin ALL=(ALL)ALL
-----------------------------------------------------------------------------
Alex так же может выполнить суперпользовательскую команду, и alisa получила
право запускать Sudo, с теми же правами и со своим паролем. Если alex и alisa
не члены одной группы, мы можем определить псевдоним пользователя в файле sudoers:
-----------------------------------------------------------------------------
User_Alias ADMINS = alisa,alex
-----------------------------------------------------------------------------
Здесь мы определили алиас под названием ADMINS, с членами alisa и alex.
-----------------------------------------------------------------------------
Тем не менее, мы не хотим, чтобы alex и alisa могли запускать с правами
суперпользователя любую програму. Мы хотим, чтобы они могли запускать только
'updatedb'. Давайте определим команду псевдоним:
-----------------------------------------------------------------------------
Cmnd_Alias LOCATE = /usr/sbin/updatedb
-----------------------------------------------------------------------------
Но этого мало! Мы должны сказать Sudo, что пользователи, определенные как
ADMINS, могут запускать команды заданные в LOCATE. Чтобы сделать это, мы
заменим строки с "%admin" на эти:
-----------------------------------------------------------------------------
ADMINS ALL = LOCATE
-----------------------------------------------------------------------------
Это означает, что пользователи входящие в алиас ADMINS могут запускать все
команды в алиасе LOCATE.
-----------------------------------------------------------------------------
На этот раз, /etc/sudoers выглядит следующим образом:
-----------------------------------------------------------------------------
User_Alias ADMINS = alisa, alex
Cmnd_Alias LOCATE = /usr/bin/updatedb
ADMINS ALL = LOCATE
-----------------------------------------------------------------------------
В результате alex и alisa могут запускать updatedb, как root, введя свой пароль.
-----------------------------------------------------------------------------
Если последнюю строчку в файле изменить:
-----------------------------------------------------------------------------
ADMINS ALL = NOPASSWD:LOCATE
-----------------------------------------------------------------------------
тогда alex и alisa смогут выполнить 'sudo updatedb' без ввода пароля.
-----------------------------------------------------------------------------
Можно добавить другие команды в командный алиас и более алиасов в правило.
Например мы можем создать алиас NETWORKING содержащий некоторые сетевые команды типа: ifconfig, route или iwconfig:
-----------------------------------------------------------------------------
Cmnd_Alias NETWORKING = /sbin/route, /sbin/ifconfig, /bin/ping, /sbin/dhcclient,
/usr/bin/net, sbin/iptables, /usr/bin/rfcom, /usr/bin/wvdial, /sbin/iwconfig,
/sbin/mii-tool
-----------------------------------------------------------------------------
Давайте все это добавим в наш /etc/sudoers файл (с помощью visudo!). А также
предоставим нашей ADMINS групе права на выполнение программ и из алиаса NETWORKING:
-----------------------------------------------------------------------------
User_Alias ADMINS = alice, bob
Cmnd_Alias LOCATE = /usr/bin/updatedb
Cmnd_Alias NETWORKING = /sbin/route, /sbin/ifconfig, /bin/ping, /sbin/dhclient,
/usr/bin/net,/sbin/iptables,
/usr/bin/rfcomm, /usr/bin/wvdial, /sbin/iwconfig, /sbin/mii-tool
ADMINS ALL = LOCATE, NETWORKING 
-----------------------------------------------------------------------------
Маленькая проба: войдите в систему как alisa (или alex), и наберите:
-----------------------------------------------------------------------------
$ping -c 10 -i localhost
Ответ должен вернуться быстро:
PING localhost.localdomain (127.0.0.1) 56(84) bytes of data.
ping: cannot flood; minimal interval, allowed for user, is 200ms
-----------------------------------------------------------------------------
Теперь, тоже-самое но с Sudo:
-----------------------------------------------------------------------------
$sudo ping -c 10 -i 0 localhost
PING localhost.localdomain (127.0.0.1) 56(84) bytes of data.
64 bytes from localhost.localdomain (127.0.0.1): icmp_seq=1 ttl=64 time=0.049 ms
-----------------------------------------------------------------------------
Sudo часто используется для предоставления определенным пользователям частичного
доступа к привелигированным командам, чтобы они могли выполнять ограниченные
административные функции. Одно из удобств Sudo в том, что все команды записываются
в /var/log/secure. Приведенный выше пример будет описан строчкой в журнале:
-----------------------------------------------------------------------------
Apr 18 11:23:17 localhost sudo: alex  : TTY=pts/0 ; PWD=/home/alex ; USER=root
; COMMAND=/bin/ping -c 10 -i 0 localhost 
-----------------------------------------------------------------------------
Вот и все. Теперь никогда не забуду, когда использовал Sudo: "с большой
властью приходит большая ответственность".
-----------------------------------------------------------------------------
2.1 Sudo shell
-----------------------------------------------------------------------------
Если у вас настроено достаточно прав в sudoers, вы также можете открыть
root-ую оболочку shell используя:
-----------------------------------------------------------------------------
sudo -s
-----------------------------------------------------------------------------
это может менять или создавать новые файлы в домашней директории Root, а
установку вести в домашний каталог вызвавшего пользователя.

-----------------------------------------------------------------------------
acl
-----------------------------------------------------------------------------
ugo
Бит r - это 4, бит w - это 2, бит x - это 1. 
1 - для sticky bit, 2 - для setgid, 4 - для setuid
-----------------------------------------------------------------------------
Пример, chmod 4666 file1 установит помимо прочих прав и бит setuid.
-----------------------------------------------------------------------------
chown newuser:newgroup file
chown -R newuser:newgroup /dir
chmod  ug+wx file1 - добавляем права записи и выполнения для владельца и группы.
chmod o-rwx file1 - забираем все права (rwx) для остальных пользователей.
chmod a-wx file1 - забираем все права на записи и выполнение для всех
		пользователей. ugo равно a, то есть можно было бы написать
		ugo-wx - это равнозначно a-wx.
chmod ug=rw file1 - устанавливаем права. Не добавляем как с +, а именно
			устанавливаем. То есть если права были –xr-xr–, то
			после данной команды будет rw-rwr–.
chmod u+s file1 - устанавливаем setuserid-бит.
chmod g+s file1 - устанавливаем setgroupid-бит.
-----------------------------------------------------------------------------
user management	useradd/del,groupadd/del,chmod/chown
-----------------------------------------------------------------------------
/etc/passwd
/etc/shadow
/etc/group

Если перед любым хешем пароля в файле /etc/shadow поставить символ ! или *,
то такой пароль будет признан недействительным и учетная запись будет
заблокирована.

adduser	user	позволяет создать учетную запись в интерактивном режиме

deluser	user	
		Если необходимо удалить пользователя без удаления его файлов
		(домашнего каталога, каталога с почтовым ящиком), то команда
		выполняется без ключей

deluser	user –remove-home

		Чтобы удалить домашний каталог и почтовый ящик (обычно 
		расположен в каталоге /var/mail/) пользователя необходимо
		ввести команду deluser с ключом –remove-home

deluser	user –remove-all-files

		Если необходимо удалить все файлы пользователя, то необходима
		задать ключ –remove-all-files. Но операция удаления с этим
		ключом потребует больше времени, так как система будет искать
		все файлы данного пользователя на жестком диске

usermod		Для изменения параметров уже созданного пользователя

usermod -L user заблокирует учетную запись user
usermod -U user разблокирует.

passwd user	позволяет изменить пароль пользователя

addgroup user group1	Добавляется пользователь 'user' в группу 'group1'

delgroup имя_группы	Для удаления группы

groupmod		для изменения информации о группе

delgroup user group1	Удаляется пользователь 'user' из группы 'group1'
-----------------------------------------------------------------------------
useradd -g users -G admins,ftp,www,developers -s /bin/bash -p xxxx -d /home/ghost -m vivek

    -d домашний каталог
    -s задать стартовую оболочку (/bin/sh) - после можно изменить в файле /etc/passwd
    -p пароль
    -g основная группа, к которой приписывается пользователь (Группа должна существовать)
    -G другие группы к которой приписывается пользователь
    -m создать для пользователя домашний каталог
    xxxx символьный пароль пользователя

userdel -r vivek

    -r удалить пользователя вместе с домашним каталогом

-----------------------------------------------------------------------------
===============
L3.LAN
===============
-----------------------------------------------------------------------------
IPv4, IPv6
-----------------------------------------------------------------------------
	Расчет сети класса С
-----------------------------------------------------------------------------
Формула расчета количества сетей 2^n
Формула расчета количества хостов 2^n – 2  
-----------------------------------------------------------------------------
n – количество бит маски = 1 в октете хоста
-----------------------------------------------------------------------------
2^1 = 2, 2^2 = 4, 2^3 = 8, 2^4 = 16, 2^5 = 32, 2^6 = 64, 2^7 = 128, 2^8 = 256
-----------------------------------------------------------------------------
Пример
-----------------------------------------------------------------------------
У нас есть адрес сети 192.168.1.0/24, нам надо разделить имеющуюся сеть на 2 подсети.
Попробуем забрать от порции хоста 1 бит и воспользоваться формулой: 2^1=2.
Красным пометил порцию подсети, а синим – порцию хоста. 
1) 11000000.10101000.00000001.00000000 = 192.168.1.0/25
2) 11000000.10101000.00000001.10000000 = 192.168.1.128/25 
Всё, сеть разделена на 2 подсети. Как мы видим выше, порция хоста теперь составляет 7 бит. 
2^7 - 2 = 126 хостов. В начале статьи было сказано, что вычитаемая
цифра 2 является двумя адресами, которые нельзя присвоить хосту: адрес сети и широковещательный адрес.
11000000.10101000.00000001.00000000 = 192.168.1.0/25 (адрес сети первой подсети) 
11000000.10101000.00000001.01111111 = 192.168.1.127/25 (широковещательный адрес первой подсети) 
11000000.10101000.00000001.10000000 = 192.168.1.128/25 (адрес сети второй подсети) 
11000000.10101000.00000001.11111111 = 192.168.1.255/25 (широковещательный адрес второй подсети)
-----------------------------------------------------------------------------
  	Расчет сети класса B
-----------------------------------------------------------------------------
Есть 172.16.0.0 с маской 255.255.240.0 
Чтобы расчитать кол-во адресов в подсети, нужно шаг умножить на 256,
получаем 16*256=4096. И от 4096 отнимаем 2, потому как адрес сети и броадкаст еще есть.
Тоже самое, но только с префиксом. С маской 255.255.240.0 префикс будет /20.
Возвращаемся к таблице степеней 2-ки.
Стандартное количество бит в префиксе
для сети класса В — /16, максимальное количество бит в маске 32.
Количество адресов в подсети 2 ^(32 — 20) = 2 ^12 = 4096
Количество подсетей 2 ^(20 — 16) = 2 ^4 = 16
Итак, из одной сети класа В 172.16.0.0 / 255.255.240.0 получается 16 подсетей
по 4096 адресов ( 4094 адреса для хостов, а 2 адреса — адрес сети и броадкаст)
если использовать маску 255.255.240.0 или префикс /20.
-----------------------------------------------------------------------------
Cisco формула расчёта хостов (узлов)
-----------------------------------------------------------------------------
Количество хостов в подсети = 2n-2, где n – это количество свободных бит
(нулей) в порции хоста, а «-2» - это вычет адреса сети (в порции хоста все нули)
и широковещательного адреса (в порции хоста все единицы). 
Объяснение формул расчета сетей
IP адрес
IP адрес состоит из 32 битов, которые поделены на 4 части по 8 бит
соответственно (эти части называются октетами). В жизни используется запись
IP адреса в десятичном виде. 
Примеры IP адресов: 
172.16.2.15 = 10101100.00010000.00000010.00001111 
178.68.128.168 = 10110010.01000100.10000000.10101000 
217.20.147.94 = 11011001.00010100.10010011.01011110 
Из этих 32 битов часть относится к адресу хоста, которому принадлежит этот
IP адрес, а другая часть относится к адресу сети, в которой находится этот
хост. Первая часть (слева направо) IP адреса обозначает адрес сети, а вторая
часть (оставшиеся биты) – адрес хоста. Чтобы узнать, сколько битов относится
к адресу сети, надо воспользоваться маской сети. 
Маска сети
Маска сети тоже состоит из 32 битов, но в отличие от IP адреса, в маске
единицы и нолики не могут перемешиваться. В жизни используется запись
сетевой маски в десятичном виде. 
Примеры масок сети: 
255.255.255.0 = 11111111.11111111.11111111.00000000 
255.0.0.0 = 11111111.00000000.00000000.00000000 
255.255.240.0 = 11111111.11111111.11110000.00000000 
255.255.255.128 = 11111111.11111111.11111111.10000000 
Префикс маски
Еще чаще, маска сети записывается в виде короткого префикса маски. Число в
префиксе обозначает количество бит относящихся к адресу сети. 
/16 = 11111111.11111111.00000000.00000000 = 255.255.0.0 
/24 = 11111111.11111111.11111111.00000000 = 255.255.255.0 
/26 = 11111111.11111111.11111111.11000000 = 255.255.255.192 
IP адрес и маска сети
Чтобы узнать, какая часть IP адреса относится к порции сети, необходимо
выполнить бинарную логическую операцию AND (И). 
-----------------------------------------------------------------------------
Бинарная логическая операция AND (И)
-----------------------------------------------------------------------------
Смысл операции заключается в сравнении двух битов, причем только в одном
случае бинарная операция даёт единицу на выходе – в случае сравнения двух
единиц. В остальных случаях логическая операция AND даёт на выходе 0. 
Результаты сравнения логической операцией AND двух битов: 
1 AND 1 = 1 
1 AND 0 = 0 
0 AND 1 = 0 
0 AND 0 = 0 
Операция AND над IP адресом и маской
Представим, что у нас есть IP адрес 192.168.1.31 с маской сети в виде
префикса /24, наша задача вычислить адрес сети, порцию сети, порцию хоста. 
Сначала надо перевести IP адрес из десятичной системы счисления в двоичную
систему. Затем перевести префикс в двоичный вид и нормальный вид маски сети
(десятичный). Далее останется только сложить IP адрес с маской с помощью
логической операции AND. 
192.168.1.31/24 
192.168.1.31 = 11000000.10101000.00000001.00011111 
/24 = 11111111.11111111.11111111.00000000 = 255.255.255.0 
11000000.10101000.00000001.00011111 (IP)

AND

11111111.11111111.11111111.00000000 (Mask)

=
11000000.10101000.00000001.00000000 (Адрес сети в двоичном виде)
192.168.1.0/24
(Адрес сети в десятичном виде с сетевым префиксом) 
Вот мы и узнали адрес сети. Единички в маске указывают на длину порции адреса
сети (11000000.10101000.00000001.), а нолики – на порцию адреса хоста (.00011111). 
-----------------------------------------------------------------------------
Примеры расчета сетей
-----------------------------------------------------------------------------
Деление сети осуществляется присвоением битов из порции адреса хоста к порции
адреса сети. Тем самым мы увеличиваем возможное количество подсетей, но
уменьшаем количество хостов в подсетях. Чтобы узнать, сколько получается
подсетей из присвоенных битов надо воспользоваться cisco формулой расчета
сетей: 2n, где n является количеством присвоенных бит. 
Пример расчета сети на 2 подсети.
У нас есть адрес сети 192.168.1.0/24, нам надо разделить имеющуюся сеть на 2
подсети. Попробуем забрать от порции хоста 1 бит и воспользоваться формулой:
21=2, это значит, что если мы заберём один бит от части хоста, то мы получим
2 подсети. Присвоение одного бита из порции хоста увеличит префикс на один
бит: /25. Теперь надо выписать 2 одинаковых IP адреса сети в двоичном виде
изменив только присвоенный бит (у первой подсети присвоенный бит будет равен
0, а у второй подсети = 1). Захваченный бит я выделю более жирным шрифтом
красного цвета. 
2 подсети (захваченный бит я выделю более жирным шрифтом красного цвета): 

1) 11000000.10101000.00000001.00000000
2) 11000000.10101000.00000001.10000000 
Теперь запишем рядом с двоичным видом десятичный, и добавим новый префикс.
Красным пометил порцию подсети, а синим – порцию хоста. 
1) 11000000.10101000.00000001.00000000 = 192.168.1.0/25
2) 11000000.10101000.00000001.10000000 = 192.168.1.128/25 
Всё, сеть разделена на 2 подсети. Как мы видим выше, порция хоста теперь составляет 7 бит. 
Чтобы высчитать, сколько адресов хостов можно получить используя 7 бит,
необходимо воспользоваться cisco формулой расчёта хостов: 2n-2, где
n = количество бит в порции хоста. 
27 - 2 = 126 хостов. В начале статьи было сказано, что вычитаемая цифра 2
является двумя адресами, которые нельзя присвоить хосту: адрес сети и
широковещательный адрес. 
Адрес сети, это когда в порции хоста все нули, а широковещательный адрес,
это когда в порции хоста все единицы. Выпишем эти адреса для каждой подсети в двоичном и десятичном виде: 
11000000.10101000.00000001.00000000 = 192.168.1.0/25 (адрес сети первой подсети) 
11000000.10101000.00000001.01111111 = 192.168.1.127/25 (широковещательный адрес первой подсети) 
11000000.10101000.00000001.10000000 = 192.168.1.128/25 (адрес сети второй подсети) 
11000000.10101000.00000001.11111111 = 192.168.1.255/25 (широковещательный адрес второй подсети) 
-----------------------------------------------------------------------------
Пример расчета сети на 4 подсети.
-----------------------------------------------------------------------------
Этот пример делается абсолютно по тому же алгоритму, что и предыдущий,
поэтому я запишу текст немного короче. Адрес я буду использовать тот же,
чтобы вы видели отличия. Если нужны подробности, пишите на почту eaneav@gmail.com. 
У нас есть адрес сети 192.168.1.0/24, надо разделить сеть на 4 подсети.
Высчитываем по формуле, сколько нам надо занять бит от хоста: 22 = 4. Префикс
изменяется на /26. 
4 подсети (захваченный бит я выделю более жирным шрифтом красного цвета): 
1) 11000000.10101000.00000001.00000000
2) 11000000.10101000.00000001.01000000
3) 11000000.10101000.00000001.10000000
4) 11000000.10101000.00000001.11000000 
Красным пометил порцию подсети, а синим – порцию хоста: 
1) 11000000.10101000.00000001.00000000 = 192.168.1.0/26
2) 11000000.10101000.00000001.01000000 = 192.168.1.64/26
3) 11000000.10101000.00000001.10000000 = 192.168.1.128/26
4) 11000000.10101000.00000001.11000000 = 192.168.1.192/26 
Всё, сеть разделена на 4 подсети. Порция хоста теперь составляет 6 бит. 
26 - 2 = 62 хостов. 
11000000.10101000.00000001.00000000 = 192.168.1.0/26 (адрес сети первой подсети) 
11000000.10101000.00000001.00111111 = 192.168.1.63/26 (широковещательный адрес первой подсети) 
11000000.10101000.00000001.01000000 = 192.168.1.64/26 (адрес сети второй подсети) 
11000000.10101000.00000001.01111111 = 192.168.1.127/26 (широковещательный адрес второй подсети) 
11000000.10101000.00000001.10000000 = 192.168.1.128/26 (адрес сети третьей подсети) 
11000000.10101000.00000001.10111111 = 192.168.1.191/26 (широковещательный адрес третьей подсети) 
11000000.10101000.00000001.11000000 = 192.168.1.192/26 (адрес сети четвёртой подсети) 
11000000.10101000.00000001.11111111 = 192.168.1.255/26 (широковещательный адрес четвёртой подсети)
----------------------------------------------------------------------------- 
Заключение
-----------------------------------------------------------------------------
Таким способом можно разделить любую сеть на подсети, а cisco формулы расчета сетей и хостов помогут вам в этом деле. 
-----------------------------------------------------------------------------
Расчет сетей и сетевых масок-2.
-----------------------------------------------------------------------------

В первой части разобрали простой способ расчета подсетей класса C.
Теперь давайте разберем сети класса B, тут дела обстоят немного по другому..

В сетях В последний октет адреса, если он равен 0, не всегда указывает на адрес
сети, и если равен 255, не всегда указывает на broadcast. 

Например, есть 172.16.0.0 с маской 255.255.240.0

Расчитаем шаг 256-240=16, но шаг здесь не будет количеством адресов в подсети!,
потому что разделение происходит еще в третьем октете адреса. Чтобы расчитать
кол-во адресов в подсети, нужно шаг умножить на 256, получаем 16*256=4096.
Здесь и приходить на помощь таблица из первой части, которую вы запомнили,
16*256 можно разложить как 1024*4, и тогда считается намного проще. И от 4096
отнимаем 2, потому как адрес сети и броадкаст еще есть. Теперь зная шаг и
кол-во адресов, можем расчитать подсети:

172.16.0.0 / 255.255.240.0 — 172.16.15.255 / 255.255.240.0

172.16.16.0 / 255.255.240.0 — 172.16.31.255 / 255.255.240.0

172.16.32.0 / 255.255.240.0 — 172.16.47.255 / 255.255.240.0

172.16.48.0 / 255.255.240.0 — 172.16.63.255 / 255.255.240.0

172.16.64.0 / 255.255.240.0 — 172.16.79.255 / 255.255.240.0

172.16.80.0 / 255.255.240.0 — 172.16.95.255 / 255.255.240.0

172.16.96.0 / 255.255.240.0 — 172.16.111.255 / 255.255.240.0

172.16.112.0 / 255.255.240.0 — 172.16.127.255 / 255.255.240.0

172.16.128.0 / 255.255.240.0 — 172.16.143.255 / 255.255.240.0

172.16.144.0 / 255.255.240.0 — 172.16.159.255 / 255.255.240.0

172.16.160.0 / 255.255.240.0 — 172.16.175.255 / 255.255.240.0

172.16.176.0 / 255.255.240.0 — 172.16.191.255 / 255.255.240.0

172.16.192.0 / 255.255.240.0 — 172.16.207.255 / 255.255.240.0

172.16.208.0 / 255.255.240.0 — 172.16.223.255 / 255.255.240.0

172.16.224.0 / 255.255.240.0 — 172.16.239.255 / 255.255.240.0

172.16.240.0 / 255.255.240.0 — 172.16.255.255 / 255.255.240.0
----------------------------------------------------------------------------- 
Тоже самое, но только с префиксом. С маской 255.255.240.0 префикс будет /20. 
Возвращаемся к таблице степеней 2-ки.
Стандартное количество бит в префиксе
для сети класса В — /16, максимальное количество бит в маске 32.
-----------------------------------------------------------------------------
Количество адресов в подсети 2 ^(32 — 20) = 2 ^12 = 4096

Количество подсетей 2 ^(20 — 16) = 2 ^4 = 16
-----------------------------------------------------------------------------
Итак, из одной сети класа В 172.16.0.0 / 255.255.240.0 получается 16 подсетей
 по 4096 адресов ( 4094 адреса для хостов, а 2 адреса — адрес сети и броадкаст)
если использовать маску 255.255.240.0 или префикс /20.
Очень важно запомнить что в подсети есть адрес сети и адрес широковещательный,
которые нельзя назначать хостам. На этом очень хорошо могут подловить на
экзамене. Если глянуть дампы экзаменов, то вопросов там таких не очень
много, но есть подвохи в них. Так что, адресацию вы должны щелкать быстро и
решительно, чтобы не попадаться на таких вопросах. Удачи в сертификации.!
-----------------------------------------------------------------------------
IPv6
-----------------------------------------------------------------------------
https://habrahabr.ru/post/210100/
-----------------------------------------------------------------------------
Существуют различные типы адресов IPv6:
	одноадресные (Unicast),
	групповые (Anycast) и
	многоадресные (Multicast).
-----------------------------------------------------------------------------
Адреса типа Unicast хорошо всем известны. Пакет, посланный на такой адрес,
достигает в точности интерфейса, который этому адресу соответствует.
-----------------------------------------------------------------------------
Адреса типа Anycast синтаксически неотличимы от адресов Unicast, но они адресуют
группу интерфейсов. Пакет, направленный такому адресу, попадёт в ближайший
(согласно метрике маршрутизатора) интерфейс. Адреса Anycast могут использоваться
только маршрутизаторами.
-----------------------------------------------------------------------------
Адреса типа Multicast идентифицируют группу интерфейсов. Пакет, посланный на
такой адрес, достигнет всех интерфейсов, привязанных к группе многоадресного вещания.
-----------------------------------------------------------------------------
Широковещательные адреса IPv4 (обычно xxx.xxx.xxx.255) выражаются адресами
многоадресного вещания IPv6. Крайние адреса подсети IPv6 (например,
xxxx:xxxx:xxxx:xxxx:0:0:0:0 и xxxx:xxxx:xxxx:xxxx:ffff:ffff:ffff:ffff для
подсети /64) являются полноправными адресами и могут использоваться наравне с остальными.
-----------------------------------------------------------------------------
Группы цифр в адресе разделяются двоеточиями (например, fe80:0:0:0:200:f8ff:fe21:67cf).
Незначащие старшие нули в группах могут быть опущены. Большое количество
нулевых групп может быть пропущено с помощью двойного двоеточия
(fe80::200:f8ff:fe21:67cf). Такой пропуск должен быть единственным в адресе.
-----------------------------------------------------------------------------
Типы Unicast-адресов
-----------------------------------------------------------------------------
    Глобальные

Соответствуют публичным IPv4-адресам. Могут находиться в любом не занятом
диапазоне. В настоящее время региональные интернет-регистраторы распределяют
блок адресов 2000::/3 (с 2000:: по 3FFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF).
-----------------------------------------------------------------------------
    Link-Local

Соответствуют автосконфигурированным с помощью протокола APIPA IPv4 адресам.
Начинаются с FE80:. Используется:

    В качестве исходного адреса для Router Solicitation(RS) и Router
Advertisement(RA) сообщений, для обнаружения маршрутизаторов.
    Для обнаружения соседей (эквивалент ARP для IPv4).
    Как next-hop-адрес для маршрутов.
-----------------------------------------------------------------------------
    Unique-Local

RFC 4193, соответствуют внутренним IP-адресам, которыми в версии IPv4 являлись
10.0.0.0/8, 172.16.0.0/12 и 192.168.0.0/16. Начинаются с цифр FCxx: и FDxx:.
-----------------------------------------------------------------------------
Типы Multicast-адресов
-----------------------------------------------------------------------------
Адреса мультикаст бывают двух типов:

    Назначенные (Assigned multicast) — специальные адреса, назначение которых
предопределено. Это зарезервированные для определённых групп устройств
мультикастовые адреса. Отправляемый на такой адрес пакет будет получен всеми
устройствами, входящими в группу.
-----------------------------------------------------------------------------
    Запрошенные (Solicited multicast) — остальные адреса, которые устройства
могут использовать для прикладных задач. Адрес этого типа автоматически
появляется, когда на некотором интерфейсе появляется юникастовый адрес.
Адрес формируется из сети FF02:0:0:0:0:1:FF00::/104, оставшиеся 24 бита
— такие же, как у настроенного юникастового адреса.
-----------------------------------------------------------------------------
Нотация
-----------------------------------------------------------------------------
Адреса IPv6 отображаются как восемь четырёхзначных шестнадцатеричных чисел
(то есть групп по четыре символа), разделённых двоеточием. Пример адреса:

2001:0db8:11a3:09d7:1f34:8a2e:07a0:765d
-----------------------------------------------------------------------------
Если две и более групп подряд равны 0000, то они могут быть опущены и заменены
на двойное двоеточие (::). Незначащие старшие нули в группах могут быть опущены.
Например, 2001:0db8:0000:0000:0000:0000:ae21:ad12 может быть сокращён до
2001:db8::ae21:ad12, или 0000:0000:0000:0000:0000:0000:ae21:ad12 может быть
сокращён до ::ae21:ad12. Сокращению не могут быть подвергнуты 2 разделённые
нулевые группы из-за возникновения неоднозначности.
-----------------------------------------------------------------------------
Также есть специальная нотация для записи встроенного и отображённого
IPv4 на IPv6. В ней последние 2 группы цифр заменены на IPv4-адрес в его формате.
Пример:

::ffff:192.0.2.1
-----------------------------------------------------------------------------
При использовании IPv6-адреса в URL необходимо заключать адрес в квадратные скобки:

http://[2001:0db8:11a3:09d7:1f34:8a2e:07a0:765d]/
-----------------------------------------------------------------------------
Если необходимо указать порт, то он пишется после скобок:

http://[2001:0db8:11a3:09d7:1f34:8a2e:07a0:765d]:8080/

-----------------------------------------------------------------------------
Зарезервированные адреса IPv6[9][10]
-----------------------------------------------------------------------------
IPv6 адрес 		Длина префикса (биты) 	Описание 	Заметки
-----------------------------------------------------------------------------
 :: 			128 			— 		см. 0.0.0.0 в IPv4
-----------------------------------------------------------------------------
 ::1 			128 		loopback адрес 		см. 127.0.0.1 в IPv4
-----------------------------------------------------------------------------
 ::xx.xx.xx.xx 		96 		встроенный IPv4 	Нижние 32 бита это адрес IPv4. Также называется IPv4 совместимым IPv6 адресом. Устарел и больше не используется.
-----------------------------------------------------------------------------
 ::ffff:​xx.xx.xx.xx 	96 		Адрес IPv4,		Нижние 32 бита — это адрес IPv4 для хостов, не поддерживающих IPv6.
					отображённый на IPv6
-----------------------------------------------------------------------------
64:ff9b:: 		96 		NAT64 (англ.)	 	Зарезервирован для доступа из подсети IPv6 к публичной сети IPv4 через механизм трансляции NAT64[11][12]
-----------------------------------------------------------------------------
2001:: 			32 		Teredo		 	Зарезервирован для туннелей Teredo в RFC 4380
-----------------------------------------------------------------------------
2001:db8:: 		32 		Документирование 	Зарезервирован для примеров в документации в RFC 3849
-----------------------------------------------------------------------------
2002:: 			16 		6to4 	З		арезервирован для туннелей 6to4 в RFC 3056
-----------------------------------------------------------------------------
fe80:: — fffe:: 	10 		link-local 		Аналог 169.254.0.0/16 в IPv4
-----------------------------------------------------------------------------
fec0:: — feff:: 	10 		site-local		Помечен как устаревший в RFC 3879 (Аналог внутренних сетей 10.0.0.0/8; 172.16.0.0/12; 192.168.0.0/16)
-----------------------------------------------------------------------------
fc00:: 			7 		Unique Local Unicast 	Пришёл на смену Site-Local RFC 4193
-----------------------------------------------------------------------------
ff00:: 			8 		multicast 	
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
CentOS 5/7
-----------------------------------------------------------------------------
# ls -l /etc/sysconfig/network-scripts/network-functions-ipv6
# modprobe -c | grep net-pf-10	Проверка On/Off
Для его включения необходимо отредактировать /etc/sysconfig/network.
Как именно — описано в след. пункте. 
-----------------------------------------------------------------------------
/etc/sysconfig/network
NETWORKING_IPV6=yes
IPV6_DEFAULTGW=«IPv6_шлюз»

/etc/sysconfig/network-scripts/ifcfg-eth0
IPV6INIT=yes
IPV6ADDR=«IPv6/48(маска)».
IPV6_DEFAULTGW=«IPv6_шлюз»
Если у вас несколько IPv6, то можно добавить
IPV6ADDR_SECONDARIES=«IPv6_1/48 IPv6_2/128 IPv6_3»
# /etc/init.d/network restart
-----------------------------------------------------------------------------
# ping6 ipv6.google.com
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
Диагностика сети с IPv6
-----------------------------------------------------------------------------
ip -6 addr show
netstat -A inet6 -rn
ip -6 route show
ping6 -c 3 ::1
traceroute6 google.com
tracepath6 ::1
tcpdump -t -n -i eth0 -s 512 -vv ip6 or proto ipv6
host -t AAAA google.com
dig google.com AAAA
-----------------------------------------------------------------------------
Сетевые сервисы IPv6
-----------------------------------------------------------------------------
Настройка SSH
-----------------------------------------------------------------------------
# sudo nano /etc/ssh/sshd_config
ListenAddress 111.111.111.111:22
ListenAddress [1341:8954:a389:33:ba33::1]:22
или
ListenAddress ::	слушать все доступные адреса IPv6
# ssh -6 username@host.com
-----------------------------------------------------------------------------
Настройка веб-сервера
-----------------------------------------------------------------------------
Apache
-----------------------------------------------------------------------------
<VirtualHost IPv4:81 [IPv6]:81>
	ServerName домен.ру

       ......................
</VirtualHost>
-----------------------------------------------------------------------------
Listen 111.111.111.111:80
Listen [1341:8954:a389:33:ba33::1]:80
или
Listen 80 слушать соединения на порт 80 на всех интерфейсах во всех протоколах

<VirtualHost 111.111.111.111:80, [1341:8954:a389:33:ba33::1]:80>
. . .
</VirtualHost>
# sudo service apache2 restart
-----------------------------------------------------------------------------
Nginx
-----------------------------------------------------------------------------
sysctl -w net.ipv6.bindv6only=1
-----------------------------------------------------------------------------
Чтобы эта строка автоматически выполнялась при загрузке, добавьте ее в /etc/sysctl.conf:

# sudo nano /etc/sysctl.conf
net.ipv6.bindv6only=1
-----------------------------------------------------------------------------
server {
		server_name домен.ру;
		listen IPv4;
		listen [IPv6];
                
               ..................
}
-----------------------------------------------------------------------------
listen [1341:8954:a389:33:ba33::1]:80 ipv6only=on;
listen 111.111.111.111:80;
# sudo service nginx restart
-----------------------------------------------------------------------------
Настройки брандмауэра
-----------------------------------------------------------------------------
/etc/sysconfig/ip6tables
-----------------------------------------------------------------------------
Для открытия 80 и 443 портов, нужно в /etc/sysconfig/ip6tables
Добавить:
-A RH-Firewall-1-INPUT -m tcp -p tcp --dport 80 -j ACCEPT
-A RH-Firewall-1-INPUT -m tcp -p tcp --dport 443 -j ACCEPT
Если перед этими строками стоит
-A RH-Firewall-1-INPUT -j REJECT --reject-with icmp6-adm-prohibited, то её необходимо удалить.
Далее перезагружаем сервис service ip6tables restart
-----------------------------------------------------------------------------
# sudo ip6tables -L
-----------------------------------------------------------------------------
Настройка TCP-оболочек
-----------------------------------------------------------------------------
# sudo nano /etc/hosts.allow
. . .
sshd: 111.111.0.0/255.255.254.0, [1341:8954:a389:33::]/64
-----------------------------------------------------------------------------
hostname
-----------------------------------------------------------------------------
/etc/hosts
/etc/hostname
# hostname -f
-----------------------------------------------------------------------------
# hostnamectl status
# hostnamectl --static set-hostname server1.wikiadmin.net
# systemctl restart systemd-hostnamed
-----------------------------------------------------------------------------
networks
-----------------------------------------------------------------------------
# ifconfig
# ip addr
-----------------------------------------------------------------------------
CentOS
-----------------------------------------------------------------------------
# yum -y install net-tools.x86_64
-----------------------------------------------------------------------------
/etc/sysconfig/network-scripts/
ifcfg-eth0
-----------------------------------------------------------------------------
# mcedit /etc/sysconfig/network-scripts/route-eth0

192.168.8.0/24 via 192.168.159.5
or
192.168.5.50/24 via 192.168.0.2 dev eth0
-----------------------------------------------------------------------------
STATIC
-----------------------------------------------------------------------------
# название устройства:
DEVICE="eth0"
# в случае, если IP получаем автоматически:
#BOOTPROTO="dhcp"
# статический IP:
BOOTPROTO="none"
# MAC адрес сетевой карты (в этом случае привязка к MAC адресу, а не к положению в слоте и т.п.):
HWADDR="00:00:00:00:00:00"
NM_CONTROLLED="yes"
# инициализировать при загрузке (иначен нужен ifup):
ONBOOT="yes"
TYPE="Ethernet"
UUID="ffffffff-ffff-ffff-ffff-ffffffffffff"
IPADDR=192.168.1.3
NETMASK=255.255.255.0
GATEWAY=192.168.1.1
DNS1=192.168.1.1
-----------------------------------------------------------------------------
BOOTPROTO 	с dhcp на none
DNS1 	указали dns сервер
IPADDR0 	настроили статический ip адрес
PREFIX0 	указали маску подсети
GATEWAY0 	настроили шлюз по-умолчанию
-----------------------------------------------------------------------------
Configuring a DHCP Client
-----------------------------------------------------------------------------
The /etc/sysconfig/network file should contain the following line:
-----------------------------------------------------------------------------
NETWORKING=yes
-----------------------------------------------------------------------------
The NETWORKING variable must be set to yes if you want networking to start at
boot time.

-----------------------------------------------------------------------------
The /etc/sysconfig/network-scripts/ifcfg-eth0 file should contain the
following lines:
-----------------------------------------------------------------------------
DEVICE=eth0
BOOTPROTO=dhcp
ONBOOT=yes
-----------------------------------------------------------------------------
A configuration file is needed for each device to be configured to use DHCP.
-----------------------------------------------------------------------------
Other options for the network script includes:

    DHCP_HOSTNAME — Only use this option if the DHCP server requires the
client to specify a hostname before receiving an IP address. (The DHCP server
daemon in Red Hat Enterprise Linux does not support this feature.)

    PEERDNS=<answer>, where <answer> is one of the following:

        yes — Modify /etc/resolv.conf with information from the server.
If using DHCP, then yes is the default.

        no — Do not modify /etc/resolv.conf.

    SRCADDR=<address>, where <address> is the specified source IP address
for outgoing packets.

    USERCTL=<answer>, where <answer> is one of the following:

        yes — Non-root users are allowed to control this device.

        no — Non-root users are not allowed to control this device.
----------------------------------------------------------------------------
Название	Описание	Возможные	Пример 
параметра	параметра	значения 	использования 	 	 	
-----------------------------------------------------------------------------
DEVICE 		наименование	eth0		device=eth0
		интерфейса 	eth1		device=eth1	
-----------------------------------------------------------------------------
BOOTPROTO 	способ 		dhcp		bootproto=dhcp
		назначения IP 	none		bootproto=
				static		bootproto=static
				(пустое		bootproto=none
				значение) 	
-----------------------------------------------------------------------------
HWADDR 	MAC адрес 	  	HWADDR="00:00:00:00:00:00"
-----------------------------------------------------------------------------
NM_CONTROLLED 	должен ли интерфейс управляться NetworkManager 	"yes"
"no" 	NM_CONTROLLED="yes"
-----------------------------------------------------------------------------
ONBOOT 	Должен ли этот интерфейс "подниматься" при запуске сетевой службы 	"yes"
"no" 	ONBOOT="yes"
-----------------------------------------------------------------------------
TYPE 	тип интерфейса 	"Ethernet" 	TYPE="Ethernet"
-----------------------------------------------------------------------------
UUID 	  	  	UUID="ffffffff-ffff-ffff-ffff-ffffffffffff"
-----------------------------------------------------------------------------
IPADDR 	IP адрес интерфейса 	  	IPADDR=192.168.1.3
-----------------------------------------------------------------------------
NETMASK 	маска подсети интерфейса 	  	NETMASK=255.255.255.0
-----------------------------------------------------------------------------
GATEWAY 	шлюз интерфейса 	  	GATEWAY=192.168.1.1
-----------------------------------------------------------------------------
DNS1 	1-й DNS сервер интерфейса 	  	DNS1=192.168.1.1
-----------------------------------------------------------------------------
DNS2 	2-й DNS сервер интерфейса 	  	DNS2=192.168.1.2
-----------------------------------------------------------------------------
DOMAIN 	текущий домен 	  	DOMAIN=MYDOMAIN.LOCAL
-----------------------------------------------------------------------------

----------------------------------------------------------------------------- 
resolv.conf
-----------------------------------------------------------------------------
Название	Описание		Пример
параметра 	параметра 	 	использования
-----------------------------------------------------------------------------
nameserver 	адрес DNS сервера		nameserver 192.168.1.1
		(не более 3-х) 			nameserver 192.168.1.2
-----------------------------------------------------------------------------
domain 		имя локального домена (?) 	domain mydom.local
-----------------------------------------------------------------------------
search 		подставляемое имя домена,	search mydom.local
		если адрес задан не полностью 	  	
-----------------------------------------------------------------------------
# /etc/init.d/network restart
# systemctl restart networking.service
-----------------------------------------------------------------------------
NetworkManager
-----------------------------------------------------------------------------
# yum install NetworkManager-tui

# nmtui 	Простой текстовый интерфейс (TUI) для NetworkManager
# nmcli 	Утилита, работающая в командной строке, которая позволяет пользователям и скриптам взаимодействовать с NetworkManager
-----------------------------------------------------------------------------
Debian/Ubuntu
-----------------------------------------------------------------------------
/etc/network/interfaces

 auto lo
 iface lo inet loopback
 
 auto eth0
 iface eth0 inet static
         address 192.168.0.150
         netmask 255.255.255.0
         gateway 192.168.0.1
         post-up iptables-restore < /etc/iptables.up.rules
-----------------------------------------------------------------------------
# ifconfig
# ifconfig -a eth0 192.168.1.15 netmask 255.255.255.0
# ifconfig eth0 up
# ifconfig eth0 down
# ip addr
# lspci | grep Ethernet
-----------------------------------------------------------------------------
Переименовать сетевой интерфейс с eth0 на wan0
-----------------------------------------------------------------------------
Чтобы переименовать интерфейс с eth0 на wan0, отредактируйте файл
/etc/udev/rules.d/70-persistent-net.rules и измените NAME=»eth0″ на NAME=»wan0″.
-----------------------------------------------------------------------------
# PCI device 0x11ab:0x4363 (sky2)
SUBSYSTEM=="net", ACTION=="add", DRIVERS=="?*",
ATTR{address}=="00:00:00:00:00:00",ATTR{dev_id}=="0x0", ATTR{type}=="1",
KERNEL=="eth*", NAME="wan0"
-----------------------------------------------------------------------------
Для Centos/RHEL и т. п.
-----------------------------------------------------------------------------
Переименуйте файл настроек интерфейса:

# cd etc/sysconfig/network-scripts/
# mv ifcfg-eth0 ifcfg-wan0
-----------------------------------------------------------------------------
Откройте файл настроек и замените все упоминания старого имени eth0 на новое wan0:

# vi /etc/sysconfig/network-scripts/ifcfg-wan0
-----------------------------------------------------------------------------
Для Ubuntu и т. п.

Откройте файл /etc/network/interfaces и замените все упоминания старого имени
eth0 на новое wan0:

# sudo nano /etc/network/interfaces
-----------------------------------------------------------------------------
Дополнительный IP адрес на интерфейсе eth1
-----------------------------------------------------------------------------
ONBOOT=no
DEVICE=eth1:0
BOOTPROTO=static
IPADDR=172.16.12.6
NETMASK=255.255.0.0
# следующие два параметра можно не писать
# они вычисляются из IP и маски
BROADCAST=172.16.255.255
NETWORK=172.16.0.0
-----------------------------------------------------------------------------
Инициализация VLAN на eth1
-----------------------------------------------------------------------------
DEVICE=eth1.72
VLAN=yes
VLAN_TRUNK_IF=eth1
BOOTPROTO=static
IPADDR=10.10.0.1
NETMASK=255.255.255.192
ONBOOT=yes
-----------------------------------------------------------------------------
dns
-----------------------------------------------------------------------------

DNS адресная книга соответствия FQDN <–> IP.
СЕРВЕРА
1. Корневой
2. Порт 53
3. FQDN
4. домен – узел в дереве имен, ветвь или поддерево в дереве имен, поддомен, относительное имя
5. Ресурсная запись – единица хранения информации DNS
РЕЖИМЫ
6. главный(Stealth DNS сервер – все обновления, автортативный), подчиненный(только чтение, автортативный), кэширующий(не автортативный).
ЗОНА – часть дерева доменных имен.
7. Первичная, вторичная, заглушки/forward.
8. Авторитетность – ответственность за зону DNS.
9. Делегирование – передача ответственности
10. Для каждой зоны всегда 2 сервера в разных сетях С
ЗАПРОСЫ
11. Прямые, обратные.
12. Рекурсивные от клиента к серверу, итеративные – от сервера к  серверу, для клиента
ТИПЫ ЗАПИСЕЙ
13. A, CNAME, NS, MX, PTR(проверка на SMTP), SOA – эталонная информация о данном дереве, SRV
NSLOOKUP
14. nslookup -type=any ya.ru, nslookup -> set q=a, mx,ns,ptr,srv,all,soa,any -> ya.ru
Дополниние
15. Кеш DNS, файл Hosts, resolv.conf
16. named.conf — основной конфигурационный файл bind
17. zones.master, zones.slave, zones.reverse — конфигурационные файлы в которых прописаны поддерживаемые DNS зоны
18. slave/, master/, reverse/ — каталоги, в которых располагают конфигурационные файлы DNS зон
19. named.root — системный конфигурационный файл, содержащий информацию о всех корневых DNS серверах сети Интернет
20. rndc.key — файл ключом, который необходим для управления работой bind посредством утилиты rndc
-----------------------------------------------------------------------------
/etc/resolv.conf
# yum -y install bind bind-utils bind-chroot
-----------------------------------------------------------------------------
Очередость обращения hosts и dns
-----------------------------------------------------------------------------
/etc/nsswitch.conf определяет 
root@DNS:~# cat /etc/nsswitch.conf
......
hosts:          files dns
networks:       files
-----------------------------------------------------------------------------
 hosts: files dns - сначала из файла /etc/hosts, затем силами DNS /etc/resolv.conf
 строка networks: files - преобразование имен сетей в IP с помощью файла /etc/network
-----------------------------------------------------------------------------
Еще раз обращаю внимание, что мы будем использовать bind в chroot среде для увеличения безопасности.
-----------------------------------------------------------------------------
# systemctl start named-chroot
# systemctl enable named-chroot
# ls -l /var/named/chroot/etc
# mcedit /var/named/chroot/etc/named.conf
-----------------------------------------------------------------------------
Пример 1
-----------------------------------------------------------------------------
Кэширующий сервер
-----------------------------------------------------------------------------
options {
listen-on port 53 { any; };
listen-on-v6 port 53 { none; };
directory "/var/named";
dump-file "/var/named/data/cache_dump.db";
allow-query { 127.0.0.1; 192.168.7.0/24; };
recursion yes;
allow-recursion { 127.0.0.1; 192.168.7.0/24; };
forwarders { 8.8.8.8; };
version "DNS Server";
managed-keys-directory "/var/named/dynamic";
pid-file "/run/named/named.pid";
session-keyfile "/run/named/session.key";
};

zone "." IN {
type hint;
file "named.ca";
};

include "/etc/named.rfc1912.zones";
include "/etc/named.root.key";

logging {
channel default_file {
file "/var/log/named/default.log" versions 3 size 5m;
severity dynamic;
print-time yes;
};
category default { default_file; };
};
-----------------------------------------------------------------------------
Эта конфигурация обеспечит работу обычного кэширующего сервера в локальной
сети. Комментарии к некоторым параметрам:
-----------------------------------------------------------------------------
listen-on-v6 port 53 { none; }; 	Отключили работу на интерфейсе ipv6.
-----------------------------------------------------------------------------
allow-query { 127.0.0.1; 192.168.7.0/24; }; 	Разрешаем обычные запросы
только из локальной сети.
-----------------------------------------------------------------------------
allow-recursion { 127.0.0.1; 192.168.7.0/24; }; 	Разрешаем рекурсивные
запросы только из локальной сети.
-----------------------------------------------------------------------------
forwarders { 8.8.8.8; }; 	Перенаправляем запросы, которые сами не
резолвим, на днс сервер гугла. У меня указан он просто для примера. Тут лучше
всего указать сначала ДНС серверы провайдера.
-----------------------------------------------------------------------------
version «DNS Server»; 	Скрываем версию бинда, вместо этого выводим
указанную строку.
-----------------------------------------------------------------------------
Не забудьте отредактировать правила фаервола для корректной работы DNS
сервера — открыть 53 порт UDP для работы кэширующего сервера, который мы
сейчас настроили, и 53 порт TCP для пересылки зон, о которых речь пойдет дальше 
-----------------------------------------------------------------------------
Поддержка собственной зоны
-----------------------------------------------------------------------------
Допустим, нам необходимо в нашем named разместить собственную зону site1.ru. Первым делом создаем файл зоны, которую будет обслуживать dns сервер:

# mcedit /var/named/chroot/var/named/site1.ru.zone
-----------------------------------------------------------------------------
$TTL 86400
@        IN     SOA     site1.ru. site1.ru.local. (
                        2015092502
                        43200
                        3600
                        3600000
                        2592000 )

        IN NS ns1.site1.ru.
        IN NS ns2.site1.ru.
        IN A 192.168.7.254
        IN MX 10 mx.site1.ru.

gate    IN A 192.168.7.254
mx      IN A 192.168.7.250
ns1     IN A 192.168.7.235
ns2     IN A 192.168.7.231
-----------------------------------------------------------------------------
Выставляем необходимые права:

# chown root:named /var/named/chroot/var/named/site1.ru.zone
# chmod 0640 /var/named/chroot/var/named/site1.ru.zone
-----------------------------------------------------------------------------
Дальше подключаем файл зоны в конфигурационном файле bind —
/var/named/chroot/etc/named.conf:

zone "site1.ru" {
 type master;
 file "site1.ru.zone";
};
-----------------------------------------------------------------------------
Перечитываем конфигурацию named с помощью rndc:

# rndc reconfig
-----------------------------------------------------------------------------
Описание любого домена (служебная информация, его NS, сервера почты,
субдомены) или, иначе говоря, зоны, должно строго соответствовать
определенному формату. Рассмотрим его.
-----------------------------------------------------------------------------
$TTL 1h
@       IN      SOA     ns1.my-ns-server.com. hostmaster.example.com. (
    2007022600	; Serial
    3h		; Refresh
    1h		; Retry
    1w		; Expiry 
    1d		; TTL
)

;;; NS ;;;
	        NS	ns1.my-ns-server.com.
		NS	ns.my-secondary-ns.com.

;;; MX ;;;
		MX 10	mx.example.com.

;;; A ;;;
	        A	192.168.1.1
www		CNAME	@
mx		A	192.168.1.1
-----------------------------------------------------------------------------
 Все, что следует после ‘;’ — комментарии.

Первая строка задает параметр $TTL, который определяет время кеширования
положительных ответов (ответ в виде найденного IP-адреса). Здесь и далее,
время может задаваться в секундах или с помощью сокращений: m — минуты,
h — часы, d — дни, w — недели.

В записи SOA указывается primary NS для домена и e-mail контактного лица. В
скобках, по порядку:

    Serial — Серийный номер. Каждый раз при изменении каких-либо данных его
нужно обязательно менять. Когда меняется серийный номер, зона обновляется на
всех серверах. Используйте следующий формат: ГГГГММДДнн (год, месяц, день,
нн — порядковый номер изменения за день). Если вы уже второй раз за день
вносите измения в файл зоны, укажите "нн" равным 01, если третий — 02, и т.д.
    Refresh — интервал, через который slave сервера должны обращаться к
primary серверу и проверять обновление зоны.
    Retry — если slave серверу не удалось обратится к primary серверу, через
это время он должен повторить свой запрос.
    Expiry — если в течении этого времени slave сервер так и не смог обновить
зону с primary сервера, то slave должен прекратить обслуживать эту зону.
    TTL — время кеширования отрицательных ответов (ответ "домен невозможно
разрешить в IP адрес")
-----------------------------------------------------------------------------
В секции NS задаются NS сервера.

Секция MX описывает почтовые шлюзы. Для каждого шлюза устанавливается
приоритет (по умолчанию — 10). Обычно имя 

В секции A указываются субдомены (A) и синонимы (CNAME). В примере домен
example.com указывает на IP адрес 192.168.1.1, а домен www.example.com
является синонимом example.com.
-----------------------------------------------------------------------------
Обратите внимание:
-----------------------------------------------------------------------------
    Если вы указываете полное имя домена, пишите в его конце точку.
    Записи NS, MX и A для основного домена (не субдомена) не должны начинаться
с начала строки.
    Если почтовый шлюз принадлежит этому же домену, не забывайте указывать его
в секции A.
-----------------------------------------------------------------------------
Проверить файл зоны на ошибки можно с помощью команды:

$ named-checkzone example.com ./example.com
zone example.com/IN: loaded serial 2007022600
-----------------------------------------------------------------------------
Настройка логов в bind (named)
-----------------------------------------------------------------------------
Первым делом в конфигурации мы задаем канал, куда будут складываться логи по
тем или иным событиям. Вот пример подобного канала:
-----------------------------------------------------------------------------
channel general {
file "/var/log/named/general.log" versions 3 size 5m;
severity dynamic;
print-time yes;
-----------------------------------------------------------------------------
Здесь указано название канала, которые мы придумываем сами — general, указан
путь до файла, сказано, что хранить будем 3 версии лога размером не более 5
мегабайт. Параметр severity может принимать следующие значения:
-----------------------------------------------------------------------------
Описание параметров severity
-----------------------------------------------------------------------------
critical 	Только критические ошибки.
error 		Обычные ошибки и все что выше.
warning 	Предупреждения и все, что выше.
notice 		Уведомления и все, что выше.
info 		Информационные сообщения и все что выше.
debug 		Сообщения уровня debug и все, что выше. Уровни debug  
		регулируются значениями 0, 1, 2, 3.
dynamic 	То же, что и debug, только его уровень регулируется глобальной
		настройкой сервера.
-----------------------------------------------------------------------------
Параметр print-time указывает на то, что в лог необходимо записывать время
события. Помимо указанных мной настроек, в конфигурации канала могут быть
добавлены следующие параметры:
-----------------------------------------------------------------------------
    print-severity yes | no — указывает, писать или нет параметр severity в лог
    print-category yes | no — указывает писать или нет название категории логов
-----------------------------------------------------------------------------
Я эти параметры не указал, так как по-умолчанию устанавливается значение no,
которое лично меня устраивает.
-----------------------------------------------------------------------------
Дальше необходимо указать категорию логов и в какой канал мы будем ее записывать:

category general { general; };
-----------------------------------------------------------------------------
Категорий у днс сервера bind достаточно много. 
Вот мой перевод полного списка с описаниями:
-----------------------------------------------------------------------------
Описание категорий логов в bind (named)
default 	Сюда будут попадать события всех категорий из этой таблицы,
		если они не определены отдельно, за исключением категории
		queries, которую нужно включать специально. То есть если
		обозначить только категорию default, то в нее будут сыпаться
		события всех категорий.
general 	Эта категория для всех логов, которые не включены ни в одну
		из перечисленных категорий.
database 	Сообщения, относящиеся к хранению зон и кэшированию.
security 	Подтверждение и отказ в выполнении запросов.
config 		Все, что относится к чтению и выполнению файла конфигурация.
resolver 	Разрешение имен, включая информацию о рекурсивных запросах,
		выполняемых от имени клиента кэширующим сервером.
xfer-in 	Информация о получении зон.
xfer-out 	Информация о передаче зон.
notify 		Логирование операций протокола NOTIFY.
client 		Выполнение клиентских запросов.
unmatched 	Сообщения, которые named не смог отнести ни к одному классу
		или для которых не определено отображение.
network 	Логирование сетевых операций.
update 		Динамические апдейты.
update-security Подтверждение или отклонение запросов на апдейт.
queries 	Логирование запросов к ДНС серверу. Для включения этой категории необходимо 		отдельно задать параметр в конфигурации сервера. Это связано с тем, что эта 			категория генерирует очень много записей в лог файл, что может сказаться на 		производительности сервера.
query-errors 	Ошибки запросов к серверу.
dispatch 	Перенаправление входящих пакетов модулям сервера на обработку.
dnssec 		Работа протоколов DNSSEC и TSIG.
lame-servers 	Фиксируются ошибки, которые получает bind при обращении к удаленным серверам в 		попытке выполнить запрос на разрешение имени.
delegation-only Логирование запросов, вернувших NXDOMAIN.
edns-disabled 	Запросы, которые вынуждены использовать plain DNS из-за превышения timeouts.
RPZ 	 	Все операции, связанные с выполнение Response Policy Zone (RPZ).
rate-limit 	Операции связанные с одним или несколькими rate-limit statements в options 		или view.
-----------------------------------------------------------------------------
Таким образом, чтобы вывести все категории логов в отдельные файлы, необходимо
в конфиг named добавить следующую конструкцию:
-----------------------------------------------------------------------------
logging {

channel default {
file "/var/log/named/default.log" versions 3 size 5m;
severity dynamic;
print-time yes;
};

channel general {
file "/var/log/named/general.log" versions 3 size 5m;
severity dynamic;
print-time yes;
};

channel database {
file "/var/log/named/database.log" versions 3 size 5m;
severity dynamic;
print-time yes;
};

channel security {
file "/var/log/named/security.log" versions 3 size 5m;
severity dynamic;
print-time yes;
};

channel config {
file "/var/log/named/config.log" versions 3 size 5m;
severity dynamic;
print-time yes;
};

channel resolver {
file "/var/log/named/resolver.log" versions 3 size 5m;
severity dynamic;
print-time yes;
};

channel xfer-in {
file "/var/log/named/xfer-in.log" versions 3 size 5m;
severity dynamic;
print-time yes;
};

channel xfer-out {
file "/var/log/named/xfer-out.log" versions 3 size 5m;
severity dynamic;
print-time yes;
};

channel notify {
file "/var/log/named/notify.log" versions 3 size 5m;
severity dynamic;
print-time yes;
};

channel client {
file "/var/log/named/client.log" versions 3 size 5m;
severity dynamic;
print-time yes;
};

channel unmatched {
file "/var/log/named/unmatched.log" versions 3 size 5m;
severity dynamic;
print-time yes;
};

channel network {
file "/var/log/named/network.log" versions 3 size 5m;
severity dynamic;
print-time yes;
};

channel update {
file "/var/log/named/update.log" versions 3 size 5m;
severity dynamic;
print-time yes;
};

channel update-security {
file "/var/log/named/update-security.log" versions 3 size 5m;
severity dynamic;
print-time yes;
};

channel queries {
file "/var/log/named/queries.log" versions 3 size 5m;
severity dynamic;
print-time yes;
};

channel query-errors {
file "/var/log/named/query-errors.log" versions 3 size 5m;
severity dynamic;
print-time yes;
};

channel dispatch {
file "/var/log/named/dispatch.log" versions 3 size 5m;
severity dynamic;
print-time yes;
};

channel dnssec {
file "/var/log/named/dnssec.log" versions 3 size 5m;
severity dynamic;
print-time yes;
};

channel lame-servers {
file "/var/log/named/lame-servers.log" versions 3 size 5m;
severity dynamic;
print-time yes;
};

channel delegation-only {
file "/var/log/named/delegation-only.log" versions 3 size 5m;
severity dynamic;
print-time yes;
};

channel edns-disabled {
file "/var/log/named/edns-disabled.log" versions 3 size 5m;
severity dynamic;
print-time yes;
};

channel rpz {
file "/var/log/named/rpz.log" versions 3 size 5m;
severity dynamic;
print-time yes;
};

channel rate-limit {
file "/var/log/named/rate-limit.log" versions 3 size 5m;
severity dynamic;
print-time yes;
};

channel cname {
file "/var/log/named/cname.log" versions 3 size 5m;
severity dynamic;
print-time yes;
};

category default { default; };
category general { general; };
category database { database; };
category security { security; };
category config { config; };
category resolver { resolver; };
category xfer-in { xfer-in; };
category xfer-out { xfer-out; };
category notify { notify; };
category client { client; };
category unmatched { unmatched; };
category network { network; };
category update { update; };
category update-security { update-security; };
category queries { queries; };
category query-errors { query-errors; };
category dispatch { dispatch; };
category dnssec { dnssec; };
category lame-servers { lame-servers; };
category delegation-only { delegation-only; };
category edns-disabled { edns-disabled; };
category rpz { rpz; };
category rate-limit { rate-limit; };
category cname { cname; };
};
-----------------------------------------------------------------------------
Теперь создадим папку для логов. Не забываем, что мы работаем в chroot окружении:

# cd /var/named/chroot/var/log && mkdir named && chown named. named
-----------------------------------------------------------------------------
Если мы хотим собирать все логи запросов из категории queries, то в раздел
options файла конфигурации необходимо добавить параметр, который это разрешает:

querylog yes;
-----------------------------------------------------------------------------
Перезапускаем bind:

# systemctl reload named-chroot.service
-----------------------------------------------------------------------------
Проверка работы DNS Server
-----------------------------------------------------------------------------
Первым делом пойдем в каталог с логами и проверим, что там у нас:
-----------------------------------------------------------------------------
# cd /var/named/chroot/var/log/named
# ls -l
-----------------------------------------------------------------------------
Все файлы журнала созданы и начали наполняться. Можно проверить один из них.
Например, посмотрим, как наш сервер centos (192.168.7.246) логирует запросы
пользователей. Попробуем с компьютера 192.168.7.254 (windows) выполнить
nslookup yandex.ru и посмотрим как это отразится в лог файле:
-----------------------------------------------------------------------------
26-Sep-2015 19:25:30.923 client 192.168.7.254#56374 (yandex.ru): query: yandex.ru IN A + (192.168.7.246)
26-Sep-2015 19:25:31.013 client 192.168.7.254#56375 (yandex.ru): query: yandex.ru IN AAAA + (192.168.7.246)
-----------------------------------------------------------------------------
Теперь выполним ping site1.ru, чтобы проверить, как сервер поддерживает нашу зону:
-----------------------------------------------------------------------------
26-Sep-2015 19:28:01.660 client 192.168.7.254#49816 (site1.ru): query: site1.ru IN A + (192.168.7.246)
-----------------------------------------------------------------------------
Таким образом очень удобно отследить, куда лезет компьютер. Например, можно поднять временно dns сервер, включить лог запросов. В клиенте указать единственный днс сервер, который мы настроили. Дальше можно отслеживать, к примеру, куда лезет винда после загрузки без нашего ведома. Или откуда грузится реклама в скайпе. Все запросы будут аккуратно складываться в файл, который потом можно спокойно анализировать, а затем, к примеру, настроить запрет сайтов на микротике.
-----------------------------------------------------------------------------
Пример 2 Bind9
-----------------------------------------------------------------------------
/usr/sbin/named.
/etc/bind/named.conf
/var/cache/bind, в котором лежат файлы описания зон и другие служебные файлы.

zone задает раздел cоответствие названия зоны и файла описания зоны 
	с параметром file.
	так же задает тип ответственности данного сервера за зону (master, slave и др.)
	определяет особые параметры для текущей зоны (например, на каком интерфейсе 	обрабатывать запросы для текущей зоны).

В файлах описания зон содержатся параметры зон и записи ресурсов 
-----------------------------------------------------------------------------
Параметры (синтаксис) named.conf
-----------------------------------------------------------------------------
Синтаксис файла named.conf придерживается следующих правил:

IP-адреса - список IP должен быть разделен символом ";" , возможно указывать подсеть в формате 192.168.1.1/24 или 192.168.1.1/255.255.255.0, (для исключения IP перед ним нужно поставить знак !), возможно указывать имена "any", "none", "localhost" в двойных кавычках.

Комментарии - строки начинающиеся на #, // и заключенные в /* и */ считаются комментариями.

В файлах описания зон - символ @ является "переменной" хранящей имя зоны, указанной в конфигурационном файле named.conf или в директиве @ $ORIGIN текущего описания зоны.

Каждая завершенная строка параметров должна завершаться символом ; .
Раздел Acl

Acl (access control list) - позволяет задать именованный список сетей. Формат раздела: acl "имя_сети" {ip; ip; ip; };
-----------------------------------------------------------------------------
Раздел Options
-----------------------------------------------------------------------------
Задает глобальные параметры конфигурационного файла, управляющие всеми зонами. Данный раздел имеет формат: options {операторы_раздела_Options};. Options может быть "вложен" в раздел Zone, при этом он переопределяет глобальные параметры. Часто используемые операторы options:
-----------------------------------------------------------------------------
    allow-query {список_ip} - Разрешает ответы на запросы только из список_ip. При отсутствии - сервер отвечает на все запросы.
    allow-recursion {список_ip} - На запросы из список_ip будут выполняться рекурсивные запросы. Для остальных - итеративные. Если не задан параметр, то сервер выполняет рекурсивные запросы для всех сетей.
    allow-transfer {список_ip} - Указывает список серверов, которым разрешено брать зону с сервера (в основном тут указывают slave сервера)
    directory /path/to/work/dir - указывает абсолютный путь к рабочему каталогу сервера. Этот оператор допустим только в разделе options.
    forwarders {ip порт, ip порт...} - указывает адреса хостов и если нужно порты, куда переадресовывать запросы (обычно тут указываются DNS провайдеров ISP).
    forward ONLY или forward FIRST - параметр first указывает, DNS-серверу пытаться разрешать имена с помощью DNS-серверов, указанных в параметре forwarders, и лишь в случае, если разрешить имя с помощью данных серверов не удалось, то будет осуществлять попытки разрешения имени самостоятельно.
    notify YES|NO - YES - уведомлять slave сервера об изменениях в зоне, NO - не уведомлять.
    recursion YES|NO - YES - выполнять рекурсивные запросы, если просит клиент, NO - не выполнять (только итеративные запросы). Если ответ найден в кэше, то возвращается из кэша. (может использоваться только в разделе Options)

-----------------------------------------------------------------------------
Раздел Zone
-----------------------------------------------------------------------------
Определяет описание зон(ы). Формат раздела: zone {операторы_раздела_zone};
Операторы, которые наиболее часто используются:

    allow-update {список_ip} - указывает системы, которым разрешено динамически обновлять данную зону.
    file "имя_файла" - указывает путь файла параметров зоны (должен быть расположен в каталоге, определенном в разделе options оператором directory)
    masters {список_ip} -указывает список мастер-серверов. (допустим только в подчиненных зонах)
    type "тип_зоны" - указывает тип зоны, описываемой в текущем разделе,тип_зоны может принимать следующие значения:
        forward - указывает зону переадресации, которая переадресовывает запросы, пришедшие в эту зону.
        hint - указывает вспомогательную зону (данный тип содержит информацию о корневых серверах, к которым сервер будет обращаться в случае невозможности найти ответ в кэше)
        master - указывает работать в качестве мастер сервера для текущей зоны.
        slave - указывает работать в качестве подчиненного сервера для текущей зоны.

-----------------------------------------------------------------------------
Для того чтобы локальный резолвер сервера тоже использовал локальный DNS,
необходимо привести файл resolv.conf к следующему виду:

dns:~# cat /etc/resolv.conf
nameserver 127.0.0.1

-----------------------------------------------------------------------------
Настройка кэширующего DNS сервера
-----------------------------------------------------------------------------
После установки bind, он полностью готов работать как кэширующий DNS сервер
без дополнительной настройки. Единственный недостаток - он обрабатывает
запросы на всех интерфейсах, что нам абсолютно не нужно, поэтому мы немного
подредактируем настройки сервера.
-----------------------------------------------------------------------------
Для того, чтобы BIND работал в качестве кэширующего сервера, необходимо
иметь конфигурационные файлы заполненные необходимой информацией:

    named.conf;
    описание серверов корневой зоны (зона типа hint);
    описание зоны 127.in-addr.arpa.
-----------------------------------------------------------------------------
dns:~# cat /etc/bind/named.conf
acl "lan" {
           192.168.1.1/24;
           127.0.0.1;
};

options {
           directory "/var/cache/bind";

           // If there is a firewall between you and nameservers you want
           // to talk to, you may need to fix the firewall to allow multiple
           // ports to talk.  See http://www.kb.cert.org/vuls/id/800113
           /*
           * Тут сказано, что если используется фаерволл, то необходимо
           *  нашему серверу создать соответствующие правила
           *  то есть открыть доступ по 53 TCP и UDP порту
           */

           forward first;              // задаем пересылку только первого запроса

           forwarders {                // указываем DNS сервера для пересылки
                      83.239.0.202;    // предоставленные провайдером
                      213.132.67.110;  // ибо до них ближе чем до корневых
           };

          listen-on { lan; };        // пусть слушает только нужные интерфейсы
          allow-query { lan; };      // разрешить запросы только из локальной сети
          allow-recursion { lan; };  // рекурсивные запросы тоже только из локальной
          allow-transfer { none; };  // трансфер зон нам не нужен

          version "unknown";         // не отображать версию DNS сервера при ответах

          auth-nxdomain no;    # для совместимости RFC1035
          listen-on-v6 { none; };    //IPv6 нам не нужен
          };

// описание настроек корневых серверов
zone "." {
          type hint;
          file "db.root";
};

// нижеописанные зоны определяют сервер авторитетным для петлевых
// интерфейсов, а так же для броадкаст-зон (согласно RFC 1912)

zone "localhost" {
          type master;
          file "localhost";
};

zone "127.in-addr.arpa" {
          type master;
          file "127.in-addr.arpa";
};

zone "0.in-addr.arpa" {
          type master;
          file "0.in-addr.arpa";
};

zone "255.in-addr.arpa" {
          type master;
          file "255.in-addr.arpa";
};
-----------------------------------------------------------------------------
В данном примере приведен кэширующий DNS сервер, обрабатывающий запросы из
списка сетей lan, в которую входит только одна локальная сеть 192.168.1.1/24
и петлевой интерфейс. При необходимости можно включить туда и другие сети.
После определения списка сетей в директиве acl, в любом месте конфига можно
будет ссылаться на этот список по имени (в нашем примере имя - lan), что,
собственно и сделано в разделе options. Большинство параметров я
прокомментировал, но отдельного внимания требует раздел, описывающий зону
корневых серверов. В параметре file задан относительный путь к файлу описания
корневых серверов (путь, относительно рабочего каталога сервера). За
обновлениями данного файла необходимо следить, хотя он обновляется довольно
редко (откуда брать обновленный файл я писал в теории DNS). Как вы заметили,
имеется так же две записи для зоны localhost и две записи обратных зон для
бродкаст доменов. Назначение этих зон состоит в том, чтобы избежать трансляции
случайных запросов имен соответствующих IP-адресов на серверы, обслуживающие
корневую зону.
-----------------------------------------------------------------------------
Чтобы не вносить неразбериху в куче конфигурационных файлов, в статье я
привожу примеры на основе единого конфигурационного файла. На  самом деле, в
последних версиях Debian (и других дистрибутивах Linux), файл named.conf
выглядит следующим образом:
-----------------------------------------------------------------------------
root@master:~# cat /etc/bind/named.conf

// If you are just adding zones, please do that in /etc/bind/named.conf.local

include "/etc/bind/named.conf.options";
include "/etc/bind/named.conf.local";
include "/etc/bind/named.conf.default-zones";
-----------------------------------------------------------------------------
То есть основной файл не содержит конфигураций, а включает в себя более узко специализированные файлы, которые отвечают за свои задачи, например
named.conf.options - содержит глобальные параметры конфигурации,
named.conf.default-zones - содержит описание localhost и broadcast зон, а
named.conf.local содержит описания зон, за которые отвечает данный сервер.
-----------------------------------------------------------------------------
Далее, хочу обратить внимание на наличие файлов зон в каталоге, указанном в
разделе options в параметре directory с именами, соответствующими параметрам
file в разделах, описывающих зоны:
-----------------------------------------------------------------------------
named должен быть разрешен для запуска на необходимых уровнях выполнения ОС
(команда в
RedHat - /sbin/chkconfig bind9 on, в
Debian - /usr/sbin/update-rc.d bind9 defaults).
После изменения конфигурационных файлов можно добавить сервис в
автозагрузку и запустить.
-----------------------------------------------------------------------------
Для проверки работы кэша можно выполнить команду nslookup mail.ru example.com.,
если в ответе содержится строка Non-authoritative answer, то адрес пришел из
кэша, а так же если выполнить dig www.ru. (или другой домен, которого еще нет
в кэше) и через некоторое время повторить команду, то время ответа должно быть
гораздо меньше.
-----------------------------------------------------------------------------
Главный (master) сервер зоны
-----------------------------------------------------------------------------
dns:~# cat /etc/bind/named.conf
acl "lan" {
          192.168.1.1/24;
          127.0.0.1;
};

options {
          directory "/var/cache/bind";
          allow-query { any; };       // отвечать на зпросы со всех интерфейсов
          recursion no;               // запретить рекурсивные запросы
          auth-nxdomain no;           // для совместимости RFC1035
          listen-on-v6 { none; };     // IPv6 нам не нужен
          version "unknown";          // не отображать версию DNS сервера при ответах

          /*
          *  Раскомментируйте строки ниже, если
          *  хотите разрешить рекрусивные запросы
          *  из локальной сети.
          *  (так же, необходимо закомментировать
          *  recursion no; )
          */
          # forwarders {                 // указываем DNS сервера для пересылки
          #         83.239.0.202;        // предоставленные провайдером
          #         213.132.67.110;      // ибо до них ближе чем до корневых
          # };

          # allow-recursion { lan; };    // рекурсивные запросы тоже только из локальной

};

// описание настроек корневых серверов
zone "." {
          type hint;
          file "db.root";
};

// нижеописанные зоны определяют сервер авторитетным для петлевых
// интерфейсов, а так же для броадкаст-зон (согласно RFC 1912)

zone "localhost" {
          type master;
          file "localhost";
};

zone "127.in-addr.arpa" {
          type master;
          file "127.in-addr.arpa";
};

zone "0.in-addr.arpa" {
          type master;
          file "0.in-addr.arpa";
};

zone "255.in-addr.arpa" {
          type master;
          file "255.in-addr.arpa";
};

// описание основной зоны
zone "example.com" {
          type master;
          file "example.com";
          allow-transfer { 10.0.0.191; };
};

//описание обратных зон
zone "0.0.10.in-addr.arpa" {
          type master;
          file "0.0.10.in-addr.arpa";
          allow-transfer { 10.0.0.191; };
};

zone "1.168.192.in-addr.arpa" {
          type master;
          file "1.168.192.in-addr.arpa";
#         allow-transfer { 10.0.0.191; };  // зона описывает локальную сеть поэтому ее не передаем
};

// настройки логирования
logging {
          channel "misc" {
                    file "/var/log/bind/misc.log" versions 4 size 4m;
                    print-time yes;
                    print-severity yes;
                    print-category yes;
          };

          channel "query" {
                    file "/var/log/bind/query.log" versions 4 size 4m;
                    print-time yes;
                    print-severity no;
                    print-category no;
          };

          category default {
                    "misc";
          };

          category queries {
                    "query";
          };
};
-----------------------------------------------------------------------------
 BIND имеет рабочий каталог /var/cache/bind, сервер отвечает на запросы со
всех интерфейсов (allow-query {any ;};), рекурсивные запросы обрабатывает как
итеративные (recursion no), является мастер-сервером для зоны example.com и
локальных служебных зон (type master). При этом, если необходимо разрешить
кэширование (то есть рекурсивные запросы) для локальной сети, то необходимо
раскомментировать параметры forwarders и allow-recursion и закомментировать
recursion no;.
-----------------------------------------------------------------------------
возможности BIND логировать все происходящее при работе сервера (можно для этой цели использовать syslog).
-----------------------------------------------------------------------------
logging
-----------------------------------------------------------------------------
задаются 2 параметра channel (можно и больше двух - на ваше усмотрение), эти параметры дословно можно назвать "канал" записи. Каждый канал определяет имя канала и настройки параметров записи (что записывать, а что - нет и куда писать).
-----------------------------------------------------------------------------
category
-----------------------------------------------------------------------------
задает какую категорию сообщений в какой канал отправлять. Исходя из этого,
мы имеем: запись стандартной информации в канал misc, а приходящие запросы
посылаются в канал query. При этом, если файлы журнала достигают 4Мб (size 4m),
он переименовывается добавлением к имени .1 и начинается запись в новый журнал,
числа в конце других журналов увеличиваются. Журналы с номером, более
указанного в version (в нашем случае 4) удаляются 
-----------------------------------------------------------------------------
(Управлять ротацией логов можно так же с помощью logrotate).
-----------------------------------------------------------------------------
print* определяют заносить ли в журнал время появления, важность и категорию
информации. 
-----------------------------------------------------------------------------
Отдельно хочется описать параметр  allow-transfer { 10.0.0.191; };.
Данный параметр описывает серверы, которым разрешено скачивать копию зоны -
т.н. slave серверА. В следующем примере мы разберем настройку slave DNS.
-----------------------------------------------------------------------------
# mkdir /var/log/bind/
# chmod 744 /var/log/bind/
# ps aux | grep named
# chown bind /var/log/bind/
-----------------------------------------------------------------------------
файл описания зоны example.com.:
-----------------------------------------------------------------------------
dns:~# cat /var/cache/bind/example.com
$TTL 3D
@       IN      SOA     ns.example.com. root.example.com. (
                                        2011070601      ; serial
                                        8H              ; refresh
                                        2H              ; retry
                                        2W              ; expire
                                        1D)             ; minimum

@       IN      NS      ns.example.com.
@       IN      NS      ns2.example.com.
@       IN      A       10.0.0.152
@       IN      MX      5 mx.example.com.
ns      IN      A       10.0.0.152
ns2     IN      A       10.0.0.191
mx      IN      A       10.0.0.152
www     IN      CNAME   @
-----------------------------------------------------------------------------
а так же в домене in-addr.arpa.
-----------------------------------------------------------------------------
dns:~# cat /var/cache/bind/0.0.10.in-addr.arpa
$TTL 3600
@       IN      SOA     ns.examle.com.  root.example.com. (
             2007042001 ; Serial
             3600       ; Refresh
             900        ; Retry
             3600000    ; Expire
             3600 )     ; Minimum
        IN      NS      ns.examle.com.
        IN      NS      ns2.example.com.
152     IN      PTR     examle.com.
191     IN      PTR     ns.example.com.
*       IN      PTR     examle.com.
-----------------------------------------------------------------------------
dns:~# cat /var/cache/bind/1.168.192.in-addr.arpa
$TTL 3600
@       IN      SOA     ns.examle.com.  root.example.com. (
             2007042001 ; Serial
             3600       ; Refresh
             900        ; Retry
             3600000    ; Expire
             3600 )     ; Minimum
        IN      NS      ns.examle.com.
        IN      NS      ns2.example.com.
*       IN      PTR     examle.com.

-----------------------------------------------------------------------------
Вторичный (secondary, slave) авторитетный сервер зоны
-----------------------------------------------------------------------------
Основная функция slave сервера - автоматическая синхронизация описания зоны
с master сервером.
Так же, slave DNS-сервер делит нагрузку с master сервером или принимает на
себя всю нагрузку в случае аварии па первом сервере.
-----------------------------------------------------------------------------
необходимо проверить возможность получения зоны вручную со вторичного сервера
с помощью следующей команды:
-----------------------------------------------------------------------------
dig @10.0.0.152 example.com. axfr
 ...
 XFR size: 11 records (messages 1, bytes 258)

-----------------------------------------------------------------------------
Получение зоны прошло успешно. Далее, для настройки подчиненного сервера,
алгоритм следующий:

    Скопировать конфигурационный файл named.conf с master сервера;
    Заменить параметр type master на type slave в тех зонах, для которых он
будет вторичным;
    Параметр  allow-transfer { 10.0.0.191; }; заменить на masters { 10.0.0.152;};
в тех зонах, для которых он будет вторичным;
    Удалить зоны, которые не будет обслуживать текущий сервер, в том числе и
корневую, если slave не будет отвечать на рекурсивные запросы;
    Создать каталоги для логов, как в предыдущем примере.
-----------------------------------------------------------------------------
root@debian:~# cat /etc/bind/named.conf
options {
          directory "/var/cache/bind";
          allow-query { any; };      // отвечать на запросы со всех интерфейсов
          recursion no;              // запретить рекурсивные запросы
          auth-nxdomain no;          // для совместимости RFC1035
          listen-on-v6 { none; };    // IPv6 нам не нужен
          version "unknown";         // не отображать версию DNS сервера при ответах
};

// нижеописанные зоны определяют сервер авторитетным для петлевых
// интерфейсов, а так же для броадкаст-зон (согласно RFC 1912)

zone "localhost" {
          type master;
          file "localhost";
};

zone "127.in-addr.arpa" {
          type master;
          file "127.in-addr.arpa";
};

zone "0.in-addr.arpa" {
          type master;
          file "0.in-addr.arpa";
};

zone "255.in-addr.arpa" {
          type master;
          file "255.in-addr.arpa";
};

// описание основной зоны
zone "example.com" {
          type slave;
          file "example.com";
          masters { 10.0.0.152; };
};

//описание обратной зоны
zone "0.0.10.in-addr.arpa" {
          type slave;
          file "0.0.10.in-addr.arpa";
          masters { 10.0.0.152; };
};

// настройки логирования
logging {
          channel "misc" {
                    file "/var/log/bind/misc.log" versions 4 size 4m;
                    print-time YES;
                    print-severity YES;
                    print-category YES;
          };

          channel "query" {
                    file "/var/log/bind/query.log" versions 4 size 4m;
                    print-time YES;
                    print-severity NO;
                    print-category NO;
          };

          category default {
                    "misc";
          };

          category queries {
                    "query";
          };
};
-----------------------------------------------------------------------------
после перезапуска наш slave сервер благополучно скопирует необходимую ему
информацию с главного сервера, о чем будет говорить наличие файлов в  каталоге:

root@debian:~# ls -la /var/cache/bind/
-----------------------------------------------------------------------------
В принципе slave сервер может не хранить копию зоны у себя в файловой системе.
Эта копия нужна только в момент старта DNS. Наличие копии зоны в файловой
системе может избавить от сбоя при недоступности master сервера во время
запуска slave DNS. 
Если не указать опцию file в разделе zone, то копия не создается.
-----------------------------------------------------------------------------
Настройка netfilter (iptables) для DNS BIND
-----------------------------------------------------------------------------
dns ~ # iptables-save
# типовые правила iptables для DNS
*filter
:INPUT DROP [7511:662704]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]
-A INPUT -i lo -j ACCEPT
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -m conntrack --ctstate INVALID -j DROP
# разрешить доступ локальной сети к DNS серверу:
-A INPUT -s 192.168.1.1/24 -d 192.168.1.1/32 -p udp -m udp --dport 53 -m conntrack --ctstate NEW -j ACCEPT
-A OUTPUT -o lo -j ACCEPT
-A OUTPUT -p icmp -j ACCEPT
-A OUTPUT -p udp -m udp --sport 32768:61000 -j ACCEPT
-A OUTPUT -p tcp -m tcp --sport 32768:61000 -j ACCEPT
-A OUTPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
# разрешить доступ DNS серверу совершать исходящие запросы
-A OUTPUT -p udp -m udp --dport 53 -m conntrack --ctstate NEW -j ACCEPT
COMMIT
-----------------------------------------------------------------------------
Устранение неполадок
-----------------------------------------------------------------------------
Основным источником для выявления проблем с DNS является системный лог.
-----------------------------------------------------------------------------
dig domain – получить DNS информацию о domain
-----------------------------------------------------------------------------
    -x 1.2.3.4 – реверсивно искать данные о хосте 1.2.3.4 (то есть найти данные для 4.3.2.1.in-addr.arpa.)
    @ns.server - источником информации о DNS - использовать ns.server
    SOA|MX|A|NS - указать тип получаемой записи
    +short - получение коротких отчетов
    +nocomments - отключить комментарии в отчете
    +trace - включение трассировки поиска запрашиваемого значения
    -f file - запуск построчно команды dig с параметрами, указанными в каждой строке файла file
-----------------------------------------------------------------------------
named-checkzone zone_name /file/name/zone - проверяет синтаксис файла зоны /file/name/zone
-----------------------------------------------------------------------------
named-checkconf- проверяет синтаксис файла named.conf
-----------------------------------------------------------------------------
    -z - проверка named.conf с проверкой корректности файлов зон
-----------------------------------------------------------------------------
nslookup- интерактивные запросы к DNS
-----------------------------------------------------------------------------
    host - отобразить основные (A и MX) записи хоста host
    -debug - включить режим отладки
    -type=SOA|MX|A.... - вывод указанного типа ресурсной записи
    host ns.server - получить информацио о хосте host с DNS сервера ns.server
-----------------------------------------------------------------------------
host domain - получить DNS информацию о домене domain
-----------------------------------------------------------------------------
    -a - вывести все записи зоны
    -d - отладка
    -t A|MX... - указание типа ресурсной записи
    -v - вывод подробной информации
    host ns.server - узнать информацию о хосте host  с DNS сервера ns.server
-----------------------------------------------------------------------------
whois domain – получить информацию whois для domain
-----------------------------------------------------------------------------
Перенаправление с сайта при 301 на внешний сайт
-----------------------------------------------------------------------------
Редирект на ДНС
@	A	301-> https://site на
www	A	301-> https://site на
@	AAAA	301-> https://site на
www	AAAA	301-> https://site на
У клиента lozh.com.ua
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------

-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
dhcp
-----------------------------------------------------------------------------
# yum install dhcp.i386
-----------------------------------------------------------------------------
/etc/dhcpd.conf
usr/share/doc/dhcp-<version>/dhcpd.conf.sample
/var/lib/dhcpd/dhcpd.leases 
-----------------------------------------------------------------------------
Пример 1
-----------------------------------------------------------------------------
# Динамическое обновление DNS, обязательная строчка без нее dhcpd не запустится
# none - не использовать динамическое обновление
# ad-hoc - устарело, и не должно использоваться
# interim - позволяет обновлять DNS записи
ddns-update-style      none;
# Описание подсети
subnet 192.168.1.0 netmask 255.255.255.0 {
# Не обязательные параметры
    default-lease-time     600;                # Время аренды в секундах
    max-lease-time         7200;               # Максимальное время аренды в секундах
# Параметры передаваемые dhcp-клиентам
    option subnet-mask 255.255.255.0;          # Маска подсети
    option broadcast-address 192.168.1.255;    # Адрес широковещательной
                                               # рассылки
    option routers 192.168.1.1;                # Адрес шлюза
    option domain-name-servers 192.168.1.1;    # Список DNS-серверов
                                               # через запятую
    option netbios-node-type 8;                # Конфигурация WINS-клиента
                                               # 1 B-node: Broadcast - no WINS
                                               # 2 P-node: Peer - WINS only.
                                               # 4 M-node: Mixed - broadcast, then WINS
                                               # 8 H-node: Hybrid - WINS, then broadcast
    option netbios-name-servers 192.168.1.4;   # Список WINS-серверов
                                               # через запятую
    option domain-name "mydomain.com";         # Суффикс домена
    range 192.168.1.10 192.168.1.100;          # Область выдаваемых адресов
}
-----------------------------------------------------------------------------
Что бы сделать резервирование адресов в конфигурационный файл /etc/dhcpd.conf
в скцию subnet добавляем следующие строчки:
-----------------------------------------------------------------------------
host myhostname {                              # myhostname - имя хоста
   option host-name "myhostname";
   hardware ethernet 00:A0:78:8E:9E:AA;        # MAC-адрес хоста
   fixed-address 192.168.1.4;                  # Резервируемый IP-адресс
}
-----------------------------------------------------------------------------
Если в системе несколько интерфейсов, то указать с каким из них должен
работать dhcpd, можно отредактировав файл /etc/sysconfig/dhcpd
-----------------------------------------------------------------------------
DHCPDARGS=eth0                                 # имя интерфейса
-----------------------------------------------------------------------------
DHCP Relay Agent
-----------------------------------------------------------------------------
 When a DHCP client requests information, the DHCP Relay Agent forwards the
request to the list of DHCP servers specified when the DHCP Relay Agent is
started. When a DHCP server returns a reply, the reply is broadcast or unicast
on the network that sent the original request.
-----------------------------------------------------------------------------
The DHCP Relay Agent listens for DHCP requests on all interfaces unless the
interfaces are specified in 
-----------------------------------------------------------------------------
/etc/sysconfig/dhcrelay with the INTERFACES directive.
-----------------------------------------------------------------------------
To start the DHCP Relay Agent, use the command
# service dhcrelay start.
-----------------------------------------------------------------------------
ПРИМЕР 2 с DDNS-UPDATE
-----------------------------------------------------------------------------
Конф DHCP
-----------------------------------------------------------------------------
Код:	
#
# DHCP Server Configuration file.
#   see /usr/share/doc/dhcp*/dhcpd.conf.example
#   see dhcpd.conf(5) man page
#

authoritative;
log-facility local7;
ddns-domainname "mydomain.ru";
ddns-update-style interim;
ddns-updates on;
update-static-leases true;
update-conflict-detection false;
ignore client-updates;
#allow client-updates;

key DHCP_UPDATER {algorithm hmac-md5;secret pRP5FapFoJ95JEL06sv4PQ==;};

zone mydomain.ru. {
  primary 172.16.1.28;
  key DHCP_UPDATER;
}

zone 1.16.172.in-addr.arpa. {
  primary 172.16.1.28;
  key DHCP_UPDATER;
}

subnet 172.16.1.0 netmask 255.255.255.0 {
  range 172.16.1.200 172.16.1.230;
  option domain-name-servers 172.16.1.28;
  option domain-name "mydomain.ru";
  option routers 172.16.1.9;
  option broadcast-address 172.16.1.255;
  default-lease-time 600;
  max-lease-time 7200;

host LogServer {
  hardware ethernet 00:0c:29:13:bf:f2;
  fixed-address 172.16.1.27;
  option host-name "LogServer";
}
}	



Почему не работало толком update-static-leases true;
-----------------------------------------------------------------------------
Конф DNS
-----------------------------------------------------------------------------
Код:	

options {
        listen-on port 53 { 127.0.0.1; 172.16.1.28; };
        listen-on-v6 port 53 { ::1; };
        directory       "/var/named";
        dump-file       "/var/named/data/cache_dump.db";
        statistics-file "/var/named/data/named_stats.txt";
        memstatistics-file "/var/named/data/named_mem_stats.txt";
        allow-query     { any ; };
        recursion yes;
        dnssec-enable yes;
        allow-transfer{172.16.1.240;};
        dnssec-validation yes;
        bindkeys-file "/etc/named.iscdlv.key";
        managed-keys-directory "/var/named/dynamic";
        pid-file "/run/named/named.pid";
        session-keyfile "/run/named/session.key";
        forwarders {8.8.8.8;};
        version "DNS Server";


};

//logging {
//        channel default_debug {
//                file "/var/log/named/named_default.log";
//                severity dynamic;
//        };

logging {
  channel debug {
                file "/var/log/named/named_default.log";
                severity dynamic;
                print-category yes;
                print-severity yes;
                print-time yes;
                };
  channel xfer{
                file "/var/log/named/xfer_in_out.log" versions 3 size 5M;
                severity dynamic;
                print-category yes;
                print-severity yes;
                print-time yes;
               };
  channel queries{
                file "/var/log/named/queries.log" versions 3 size 5M;
                severity dynamic;
                print-category yes;
                print-severity yes;
                print-time yes;
               };
  channel notify{
                file "/var/log/named/notify.log" versions 3 size 5M;
                severity dynamic;
                print-category yes;
                print-severity yes;
                print-time yes;
               };
  channel update{
                file "/var/log/named/update.log" versions 3 size 5M;
                severity dynamic;
                print-category yes;
                print-severity yes;
                print-time yes;
               };
  category xfer-out {xfer;};
#  category queries {queries;};
  category notify {notify;};
  category update {update;};
  category "default" { "debug"; };
};
key DHCP_UPDATER {
         algorithm hmac-md5;
         secret pRP5FapFoJ95JEL06sv4PQ==;
       };

zone "." IN {
        type hint;
        file "named.ca";
};


zone "mydomain.ru" in {
              type master;
              file "mydomain.zone";
              allow-transfer{172.16.1.240;};
              allow-update {key DHCP_UPDATER;};
      };

zone "1.16.172.in-addr.arpa" in {
               type master;
               file "172.16.1.zone";
               allow-transfer{172.16.1.240;};
               allow-update {key DHCP_UPDATER;};
           };

include "/etc/named.rfc1912.zones";
include "/etc/named.root.key";	


-----------------------------------------------------------------------------
Ну и зоны
-----------------------------------------------------------------------------
Прямая

Код:	
$TTL 10800      ; 3 hours
mydomain.ru               IN SOA  ns.mydomain.ru. admin.mydomain.ru. (
                                2016150215 ; serial
                                300        ; refresh (5 minutes)
                                1800       ; retry (30 minutes)
                                604800     ; expire (1 week)
                                60         ; minimum (1 minute)
                                )
                        NS      ns.mydomain.ru.
$ORIGIN mydomain.ru.
LogServer               A       172.16.1.27

-----------------------------------------------------------------------------
Обратная

Код:	

$ORIGIN .
$TTL 10800      ; 3 hours
1.16.172.in-addr.arpa   IN SOA  mydomain.ru. admin.mydomain.ru. (
                                2016150210 ; serial
                                300        ; refresh (5 minutes)
                                1800       ; retry (30 minutes)
                                1209600    ; expire (2 weeks)
                                60         ; minimum (1 minute)
                                )
                        NS      ns.mydomain.ru.
$ORIGIN 1.16.172.in-addr.arpa.
27                      PTR     LogServer.mydomain.ru. 

-----------------------------------------------------------------------------
Пример 3
-----------------------------------------------------------------------------
Installing,configuring DNS,DHCP and Dynamic DNS on CENTOS 7
-----------------------------------------------------------------------------
# yum install bind-chroot bind-utils -y
-----------------------------------------------------------------------------
Then edit /etc/named.conf.file
-----------------------------------------------------------------------------
acl “allowed” {//create acl named allowed,to specify who can search our DNS server
192.168.122.0/24;
localhost;};
options {
listen-on port 53 { 192.168.122.200;127.0.0.1; };  //On which interfaces bind server will listen for requests
listen-on-v6 port 53 { ::1; };
directory “/var/named”;
dump-file “/var/named/data/cache_dump.db”;
statistics-file “/var/named/data/named_stats.txt”;
memstatistics-file “/var/named/data/named_mem_stats.txt”;
allow-query { allowed; };
forwarders {8.8.8.8;}; //forward all requests to Google server
recursion yes; //(the default) the server will always provide recursive query  if requested by the client
allow-recursion {allowed;}; //who can access DNS server cache
dnssec-enable no;   // disable maintaining the data integrity of DNS responses.
dnssec-validation no; //disable DNS query validation
dnssec-lookaside auto;

/* Path to ISC DLV key */
bindkeys-file “/etc/named.iscdlv.key”;

managed-keys-directory “/var/named/dynamic”;

pid-file “/run/named/named.pid”;
session-keyfile “/run/named/session.key”;
};

logging {
channel default_debug {
file “data/named.run”;
severity dynamic;
};
};

zone “.” IN {
type hint;
file “named.ca”;
};
include “/etc/named.rfc1912.zones”;
include “/etc/named.root.key”;
zone “122.168.192.in-addr.arpa” IN {
//this is our reverse lookup zone (translate IP address to names)
type master;         //it takes reverse IP of our network (192.168.122.)
file “/var/named/chroot/etc/named/reverse.example.com.db”;
//this is zone file we will created later
allow-update {none;};   //don’t allow dynamic zone updates (default) we will enable it later
};
zone “example.com” IN {  //forward lookup zone (example.com)
type master;
file “/var/named/chroot/etc/named/example.com.db”;
//zone file name and location,will be created latter
allow-update {none;};  //no Dynamic DNS
};
-----------------------------------------------------------------------------
check config files for typo errors:

[root@server1 dhcpd]# named-checkconf /etc/named.conf

of course,at this moment it’ll throw errors that files example.com and reverse.example.com.db

cannot be found,they don’t exist (yet).
-----------------------------------------------------------------------------
It’s high time now to create these files.

Template zone file is located at /usr/share/doc/bind-9.9.4/sample/var/named/named.localhost

we can use it as a template for our zone files.

Copy that file to /var/named/chroot/etc/named/ and save as example.com.db
-----------------------------------------------------------------------------
cp  /usr/share/doc/bind-9.9.4/sample/var/named/named.localhost /var/named/chroot/etc/named/example.com.db
-----------------------------------------------------------------------------
open example.com.db file in your favorite text editor and start editing:
-----------------------------------------------------------------------------
@ IN SOA server1.example.com. root.example.com. (

2015052601 ; serial
1D ; refresh
1H ; retry
1W ; expire
3H ) ; minimum

@ IN NS server1.example.com.
server1 IN A 192.168.122.200

Lets’s “decipher” these entries
-----------------------------------------------------------------------------
@ means this zone

SOA:The SOA record stores information about the name of the server that
supplied the data for the zone

root.example.com. (don’t forget period at the end) is mail address resposibile
person for zone

(although it dosen’t seems as e-mail address),remeber @ means “this zone in this case 🙂

2015052601 is serial zone number.It’s purpose in DNS zone files is to provide a way for
the server to verify that the contents of a zone file are up-to-date. If the
serial number in a zone file hasn’t changed since that zone was last loaded,
named figures that it can ignore the file.I put datetime as number,followed
with 01 at the end,you can put any number you like

Refresh: Indicates the time when the slave will try to refresh the zone from
the master (if we have another DNS server which transfers zone files from master server)

Retry:Defines the time between retries if the slave (secondary) fails to
contact the master when refresh (above) has expired

Expire:Indicates when the zone data are considered incorrect by slave
server,then slave tries to get update from master server

Minimum: defines the duration in seconds that the record may be cached

We don’t have slave server so accept default values
-----------------------------------------------------------------------------
@ IN NS server1.example.com. don’t forget period at the end,if you ommit it then server name would

be appended at the end (server1.example.com.server1-is Name server for zone (our server)
server1 IN A 192.168.122.200  host (A) record our server

Copy that file as reverse.example.com.db (zone file for our reverse lookup zone)
@ IN SOA server1.example.com. root.example.com. (
2015052601 ; serial
1D ; refresh
1H ; retry
1W ; expire
3H ) ; minimum
@ IN NS server1.example.com.
server1 IN A 192.168.122.200
200 IN PTR server1.example.com

200 IN PTR server1.example.com is PTR record for our server (last octet of IP address 192.168.122.200)
-----------------------------------------------------------------------------
Check both files for errors

[root@server1 dhcpd]# named-checkconf /var/named/chroot/etc/named/example.com.db

named-checkconf /var/named/chroot/etc/named/reverse.example.com.db
-----------------------------------------------------------------------------
Open firewall port (53)
-----------------------------------------------------------------------------
[root@server1 dhcpd]#firewall-cmd –zone=public –add-service=dns –permanent

[root@server1 dhcpd]#firewall-cmd –reload
-----------------------------------------------------------------------------
set folder permissons

[root@server1 dhcpd]#chown named:named -Rf /var/named/chroot/etc/named/

[root@server1 dhcpd]#chmod 775 -Rf /var/named/chroot/etc/named/
-----------------------------------------------------------------------------
restart named service

[root@server1 dhcpd]#systemctl restart named
-----------------------------------------------------------------------------
and check if service listens on port 53:

Untitled5

Point client computer to our DNS server:

Edit interface file in /etc/sysconfig/network-scripts/
-----------------------------------------------------------------------------
TYPE=”Ethernet”
BOOTPROTO=”static”
DEFROUTE=”yes”
IPADDR=192.168.122.100
NETMASK=255.255.255.0
GATEWAY=192.168.122.1
IPV4_FAILURE_FATAL=”no”
IPV6INIT=”yes”
IPV6_AUTOCONF=”yes”
IPV6_DEFROUTE=”yes”
IPV6_FAILURE_FATAL=”no”
NAME=”ens3″
DNS1=192.168.122.200
UUID=”405213a0-56f5-4d45-b21e-244b19f7c3ef”
ONBOOT=”yes”
HWADDR=”52:54:00:14:3f:47″
PEERDNS=”yes”
PEERROUTES=”yes”
IPV6_PEERDNS=”yes”
IPV6_PEERROUTES=”yes”
-----------------------------------------------------------------------------
restart network service and test DNS server:
-----------------------------------------------------------------------------
[root@localhost ~]# dig skins.be

; <<>> DiG 9.9.6-RedHat-9.9.6-4.fc21 <<>> skins.be
;; global options: +cmd
;; Got answer:
;; ->>HEADER< ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 13, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;skins.be. IN A

;; ANSWER SECTION:
skins.be. 3547 IN A 213.131.234.8

—-output cut———-

search our zone,example,com:
-----------------------------------------------------------------------------
[root@localhost ~]# dig example.com

; <<>> DiG 9.9.6-RedHat-9.9.6-4.fc21 <<>> example.com
;; global options: +cmd
;; Got answer:
;; ->>HEADER< ;; flags: qr aa rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;example.com. IN A

;; AUTHORITY SECTION:
example.com. 10800 IN SOA server1.example.com. root.example.com. 2015052607 86400 3600 604800 10800

;; Query time: 1 msec
;; SERVER: 192.168.122.200#53(192.168.122.200)
;; WHEN: Wed May 27 18:53:21 EDT 2015
;; MSG SIZE rcvd: 89

So far so good,
-----------------------------------------------------------------------------
Install and configure DHCP server:
-----------------------------------------------------------------------------
Install dhcp package

yum install dhcp -y

Then copy dhcpd.conf.example in /etc/dhcp folder:

cp  /usr/share/doc/dhcp-4.2.5/dhcpd.conf.example /etc/dhcp/dhcpd.conf

Here is dhcpd.conf file:
-----------------------------------------------------------------------------
dhcpd.conf
-----------------------------------------------------------------------------
#
# Sample configuration file for ISC dhcpd
#

# option definitions common to all supported networks…
option domain-name “example.com”;
option domain-name-servers 192.168.122.200;

default-lease-time 600;
max-lease-time 7200;

# Use this to enble / disable dynamic dns updates globally.
#ddns-update-style none;

# If this DHCP server is the official DHCP server for the local
# network, the authoritative directive should be uncommented.
#authoritative;

# Use this to send dhcp log messages to a different log file (you also
# have to hack syslog.conf to complete the redirection).
log-facility local7;

# No service will be given on this subnet, but declaring it helps the
# DHCP server to understand the network topology.

#subnet 10.152.187.0 netmask 255.255.255.0 {
#}

# This is a very basic subnet declaration.

#subnet 10.254.239.0 netmask 255.255.255.224 {
# range 10.254.239.10 10.254.239.20;
# option routers rtr-239-0-1.example.org, rtr-239-0-2.example.org;
#}

# This declaration allows BOOTP clients to get dynamic addresses,
# which we don’t really recommend.

#subnet 10.254.239.32 netmask 255.255.255.224 {
# range dynamic-bootp 10.254.239.40 10.254.239.60;
# option broadcast-address 10.254.239.31;
# option routers rtr-239-32-1.example.org;
#}

# A slightly different configuration for an internal subnet.
subnet 192.168.122.0 netmask 255.255.255.0 {   //our subnet
range 192.168.122.10 192.168.122.20;         //range
option domain-name-servers 192.168.122.200;
option domain-name “example.com”;
option routers 192.168.122.1;
option broadcast-address 192.168.122.255;
default-lease-time 600;
max-lease-time 7200;

}

# Hosts which require special configuration options can be listed in
# host statements. If no address is specified, the address will be
# allocated dynamically (if possible), but the host-specific information
# will still come from the host declaration.

host passacaglia {
hardware ethernet 0:0:c0:5d:bd:95;
filename “vmunix.passacaglia”;
server-name “toccata.fugue.com”;
}

# Fixed IP addresses can also be specified for hosts. These addresses
# should not also be listed as being available for dynamic assignment.
# Hosts for which fixed IP addresses have been specified can boot using
# BOOTP or DHCP. Hosts for which no fixed address is specified can only
# be booted with DHCP, unless there is an address range on the subnet
# to which a BOOTP client is connected which has the dynamic-bootp flag
# set.

host fantasia {
hardware ethernet 08:00:07:26:c0:a5;
fixed-address fantasia.fugue.com;
}

# You can declare a class of clients and then do address allocation
# based on that. The example below shows a case where all clients
# in a certain class get addresses on the 10.17.224/24 subnet, and all
# other clients get addresses on the 10.0.29/24 subnet.

class “foo” {
match if substring (option vendor-class-identifier, 0, 4) = “SUNW”;
}

shared-network 224-29 {
subnet 10.17.224.0 netmask 255.255.255.0 {
option routers rtr-224.example.org;
}
subnet 10.0.29.0 netmask 255.255.255.0 {
option routers rtr-29.example.org;
}
pool {
allow members of “foo”;
range 10.17.224.10 10.17.224.250;
}
pool {
deny members of “foo”;
range 10.0.29.10 10.0.29.230;
}
}
-----------------------------------------------------------------------------
check file for errors:
[root@server1 dhcpd]# dhcpd -cf /etc/dhcp/dhcpd.conf
-----------------------------------------------------------------------------
If you didn’t installed this server on KVM switch (and set virtual adapter to
receive address from host DHCP),you can start DHCP service.

Othervise,we must first disable DHCP service on interface,othervise,our client
won’t receive DHCP DIscover and DHCP offer packets from our DHCP server but
from KVM host,and our log file will be receiving

“Unknown lease” .

in terminal,type
-----------------------------------------------------------------------------
root@host # virsh

virsh # net-destroy yournetwork
virsh # net-edit yournetwork
[remove the element, save, exit]
virsh # net-start yournetwork
-----------------------------------------------------------------------------
Restart your Virtual machine and then start dhcp service on KVM virtual
machine (server1.example.com)
-----------------------------------------------------------------------------
[root@server1 dhcpd]# systemctl restart dhcpd

Configure client to receive address from our DHCP server:

Edit interface file:

TYPE=”Ethernet”
BOOTPROTO=“dhcp”
DEFROUTE=”yes”
IPV4_FAILURE_FATAL=”no”
IPV6INIT=”yes”
IPV6_AUTOCONF=”yes”
IPV6_DEFROUTE=”yes”
IPV6_FAILURE_FATAL=”no”
NAME=”ens3″
UUID=”405213a0-56f5-4d45-b21e-244b19f7c3ef”
ONBOOT=”yes”
HWADDR=”52:54:00:14:3f:47″
PEERDNS=”yes”
PEERROUTES=”yes”
IPV6_PEERDNS=”yes”
IPV6_PEERROUTES=”yes”

restart network,and type ifconfig:
-----------------------------------------------------------------------------
root@localhost ~]# ifconfig

ens3: flags=4163<UP,BROADCAST,RUNNING,MULTICAST> mtu 1500
inet 192.168.122.11 netmask 255.255.255.0 broadcast 192.168.122.255
inet6 fe80::5054:ff:fe14:3f47 prefixlen 64 scopeid 0x20 ether 52:54:00:14:3f:47 txqueuelen 1000 (Ethernet)
RX packets 676 bytes 72259 (70.5 KiB)
RX errors 0 dropped 0 overruns 0 frame 0
TX packets 2222 bytes 142855 (139.5 KiB)
TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0

we got address from our range (192.168.122.10-192.168.122.20)

Switch to server and check log file:

Untitled
-----------------------------------------------------------------------------
Dynamic DNS Updates
-----------------------------------------------------------------------------
DNS client computers can use dynamic update to register and dynamically
update their resource records with a DNS server whenever changes occur.
This reduces the need for manual administration of zone records, especially
for clients that frequently move or change locations and use Dynamic Host
Configuration Protocol (DHCP) to obtain an IP address,to do it securely,
wee need to first create a secret key. This secret key will be used to
authenticate our dns update clients with the dns server.

First,generate the key:
-----------------------------------------------------------------------------
[root@server1 dhcpd]#dnssec-keygen -a hmac-md5 -b 128 -n USER dhcpupdate
-----------------------------------------------------------------------------
Kdhcpupdate.+157+06009

The output is the file prefix. If you do ls Kdhcpupdate.+157+06009* 
 will see two files. The .key file is most useful,open the .key file:

The selected part will be used for authentication:

Untitled8

Let’s configure our dhcp server for Secure DNS updates:

make changes to dhcpd.conf file (I bold updates)
-----------------------------------------------------------------------------
# dhcpd.conf
-----------------------------------------------------------------------------
#
# Sample configuration file for ISC dhcpd
#

# option definitions common to all supported networks…
option domain-name “example.com”;
option domain-name-servers 192.168.122.200;

default-lease-time 600;
max-lease-time 7200;

# Use this to enble / disable dynamic dns updates globally.
ddns-update-style interim; //interim: allows your DHCP server to update a
//DNS server whenever it hands //out a lease. Allows your DNS server to know which
//IP addresses are associated with which computers in 
//your network. Requires that your DNS server support DDNS (Dynamic DNS)

//none: to disable dynamic DNS updates or DNS is not supporting DDNS.
update-static-leases-on;          
key dhcp_updater {       //we here defined key called dhcp_updater and configured it’s
algorithm hmac-md5;      //properties (algorithm and secret key (created with dnssec-keygen
secret kfc1r6C2VwHGnKMi/NHt6w==;    

}
zone 122.168.192.in-addr.arpa {
primary 192.168.122.200;
key dhcp_updater;  //use this key to update zone
}
zone example.com {
primary 192.168.122.200;
key dhcp_updater;      //use this key to update zone
}
# If this DHCP server is the official DHCP server for the local
# network, the authoritative directive should be uncommented.

#authoritative;

# Use this to send dhcp log messages to a different log file (you also
# have to hack syslog.conf to complete the redirection).
log-facility local7;

# No service will be given on this subnet, but declaring it helps the
# DHCP server to understand the network topology.

#subnet 10.152.187.0 netmask 255.255.255.0 {
#}

# This is a very basic subnet declaration.

#subnet 10.254.239.0 netmask 255.255.255.224 {
# range 10.254.239.10 10.254.239.20;
# option routers rtr-239-0-1.example.org, rtr-239-0-2.example.org;
#}

# This declaration allows BOOTP clients to get dynamic addresses,
# which we don’t really recommend.

#subnet 10.254.239.32 netmask 255.255.255.224 {
# range dynamic-bootp 10.254.239.40 10.254.239.60;
# option broadcast-address 10.254.239.31;
# option routers rtr-239-32-1.example.org;
#}

# A slightly different configuration for an internal subnet.
subnet 192.168.122.0 netmask 255.255.255.0 {
range 192.168.122.10 192.168.122.20;
option domain-name-servers 192.168.122.200;
option domain-name “example.com”;
option routers 192.168.122.1;
option broadcast-address 192.168.122.255;
default-lease-time 600;
max-lease-time 7200;

}

# Hosts which require special configuration options can be listed in
# host statements. If no address is specified, the address will be
# allocated dynamically (if possible), but the host-specific information
# will still come from the host declaration.

host passacaglia {
hardware ethernet 0:0:c0:5d:bd:95;
filename “vmunix.passacaglia”;
server-name “toccata.fugue.com”;
}

# Fixed IP addresses can also be specified for hosts. These addresses
# should not also be listed as being available for dynamic assignment.
# Hosts for which fixed IP addresses have been specified can boot using
# BOOTP or DHCP. Hosts for which no fixed address is specified can only
# be booted with DHCP, unless there is an address range on the subnet
# to which a BOOTP client is connected which has the dynamic-bootp flag
# set.

host fantasia {
hardware ethernet 08:00:07:26:c0:a5;
fixed-address fantasia.fugue.com;
}

# You can declare a class of clients and then do address allocation
# based on that. The example below shows a case where all clients
# in a certain class get addresses on the 10.17.224/24 subnet, and all
# other clients get addresses on the 10.0.29/24 subnet.

class “foo” {
match if substring (option vendor-class-identifier, 0, 4) = “SUNW”;
}

shared-network 224-29 {
subnet 10.17.224.0 netmask 255.255.255.0 {
option routers rtr-224.example.org;
}
subnet 10.0.29.0 netmask 255.255.255.0 {

option routers rtr-29.example.org;
}
pool {
allow members of “foo”;
range 10.17.224.10 10.17.224.250;
}
pool {
deny members of “foo”;
range 10.0.29.10 10.0.29.230;
}
}
-----------------------------------------------------------------------------
Lease info is written in leases files in /var/lib/dhcpd folder:

[root@server1 dhcpd]# ls
dhcpd6.leases dhcpd.leases dhcpd.leases~
-----------------------------------------------------------------------------
Now edit named.conf:
-----------------------------------------------------------------------------
(Changes bolded)

acl “allowed” {
192.168.122.0/24;
localhost;};

options {
listen-on port 53 { 192.168.122.200;127.0.0.1; };
listen-on-v6 port 53 { ::1; };
directory “/var/named”;
dump-file “/var/named/data/cache_dump.db”;
statistics-file “/var/named/data/named_stats.txt”;
memstatistics-file “/var/named/data/named_mem_stats.txt”;
allow-query { allowed; };
forwarders {8.8.8.8;};

recursion yes;
allow-recursion {allowed;};

dnssec-enable yes;
dnssec-validation yes;
dnssec-lookaside auto;

/* Path to ISC DLV key */
bindkeys-file “/etc/named.iscdlv.key”;

managed-keys-directory “/var/named/dynamic”;

pid-file “/run/named/named.pid”;
session-keyfile “/run/named/session.key”;
};

logging {
channel default_debug {
file “data/named.run”;
severity dynamic;

};

};
key dhcp_updater {
algorithm hmac-md5;
secret “kfc1r6C2VwHGnKMi/NHt6w==”;
};

zone “.” IN {
type hint;
file “named.ca”;

};
include “/etc/named.rfc1912.zones”;
include “/etc/named.root.key”;
zone “122.168.192.in-addr.arpa” IN {
type master;
file “/var/named/chroot/etc/named/reverse.example.com.db”;

allow-update {key “dhcp_updater”;};
};

zone “example.com” IN {
type master;

file “/var/named/chroot/etc/named/example.com.db”;
allow-update {key “dhcp_updater“;};
};

But,we are not done yet,

We now must configure SELinux policy to allow user named to create journal files

chcon -R -t dnssec_trigger_var_run_t ‘/var/named/chroot/etc/named/’

othervise,we’ll receive this error:

Untitled2

Check system time on the server (if it’s not synchronized with time server you won’t be able to access

the internet

Now restart named and dhcpd service on server,and network service on client and

check log file on server,client should be updated in example.com.db file:

Untitled3

$ORIGIN .
$TTL 10800 ; 3 hours
example.com IN SOA server1.example.com. root.example.com. (
2015052607 ; serial
86400 ; refresh (1 day)
3600 ; retry (1 hour)
604800 ; expire (1 week)
10800 ; minimum (3 hours)
)
NS server1.example.com.
$ORIGIN example.com.
$TTL 300 ; 5 minutes
localhost A 192.168.122.11   //this is our client
TXT “3145910aacd6ffbcd99fae801b8ffe89d5”
$TTL 10800 ; 3 hours
server1 A 192.168.122.200

-----------------------------------------------------------------------------
route
-----------------------------------------------------------------------------
# /etc/init.d/network restart
# systemctl restart networking.service
-----------------------------------------------------------------------------
Конфигурационные файлы
-----------------------------------------------------------------------------
    Debian GNU/Linux: /etc/network/interfaces
    RHEL/CentOS/Scientifix: etc/sysconfig/network-scripts/route-<interface name>
-----------------------------------------------------------------------------
Monitoring
-----------------------------------------------------------------------------
ping (проверка соединения с узлом),
ifconfig, 
traceroute (трассировка маршрутов следования до узла – по умолчанию в пределах
	30 "прыжков"), route
netstat,
-----------------------------------------------------------------------------
Для графического отображения трассировки к хостам используется утилита
tracemap3, написанная на Perl. С ее помощью можно строить графические карты
для нескольких удаленных узлов, например, отдельной филиальной сети.
-----------------------------------------------------------------------------
3http://xgu.ru/wiki/Tracemap
-----------------------------------------------------------------------------
Просмотреть таблицу можно следующими способами:
-----------------------------------------------------------------------------
# route
# netstat -rn
# ip route show
# cat /proc/net/route
-----------------------------------------------------------------------------
Использование route
-----------------------------------------------------------------------------
Добавление маршрута через шлюз: route add -net 192.168.0.0/16 gw 10.0.0.1
 Добавление маршрута через интерфейс: route add -net 192.168.0.0/16 dev eth1
 Маршрут до отдельного хоста: route add -host 192.168.0.1 gw 172.16.0.1
 Удаление маршрута: route del ...
-----------------------------------------------------------------------------
Sometimes we may want to reject routing the packets to a particular host/network. To do that, add the following entry.
-----------------------------------------------------------------------------
# route add -host 192.168.1.51 reject
-----------------------------------------------------------------------------
If you want to reject an entire network ( 192.168.1.1 – 192.168.1.255 ), then add the following entry.
-----------------------------------------------------------------------------
$ route add -net 192.168.1.0 netmask 255.255.255.0 reject
-----------------------------------------------------------------------------
Использование ip
-----------------------------------------------------------------------------
Синтаксис ip по структуре напоминает синтаксис Cisco IOS. Любые опции могут
быть сокращены до потери двусмысленности, например «ip ro ad» вместо «ip route add».
-----------------------------------------------------------------------------
 Добавление маршрута через шлюз: ip route add 172.16.10.0/24 via 192.168.1.1
 Добавление маршрута через интерфейс: ip route add 172.16.10.0/24 dev eth0
 Маршрут с метрикой: ip route add 172.16.10.0/24 dev eth0 metric 100
-----------------------------------------------------------------------------
Командой вида ip route add blackhole 10.56.50.0/27 можно добавить
«зануленный» маршрут (аналог «ip route ... null0» в Cisco). Пакеты в сеть с таким маршрутом будут удалены
с причиной «No route to host». Может быть полезно для подавление DoS-атаки с хоста или иных
подобных случаев. 
-----------------------------------------------------------------------------
Действия с маршрутами
-----------------------------------------------------------------------------
Кроме add также поддерживаются и другие действия:

    del — удалить маршрут.
    replace — заменить маршрут другим.
    change — изменить параметры маршрута. 
-----------------------------------------------------------------------------
IPv6
-----------------------------------------------------------------------------
Настройка маршрутизации IPv6 почти идентична настройке для IPv4.

# ip route add ::/0 via 2001:db8:dead:beef::1/64
-----------------------------------------------------------------------------
В некоторых дистрибутивах еще есть нерешенная проблема с маршрутом по
умолчанию (например, старые версии RHEL), используйте

# ip route add 2000::/3 ...
-----------------------------------------------------------------------------
Просмотр маршрутов до определенной сети
-----------------------------------------------------------------------------
На маршрутизаторах с длинной таблицей может быть неудобно просматривать вывод
«ip route show» в поисках нужного маршрута. В этом случае можно использовать команду вида:

# ip route show 10.0.0.0/8
-----------------------------------------------------------------------------
Пересылка пакетов между интерфейсами
-----------------------------------------------------------------------------
Linux позволяет разрешить или запретить пересылку пакетов между интерфейсами
(forwarding). На рабочих станциях и серверах приложений ее можно запретить,
на маршрутизаторах или межсетевых экранах она, очевидно, должна быть разрешена.
-----------------------------------------------------------------------------
За этот параметр для IPv4 отвечает переменная net.ipv4.ip_forward (1 =
«разрешить», 0 = «запретить»).
-----------------------------------------------------------------------------
 cat /proc/sys/net/ipv4/ip_forward
 echo 1 > /proc/sys/net/ipv4/ip_forward
-----------------------------------------------------------------------------
Для IPv6 используйте net.ipv6.conf.all.forwarding
-----------------------------------------------------------------------------
 cat /proc/sys/net/ipv6/conf/all/forwarding
 echo 1 > /proc/sys/net/ipv6/conf/all/forwarding
-----------------------------------------------------------------------------
Чтобы настройки сохранились после перезагрузки, пропишите значения
net.ipv4.ip_forward и net.ipv6.conf.all.forwarding в /etc/sysctl.conf. 
-----------------------------------------------------------------------------
Policy routing
-----------------------------------------------------------------------------
 ip route add default via 10.0.1.2
 ip rule add from 192.168.1.1 lookup 3
 ip route add default via 10.0.3.4 table 3
-----------------------------------------------------------------------------
Для хоста 192.168.1.1 используется особенная таблица маршрутизации (table 3),
не такая как для всех остальных хостов. В ней указан единственный маршрут — маршрут по умолчанию.

Все будут ходить через шлюз 10.0.1.2, а 192.168.1.1 — через 10.0.3.4. 
-----------------------------------------------------------------------------
Например, нам нужен маршрут по-умолчанию. Без него вы не выйдете за пределы своей сети
# route add default gw 192.168.0.1
в данном примере 192.168.0.1 - это адрес вашего шлюза. 
-----------------------------------------------------------------------------
Теперь посмотрим как удалить маршрут по-умолчанию
# route del default gw 192.168.0.1
-----------------------------------------------------------------------------
Теперь посмотрим, как прописать маршрут до сервера 192.168.2.1, который находится за шлюзом 192.168.0.1
# route add -host 192.168.2.1 gw 192.168.0.1
-----------------------------------------------------------------------------
Удалить такой маршрут так же просто, заменив add на del
# route add -host 192.168.2.1 gw 192.168.0.1


-----------------------------------------------------------------------------
ssh/sftp
-----------------------------------------------------------------------------
# ssh user@host– подключится к host как user
        -p port – подключится на порт port
-----------------------------------------------------------------------------
# ssh-copy-id user@host – добавить ваш ключ на host для user чтобы включить
			логин без пароля и по ключам
-----------------------------------------------------------------------------
	Доступ локального пользователя на сервер, генерируем ключи на сервере.
-----------------------------------------------------------------------------
ssh-keygen -t rsa -b 4096
~/.ssh/id_rsa.pub -> sudo chmod 0700 ~/.ssh/ 
~/.ssh/id_rsa -> sudo chmod 0600 ~/.ssh/id*
scp /home/NameUser/.ssh/id_rsa NameUser@ipadressremotehost:/PathToFolder/
rm /home/NameUser/.ssh/id_rsa
cd ~/.ssh
sudo touch authorized_key
sudo chown NameUser:NameUser authorized_keys
sudo cat id_rsa.pub >> authorized_keys
sudo chmod 0700 ~/.ssh/
sudo chmod 0600 ~/.ssh/authorized_keys
sshd_config
# разрешаем использование RSA ключей
Authentication yes # если используете SSH1 не желательно
# разрешаем авторизацию при помощи ключей
PubkeyAuthentication yes
# Пут где будут находиться ключи, с которыми можно соединяться для каждого
пользователя свой файл в его директории.
AuthorizedKeysFile %h/.ssh/authorized_keys
PasswordAuthentication no
PermitEmptyPasswords no
service ssh restart
Удаление rm authorized_key id_rsa.pub id_rsa
-----------------------------------------------------------------------------
	Доступ удаленного пользователя на сервер, генерируем ключи на клиенте.
-----------------------------------------------------------------------------
ssh-keygen -t rsa -b 4096
~/.ssh/id_rsa.pub -> sudo chmod 0700 ~/.ssh/ 
~/.ssh/id_rsa -> sudo chmod 0600 ~/.ssh/id*
ssh-copy-id "-p 8022 NameUserONOpenSSHServer@ipAdressOpenSSHServer"
sudo ssh 'NameUserONOpenSSHServer@ipAdressOpenSSHServer'
sudo cat /home/NameUserONOpenSSHServer/.ssh/authorized_keys
sudo service ssh restart
chmod 0600 ~/.ssh/authorized_keys
ssh NameUser@ipAdressOpenSSHServer
-----------------------------------------------------------------------------
	Для Windows – генерировать ключ на сервере, затем импортировать putty_gen.
Для Linux – локально, затем передать.
-----------------------------------------------------------------------------
# sftp username@remote_hostname_or_IP
# pwd
# ls -la
# cd testDirectory
# lpwd
# lls -la
# lcd Directory
# get remoteFile
# get remoteFile localFile
# get -Pr someDirectory
# put localFile
# df -h

# !	Команда "!" переводит нас в локальный shell, где мы можем выполнить
	любую команду, доступную в нашей локальной системе.
# df -h	например
-----------------------------------------------------------------------------
Простые операции с файлами через SFTP
-----------------------------------------------------------------------------
# chown userID file

Обратите внимание, что, в отличие от системной команды "chmod", SFTP-команда
принимает в виде параметра не имя пользователя, а его идентификатор.
К сожалению, не существует простого способа узнать идентификатор пользователя
из SFTP-интерфейса.

Проблему можно обойти следующим образом:

# get /etc/passwd
# !less passwd
-----------------------------------------------------------------------------
# chgrp groupID file

И опять, не существует простого способа получить список групп удаленной
системы. Данную проблему можно обойти при помощи следующей команды:

# get /etc/group
# !less group
-----------------------------------------------------------------------------
# chmod 777 publicFile
-----------------------------------------------------------------------------
Команды для изменения прав доступа к локальным файлам нет, но Вы можете
настроить локальную umask (маска режима создания пользовательских файлов)
так, чтобы любые файлы, копируемые в локальную систему, будут иметь
соответствующие права доступа.

Это может быть сделано при помощи команды "lumask":

# lumask 022
-----------------------------------------------------------------------------
Следующие команды работают только на удаленной файловой системе:

# ln
# rm
# rmdir
-----------------------------------------------------------------------------
# exit или 
# bye
-----------------------------------------------------------------------------
firewalld
-----------------------------------------------------------------------------
﻿################
#Firewalld
################
-------------------------------------------------------------------------------------------
# systemctl status firewalld
# firewall-cmd --state
# systemctl start firewalld
# systemctl enable firewalld
# systemctl disable firewalld
# systemctl stop firewalld

# yum install iptables-services
# systemctl start iptables
# systemctl start ip6tables
# systemctl enable iptables
# systemctl enable ip6tables
# /sbin/iptables-save > /etc/sysconfig/iptables
# /sbin/ip6tables-save > /etc/sysconfig/ip6tables

Или по-старинке:
# service iptables save
Текущие правила находятся в файлах:
/etc/sysconfig/iptables
/etc/sysconfig/ip6tables

Перезапуск iptables (например, после совершения каких-либо изменений):
# systemctl restart iptables.service
---------------------------------------------------------------------------------------------------
firewalld хранит свои настройки в XML файлах раскидав их по /usr/lib/firewalld/ и /etc/firewalld/
---------------------------------------------------------------------------------------------------

    drop – как и следовало ожидать входящие сетевые пакеты сбрасываются, без ответа, допускаются только исходящие соединения
    block – входящие сетевые соединения отклоняются с сообщением icmp-host-prohibited для Ipv4 и icmp6-adm-prohibited для IPv6
	    допускаются только сетевые соединения инициированные внутри нашей системы.
    public – разрешается устанавливать только конкретные входящие соединения.
    external – для использования во внешних сетях с разрешенным маскарадингом, особенно для роутеров,
	       разрешается устанавливать только конкретные входящие соединения
    dmz – для компьютеров собственной демилитаризованной зоне с ограниченным доступом к вашей внутренней сети,
	  разрешается устанавливать только конкретные входящие соединения.
    work/home/internal – Для всех трёх зон в описании примерно та же вода, плюс:
	максимальное доверие к компьютерам, уверенность в том, что они не причинят вреда нашему компьютеру,
	разрешается устанавливать только конкретные входящие соединения
    trusted – Специальная зона, где все сетевые соединения разрешены.

-------------------------------------------------------------------------------------------
Packet Forwarding
-------------------------------------------------------------------------------------------
To configure routing, the server needs to forward incoming packets from one interface to another interface.
Create a new file /etc/sysctl.d/ip_forward.conf and add the following:

net.ipv4.ip_forward=1

The above makes the change permanent. Now change the runtime value:
# sysctl -w net.ipv4.ip_forward=1
-------------------------------------------------------------------------------------------
#firewall-cmd --zone=[нужная_зона] --add-port=5280/tcp --permanent
#firewall-cmd --reload
-------------------------------------------------------------------------------------------
[--zone=нужная_зона] --list-services 	Просмотреть список сервисов в зоне
[--zone=нужная_зона] --list-ports 	Просмотреть список портов в зоне
--permanent 	объявить вносимые изменеия постоянными
--state  	 узнать состояние FirewallD
 --reload 	 перезагрузить FirewallD
 --get-zones 	 вывести список всех заданных зон
 --get-services 	 список всех поддерживаемых служб
--get-active-zones 	список всех активных зон
[--zone=нужная_зона] --add-interface=интерфейс 	добавить интерфейс к зоне
[--zone=нужная_зона] --change-interface= интерфейс 	изменить интерфейс
[--zone=нужная_зона] --remove-interface= интерфейс 	удалить интерфейс из зоны
--panic-on 	режим паники, блокирующий все сетевые соединения
--panic-off  	отмена режима паники
[--zone=нужная_зона] --add-service=нужный_сервис [--timeout=] 	добавить службу к зоне
[--zone=нужная_зона] --remove-service= нужный_сервис [--timeout=] 	- удалить службу из зоны
[--zone=нужная_зона] --add-port=[-]/ [--timeout=]       	добавить порт к зоне
[--zone=нужная_зона] --remove-port=[-]/ [--timeout=]  	удалить порт из зоны
[--zone=нужная_зона] --add-masquerade 	добавить маскарадинг к зоне
[--zone=нужная_зона] --remove-masquerade   	удалить маскарадинг
[--zone=нужная_зона] --add-forward-port=port=[-]:proto= { :toport=[-] | :toaddr=| :toport=[-]:toaddr=} 	добавить проброс портов к зоне
[--zone=нужная_зона] --remove-forward-port=port=[-]:proto= { :toport=[-] | :toaddr=| :toport=[-]:toaddr=} 	удалить проброс портов из зон
-------------------------------------------------------------------------------------------
Пример: разрешаем ssh на нестандартном порте

# firewall-cmd --permanent --zone=public --add-port=2234/tcp
# firewall-cmd --reload
# firewall-cmd --zone=public --list-ports
2234/tcp
# nano /etc/ssh/sshd_config
...
port 2234
# systemctl restart sshd.service
# yum provides semanage
# yum install policycoreutils-python
# semanage port -a -t ssh_port_t -p tcp 2234
# firewall-cmd --permanent --zone=public --remove-service=ssh
# firewall-cmd --reload
# firewall-cmd --list-all
-------------------------------------------------------------------------------------------
# firewall-cmd --permanent --zone=public --remove-service=dhcpv6-client
-------------------------------------------------------------------------------------------
# firewall-cmd --zone=public --permanent --add-interface=em1
-------------------------------------------------------------------------------------------
# firewall-cmd --zone=public --add-port=5059-5061/udp
-------------------------------------------------------------------------------------------
Маскарад (masquerade, он же nat, он же...):

# firewall-cmd --zone=external --query-masquerade
# firewall-cmd --zone=external --add-masquerade
# firewall-cmd --zone=external --add-forward-port=port=22:proto=tcp:toaddr=192.168.1.23
# firewall-cmd --zone=external --add-forward-port=port=22:proto=tcp:toport=2055:toaddr=192.168.1.23
-------------------------------------------------------------------------------------------
--------------------------------------
Forward ports and servers
--------------------------------------
firewall-cmd --list-all
firewall-cmd --zone=external --add-interface=eth0
firewall-cmd --zone=external --add-service=ssh --permanent 
firewall-cmd --zone=external --query-masquerade
firewall-cmd --zone=external --add-forward-port=port=3389:proto=tcp:toport=3389:toaddr=194.54.80.222 --permanent
firewall-cmd --zone=external --remove-forward-port=port=3389:proto=tcp:toport=3389:toaddr=194.54.80.222 --permanent
firewall-cmd --reload
firewall-cmd --zone=external --list-forward-ports
--------------------------------------
-------------------------------------------------------------------------------------------

firewall-cmd
-------------------------------------------------------------------------------------------
Постоянные параметры:

Постоянные параметры будут хранится в настройках и не исчезнут после перезагрузки.
Так же их изменение вступят в силу только после перезагрузки или перезапуска системы.(Ключевое слово тут --permanent) Можно использовать:

    --permanent { --get-zones | --get-services | --get-icmptypes }
    --permanent [--zone=<zone>] { --list-services | --list-ports | --list-icmp-blocks | --list-forward-ports }
    --permanent [--zone=<zone>] { --add-ACTION | --remove-ACTION | --query-ACTION }
    --permanent [--zone=<zone>] { --add-masquerade | --remove-masquerade |--query-masquerade }

Результат такой же как и при использовании временных параметров, только постоянный. :)
-------------------------------------------------------------------------------------------
Проверка статуса:
    --state — Проверяет активен ли демон firewalld.
-------------------------------------------------------------------------------------------
Перезагрузка:
    --reload - Перезагружает правила межсетевого экрана с сохранением информации о состоянии.
    --complete-reload — Полностью перезагружает межсетевой экран, в том числе перезагружает
модули ядра (netfilter). Все соединения будут сброшены и временные правила потеряны.
-------------------------------------------------------------------------------------------
Паника (внештатный режим):
    --panic-on — Включае режим паники. Все входящие и исходящие пакеты без исключения
отбрасываются, все соединения со временем разрываются.
    --panic-off — Отключить режим паники. Брэндмауер начинает работать в штатном режиме,
некоторые соединения могут быть восстановлены, если режим паники длился меньше время окончания для этих соединений.
    --query-panic — Возвращает 0 если режим паники включен и 1 если выключен.
-------------------------------------------------------------------------------------------
Опции обработки зон:

    --get-default-zone — Возвращает зону по умолчанию для соединений и интерфейсов.
    --set-default-zone=<zone> - Устанавливает зону по умолчанию для соединений и интерфейсов
(Для которых зона не была установлена). Это постоянные изменения.
    --get-zones — Возвращает предопределенных зон служб используя пробелы в качестве разделителя.
    --get-services — Возвращает список стандартных служб используя пробелы в качестве разделителя.
    --get-icmptypes - Возвращает список предопределенных типов ICMP используя пробелы в качестве
разделителя
    --get-active-zones — Возвращает список активных в настоящее время зон вместе с интерфейсами
в этих зонах в формате:
    <zone1>: <interface1> <interface2> ..
    <zone2>: <interface3> ..
    --get-zone-of-interface=<interface> - Возвращает зону которой пренадлежит интерфейс <interface>
или ничего, если интерфейсу не назначена зона.
    --list-all-zones — Возвращает список всех действий во всех зонах в формате:
    <zone>
    interfaces: <interface1> ..
    services: <service1> ..
    ports: <port1> ..
    forward-ports: <forward port1> ..
    icmp-blocks: <icmp type1> ..

-------------------------------------------------------------------------------------------
Опции обработки интерфейсов:

Эти опции относятся только к одной конкретной зоне. Если используется --zone=<zone>, то они влияют
на зону <zone>. Если нет, то опции влияют на зону «по умолчанию» (смотрите --get-default-zone).

[--zone=<zone>] --list-interfaces — Возвращает список интерфейсов которые пренадлежат к зоне <zone>.
Если параметра нет, то используется зона «по умолчанию». 
[--zone=<zone>] --add-interface=<interface> - Добавляет интерфейс <interface> в зону <zone>.

[--zone=<zone>] { --change-interface=<interface> | --change --zone=<interface> } - Изменить
зону интерфейса <interface> принадлежащего зоне <zone>.
Если старая и новая зона совпадают то команда ничего не делает и не возвращает ошибки. Если
интерфейс не принадлежал ранее к этой зоне то он будет в неё добавлен, как при использовании параметра --add-interface.

[--zone=<zone>]--query-interface=<interface> - Возвращает 0 если интерфейс <interface>
принадлежит к зоне <zone> и 1 если не пренадлежит.

[--zone=<zone>]--remove-interface=<interface> - Удаляет интерфейс<interface> из зоны <zone>.


-------------------------------------------------------------------------------------------
Опции настройки и запроса зон:

Чтобы использовать эти параметры следует знать какие действия и когда можно использовать.
Об этом написано ниже.

    [--zone=<zone>] --add-ACTION [--timeout=<seconds>] - Добавить действие ACTION для зоны <zone>.
Эта опция может быть указана несколько раз. Чтобы получить зону по умолчанию используется
--get-default-zone. Если указан тайм-аут то действие ACTION будет активно указанное количество
секунд и затем удалено.

    [--zone=<zone>] --remove-ACTION - Удалить действие ACTION из зоны <zone>. Эта опция может
быть указан несколько раз. Если действие было добавлено с указанием тайм-аута, оно всё равно будет удалено.

    [--zone=<zone>] --query-ACTION — Возвращает 0 если действие ACTION было добавлено для зоны
<zone> и 1 в противном случае.

    [--zone=<zone>] --add-masquerade [--timeout=<seconds>] - Включить маскарад для зоны <zone>.
Если указан тайм-аут, маскарадинг будет активным в течение указанного количества секунд.

    [--zone=<zone>] --remove-masquerade - Отключить маскарад для зоны <zone>. Если маскарадинг
был включен с тайм-аут, он всё равно будет отключен.

    [--zone=<zone>] --query-masquerade — Возвращает 0 если маскарадинг включен для зоны <zone>
и 1 в противном случае.

    [--zone=<zone>] --list-services — Возвращает список сервисов добавлены в зону <zone>
разделенный пробелами. Чтобы получить список всех предустановленных сервисов используйте --get-services.

    [--zone=<zone>] --list-ports— Возвращает список портов добавленных в зону <zone> разделённый
пробелами. Списрок имеет формат: <port>[-<port>]/<protocol>, где в качестве порта может быть указан диапазон портов.

    [--zone=<zone>]--list-icmp-blocks - Список типов ICMP пакетов добавлнных в зону <zone>
разделенный пробелами. Для получения списка всех предопределенных типов ICMP используйте --get-icmptypes.

    [--zone=<zone>] --list-forward-ports — Возвращает список всех «проброшенных» портов
добавленных в зону <zone>.
    [--zone=<zone>] --list-all - Возвращает список всех действий добавленных или включенных в зону <zone>.

-------------------------------------------------------------------------------------------
Эти действия (ACTION) используются в --add-ACTION, --remove-ACTION и --query-ACTION предыдущего раздела.

    service=<service> - Использовать одну из стандартных служб. Для получения списка всех
стандартных служб используйте --get-services.

    port=<port>[-<port>]/<protocol> - Использовать порт <port> или диапазон портов <port>-<port>
для работы протоколы. Порт - это номер порта от 1 до 65535. Протокол может быть TCP или UDP.

    icmp-block=<icmptype> - .Использовать предопределенные типы ICMP пакетов. Для получения
списка всех предопределенных типов ICMP используйте --get-icmptypes.

    forward-port=port=<port>[-<port>]:proto=<protocol>:toport=<port>[-<port>] - Использовать
порт при переадресации пакетов. Указываются исходный и целевой порты или диапазоны портов для
протокола. Протоколом может быть UDP или TCP. Проброс осуществляется с локального порта port
на локальный toport.

    forward-port=port=<port>[-<port>]:proto=<protocol>:toaddr=<address> - Проброс локального
порта port в тот же порт на хосте toaddr.

    forward-port=port=<port>[-<port>]:proto=<protocol>:toport=<port>[-<port>]:toaddr=<address>
- Проброс локального порта port в порт toport на хосте toaddr.

Ещё опции:

-------------------------------------------------------------------------------------------
Эти опции служат для управления правилами на более низком уровне.

    --direct--passthrough { ipv4 | ipv6 | eb } <args> - Передача команд через фаервол.
Аргументом <args> могут быть любые агрументы командной строки допрустимые в
iptables, ip6tables и ebtables.

    --direct--add-chain { ipv4 | ipv6 | eb } <table> <chain> - Добавить новую цепочку <chain>
в таблицу <table>.

    --direct--remove-chain { ipv4 | ipv6 | eb } <table> <chain> - Удалить цепочку <chain> из
таблицы <table>.

    --direct--query-chain { ipv4 | ipv6 | eb } <table> <chain> - Возвращает 0 если цепочка с
именем <chain> присутствует в таблице <table> и 1 в противном случае.

    --direct--get-chains { ipv4 | ipv6 | eb } <table> - Возвращает все цепочки содержащиеся в
таблице <table> в виде списка разделенного пробелами.

    --direct--add-rule { ipv4 | ipv6 | eb } <table> <chain> <priority> <args> - Добавить правило
<args> в цепочку <chain> таблицы <table>.Приоритет используется для задания позиции правила в цепи.
Правило с приоритетом 0 добавляется на самый верх цепи. Чем больше приоритет, тем ниже правило
расположено в цепочке. Порядок расположения правил с одинаковым приоритетом может менятся и
поэтому не предсказуем. Не стоит назначать одинаковый приоритет правилам.

    --direct--remove-rule { ipv4 | ipv6 | eb } <table> <chain> <args> -Удалить правило <args>
из цепочки <chain> в таблице <table>.

    --direct--query-rule { ipv4 | ipv6 | eb } <table> <chain> <args> - Возвращает 0 если правило
<args> существует в цепочке <chain> таблицы <table> и 1 в противном случае.

    --direct--get-rules { ipv4 | ipv6 | eb } <table> <chain> - Возвращает все правила цепочки
<chain> в таблице <table> в виде строк.
-------------------------------------------------------------------------------------------
ПРИМЕРЫ --direct--add-rule
-----------------------------------------------------------------------------
To allow our dmz (enp0s17) network VMs with private IP addresses to communicate
with external networks, we have to configure firewall for IP masquerading:
# firewall-cmd --permanent --direct --add-rule ipv4 nat POSTROUTING 0 -o enp0s8 -j MASQUERADE

Forward all ICMP requests from the zone dmz (enp0s17) to the zone public (enp0s8):
# firewall-cmd --permanent --direct --add-rule ipv4 filter FORWARD 0 -i enp0s17 -o enp0s8 \
  -p icmp -m state --state NEW,RELATED,ESTABLISHED -j ACCEPT

Do the same for all HTTP and HTTPS traffic:
# firewall-cmd --permanent --direct --add-rule ipv4 filter FORWARD 0 -i enp0s17 -o enp0s8 \
  -p tcp -m multiport --dport 80,443 -m state --state NEW,RELATED,ESTABLISHED -j ACCEPT

Also allow access to public SMTP and SMTPS servers:
# firewall-cmd --permanent --direct --add-rule ipv4 filter FORWARD 0 -i enp0s17 -o enp0s8 \
  -p tcp -m multiport --dport 25,465 -m state --state NEW,RELATED,ESTABLISHED -j ACCEPT

Allow to SSH into public servers:
# firewall-cmd --permanent --direct --add-rule ipv4 filter FORWARD 0 -i enp0s17 -o enp0s8 \
  -p tcp --dport 22 -m state --state NEW,RELATED,ESTABLISHED -j ACCEPT

Log everything else:
# firewall-cmd --permanent --direct --add-rule ipv4 filter FORWARD 0 -i enp0s17 -o enp0s8 \
  -j LOG --log-prefix "forward_fw "

Optional, but not really required:
# firewall-cmd --permanent --direct --add-rule ipv4 filter FORWARD 0 -i enp0s17 -o enp0s8 -j REJECT

Reload:
# firewall-cmd --reload
-----------------------------------------------------------------------------
Check the direct rules:
# firewall-cmd --direct --get-all-rules
ipv4 nat POSTROUTING 0 -o enp0s8 -j MASQUERADE
ipv4 filter FORWARD 0 -i enp0s17 -o enp0s8 -p icmp -m state --state NEW,RELATED,ESTABLISHED -j ACCEPT
ipv4 filter FORWARD 0 -i enp0s17 -o enp0s8 -p tcp -m multiport --dport 80,443 -m state --state NEW,RELATED,ESTABLISHED -j ACCEPT
ipv4 filter FORWARD 0 -i enp0s17 -o enp0s8 -p tcp -m multiport --dport 25,465 -m state --state NEW,RELATED,ESTABLISHED -j ACCEPT
ipv4 filter FORWARD 0 -i enp0s17 -o enp0s8 -p tcp --dport 22 -m state --state NEW,RELATED,ESTABLISHED -j ACCEPT
ipv4 filter FORWARD 0 -i enp0s17 -o enp0s8 -j LOG --log-prefix 'forward_fw '
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
iptables
-----------------------------------------------------------------------------
CentOS7
-----------------------------------------------------------------------------
# systemctl stop firewalld
# systemctl disable firewalld
-----------------------------------------------------------------------------
# iptables -L -v -n
# iptables –list
# iptables -L --line-numbers
# iptables -S
# iptables -L INPUT -v -n
-----------------------------------------------------------------------------
# yum -y install iptables-services
# systemctl enable iptables.service
# systemctl start iptables.service
# mcedit /etc/iptables.sh
# chmod 0740 /etc/iptables.sh
# /etc/sysconfig/iptables
-----------------------------------------------------------------------------
Добавление правил
-----------------------------------------------------------------------------
ВНИМАНИЕ: применять правила нужно лишь в том случае, если у вас
имеется доступ к консоли сервера. При ошибке в настройках вы можете потерять
доступ. Убедитесь, что в нештатной ситуации вы сможете отключить фаервол и
скорректировать настройки. 
-----------------------------------------------------------------------------
РЕШЕНИЕ: 
1.shutdown -r 10-15минут
2. Команду iptables -A ... 
3. ssh user@host -p 22
Если доступ есть, тогда
4. shutdown -c
5. /sbin/iptables-save > /etc/sysconfig/iptables

-----------------------------------------------------------------------------
Сохранение введенных правил при перезагрузке
-----------------------------------------------------------------------------
# iptables-save		сохраняют создают дамп правил netfilter из ядра на
			стандартный вывод
# iptables-restore	восстанавливают в ядро правила со стандартного ввода 
-----------------------------------------------------------------------------
RedHat
-----------------------------------------------------------------------------
хранения команд iptables выполняемых при старте и останове сети выполняет файл
/etc/sysconfig/iptables. Управление данным файлом лежит на iptables.

Вариант 2 сохранения правил, можно рассмотреть использование параметра up в
файле /etc/network/interfaces с аргументом в виде файла, хранящего команды iptables.
-----------------------------------------------------------------------------
Debian
-----------------------------------------------------------------------------
/etc/network/if-up.d/
/etc/network/if-up.d/iptables-rules
можно поместить скрипты, которые будут запускаться при старте сети.
# chmod +x /etc/network/if-up.d/iptables-rules
# /etc/network/if-up.d/iptables-rules
-----------------------------------------------------------------------------
Итак, алгоритм сохранения iptables примерно следующий:
-----------------------------------------------------------------------------
   - Настраиваем сетевой экран под свои нужны с помощью команды iptables
   - создаем дамп созданный правил с помощью команды
# iptables-save > /etc/iptables.rules
   - создаем скрипт импорта созданного дампа при старте сети
(в каталоге /etc/network/if-up.d/)    - и не забываем его сделать исполняемым:
-----------------------------------------------------------------------------
# cat /etc/network/if-up.d/firewall
#!/bin/bash
/sbin/iptables-restore < /etc/iptables.rules
exit 0
# chmod +x /etc/network/if-up.d/firewall
-----------------------------------------------------------------------------
Дамп правил, полученный командой iptables-save имеет текстовый формат,
соответственно пригоден для редактирования. Синтаксис вывода команды iptables-save следующий:
-----------------------------------------------------------------------------
# Generated by iptables-save v1.4.5 on Sat Dec 24 22:35:13 2011
*filter
:INPUT ACCEPT [0:0] 
:FORWARD ACCEPT [0:0]
.......
# комментарий
-A INPUT -i lo -j ACCEPT
-A INPUT ! -i lo -d 127.0.0.0/8 -j REJECT
...........
-A FORWARD -j REJECT
COMMIT
# Completed on Sat Dec 24 22:35:13 2011
# Generated by iptables-save v1.4.5 on Sat Dec 24 22:35:13 2011
*raw
......
COMMIT
-----------------------------------------------------------------------------
Строки, начинающиеся на # - комментарии, строки на * - это название таблиц,
между названием таблицы и словом COMMIT содержатся параметры, передаваемые команде iptables. Параметр COMMIT - указывает на завершение параметров для
вышеназванной таблицы. Строки, начинающиеся на двоеточие задают цепочки, в которых содержится данная таблица в формате:
-----------------------------------------------------------------------------
:цепочка политика [пакеты:байты]
-----------------------------------------------------------------------------
где цепочка - имя цепочки, политика - политика цепочки по-умолчанию для
данной таблицы, а далее счетчики пакетов и байтов на момент выполнения команды.
-----------------------------------------------------------------------------
Скрипт для загрузки правил
-----------------------------------------------------------------------------
# mcedit /etc/iptables.sh
# chmod 0740 /etc/iptables.sh
# /etc/iptables.sh
-----------------------------------------------------------------------------
#!/bin/bash
export IPT="iptables"
export WAN=eht0
export WAN_IP=85.31.203.127
export LAN1=eht1
export LAN1_IP_RANGE=10.1.3.0/24

# Перед применением новых правил, очищаем все цепочки:
$IPT -F
$IPT -F -t nat 
$IPT -F -t mangle 
$IPT -X
$IPT -t nat -X
$IPT -t mangle -X

# Блокируем весь трафик, который не соответствует ни одному из правил:
$IPT -P INPUT DROP
$IPT -P OUTPUT DROP
$IPT -P FORWARD DROP

# Разрешаем весь трафик локалхоста и локалки:
$IPT -A INPUT -i lo -j ACCEPT
$IPT -A INPUT -i $LAN1 -j ACCEPT
$IPT -A OUTPUT -o lo -j ACCEPT
$IPT -A OUTPUT -o $LAN1 -j ACCEPT

######
#ICMP
######

# Разрешаем делать ping:
$IPT -A INPUT -p icmp --icmp-type echo-reply -j ACCEPT
$IPT -A INPUT -p icmp --icmp-type destination-unreachable -j ACCEPT
$IPT -A INPUT -p icmp --icmp-type time-exceeded  -j ACCEPT
$IPT -A INPUT -p icmp --icmp-type echo-request -j ACCEPT

# Открываем доступ в инет самому серверу:
$IPT -A OUTPUT -o $WAN -j ACCEPT

# Разрешим все установленные соединения и дочерние от них:
$IPT -A INPUT -p all -m state --state RELATED,ESTABLISHED -j ACCEPT
$IPT -A OUTPUT -p all -m state --state NEW,RELATED,ESTABLISHED -j ACCEPT
$IPT -A FORWARD -p all -m state --state RELATED,ESTABLISHED -j ACCEPT

##########
#SECURITY
##########

# Теперь добавим защиту от наиболее распространенных сетевых атак.
# Сначала отбросим все пакеты, которые не имеют никакого статуса:
$IPT -A INPUT -m state --state INVALID -j DROP
$IPT -A FORWARD -m state --state INVALID -j DROP

# Блокируем нулевые пакеты:
$IPT -A INPUT -p tcp --tcp-flags ALL NONE -j DROP

# Закрываемся от syn-flood атак:
$IPT -A INPUT -p tcp ! --syn -m state --state NEW -j DROP
$IPT -A OUTPUT -p tcp ! --syn -m state --state NEW -j DROP

# запрет доступа с определенных IP
$IPT -A INPUT -s 84.122.21.197 -j REJECT

##########
#INTERNET
##########

# Разрешаем всем выход в интернет:
$IPT -A FORWARD -i $LAN1 -o $WAN -j ACCEPT

# Запрещаем доступ из инета в локальную сеть:
$IPT -A FORWARD -i $LAN1 -o $WAN -j REJECT

#####
#NAT
#####
############
#MASQUERADE
############

# Включаем nat:
$IPT -t nat -A POSTROUTING -o $WAN -s $LAN1_IP_RANGE -j MASQUERADE
#или

######
#SNAT
######

#------------------------------------------------------------------
#Включить транзитный трафик 
#/etc/sysctl.conf раз коментировать строчку net.ipv4.ip_forward=1

# Разрешаем ходить транзитным пакетам через firewall для нашего
# диапазона ip адресов, а всё # остальное запрещаем.
$IPT -A FORWARD -i $LAN1 -o $WAN -s $LAN1_IP_RANGE -j ACCEPT
$IPT -A FORWARD -i $WAN -o $LAN1 -d $LAN1_IP_RANGE -j ACCEPT
#------------------------------------------------------------------
$IPT -A FORWARD -i $WAN -d $LAN1_IP_RANGE -p tcp -m tcp --dport 11111 -j ACCEPT
#------------------------------------------------------------------
#Если вы пробрасываете порт снаружи внутрь локальной сети, то
#обязательно закомментируйте правило, которое блокирует доступ из
#внешней сети во внутреннюю. В моем примере это правило:
#------------------------------------------------------------------
$IPT -A FORWARD -i $WAN -o $LAN1 -j REJECT
#Перед этим правилом создано разрешающее правило для доступа 
#снаружи к внутреннему сервису 11111
#------------------------------------------------------------------
#Правило Перенаправления c 11111 на порт 3389 в раздере DNAT
#------------------------------------------------------------------
$IPT -P FORWARD DROP

# Теперь сам SNAT:
$IPT -A POSTROUTING -s $LAN1_IP_RANGE -o $WAN -j SNAT --to-source $WAN_IP

#Этого достаточно для того что бы у вас заработал NAT.
#------------------------------------------------------------------

######
#DNAT
######
#Перенаправление пакетов, адресованных одному хосту, на другой хост
$IPT -t nat -A PREROUTING -d $WAN -p tcp -m tcp --dport 25 -j DNAT —to-destination 10.1.3.2:25

#Port Forwarding соединения на 80 порт шлюза на внутренний WEB сервер:
$IPT -A PREROUTING -t nat -i $WAN -p tcp --dport 80 -j DNAT --to 10.1.3.3:8080
$IPT -A FORWARD -p tcp -d 10.1.3.3 --dport 8080 -j ACCEPT

# переадресовывать все пакеты приходящие на шлюз из интернет на порт
# TCP 3389(именно его использует RDP протокол)аца ваш внутренний Windows Server.
$IPT -A PREROUTING -i $WAN -p tcp -m tcp --dport 11111 -j DNAT --to-destination 10.1.3.4:3389

#####
#SSH
#####

# Разрешаем подключения по ssh:
$IPT -A	 INPUT -i $WAN -p tcp --destination-port 22 -j ACCEPT

#######
#INPUT
#######
$IPT -A INPUT -m state --state NEW -m tcp -p tcp --dport 21 -j ACCEPT
$IPT -A INPUT -p tcp -m tcp  -–dport 80 -j ACCEPT
$IPT -A INPUT -p tcp -m udp  -–dport 53 -j ACCEPT
$IPT -A INPUT -p tcp -m tcp  -–dport 53 -j ACCEPT

#####
#LOG
#####
#------------------------------------------------------------------
# все заблокированные пакеты в отдельные цепочки (block_in, block_out, block_fw)
# Добавляем следующие правила в самый конец скрипта, перед сохранением настроек:

#$IPT -N block_in
#$IPT -N block_out
#$IPT -N block_fw

#$IPT -A INPUT -j block_in
#$IPT -A OUTPUT -j block_out
#$IPT -A FORWARD -j block_fw

#$IPT -A block_in -j LOG --log-level info --log-prefix "--IN--BLOCK"
#$IPT -A block_in -j DROP
#$IPT -A block_out -j LOG --log-level info --log-prefix "--OUT--BLOCK"
#$IPT -A block_out -j DROP
#$IPT -A block_fw -j LOG --log-level info --log-prefix "--FW--BLOCK"
#$IPT -A block_fw -j DROP

# Все заблокированные пакеты вы сможете отследить в файле /var/log/messages.
#После того, как закончите настройку, закомментируйте эти строки, отключив логирование.
#------------------------------------------------------------------

######
#SAVE
######

# Записываем правила, чтобы они применились после перезагрузки:
/sbin/iptables-save > /etc/sysconfig/iptables

-----------------------------------------------------------------------------
Цепочки netfilter:
-----------------------------------------------------------------------------
    PREROUTING — для изначальной обработки входящих пакетов
    INPUT — для входящих пакетов, адресованных непосредственно локальному компьютеру
    FORWARD — для проходящих (маршрутизируемых) пакетов
    OUTPUT — для пакетов, создаваемых локальным компьютером (исходящих)
    POSTROUTING— для окончательной обработки исходящих пакетов
    Также можно создавать и уничтожать собственные цепочки при помощи утилиты iptables.
-----------------------------------------------------------------------------
Принцип действия
-----------------------------------------------------------------------------
Interface – > Ядро – > Таблицы – > Цепочки - > Правила -> Приложение или Сеть/Компьютер
-----------------------------------------------------------------------------
Примеры прохождения цепочек
-----------------------------------------------------------------------------
Последовательность обработки входящего пакета, предназначенного для локального
процесса:
-----------------------------------------------------------------------------
    Просматривается цепочка PREROUTING
        Просматривается таблица raw
        Просматривается  таблица mangle, далее происходит отслеживание соединений
        Просматривается таблица nat (используется для DNAT - модификация адреса получателя)
    маршрутизация: если пакет надо маршрутизовать мимо локального хоста, то
переходим к обработке проходящего пакета, если для он предназначен локальному хосту, то обрабатывается как локальный
    Просматривается цепочка INPUT 
        Просматривается таблица mangle
        Просматривается таблица filter
-----------------------------------------------------------------------------
Последовательность обработки пакета, уходящего с нашего хоста:
-----------------------------------------------------------------------------
    Маршрутизация: определение исходящего адреса, адреса назначения, используемого
интерфейса; если пакет маршрутизируется внутрь (для локального хоста), то переходим к предыдущей процедуре
    Просматривается цепочка OUTPUT
        Просматривается таблица raw
        Просматривается таблица mangle, фильтровать здесь не стоит, здесь же
происходит отслеживание локально создаваемых соединений
        Просматривается таблица nat (NAT для локально сгенерированных пакетов)
        Просматривается таблица filter
    Повторная маршрутизация, т.к. в таблицах mangle и nat пакет мог быть изменён;
если пакет маршрутизируется внутрь (для локального хоста), то переходим к предыдущей процедуре
    Просматривается цепочка POSTROUTING 
        Просматривается таблица mangle
        Просматривается таблица nat (используется для SNAT - модификация адреса
источника, фильтровать здесь не стоит)
-----------------------------------------------------------------------------
Последовательность обработки проходящего пакета (начинается от п.2 первой процедуры):
-----------------------------------------------------------------------------
    Просматривается цепочка FORWARD
        Просматривается таблица mangle
        Просматривается таблица filter
    повторная маршрутизация, т.к. в таблице mangle пакет мог быть изменён;
если пакет маршрутизируется внутрь (для локального хоста), то переходим к первой процедуре
    Просматривается цепочка POSTROUTING
        Просматривается таблица mangle
        Просматривается таблица nat (используется для SNAT и Masquerading,
фильтровать здесь не стоит)

Как видно, таблица nat и mangle может модифицировать получателя или отправителя
сетевого пакета. Именно поэтому сетевой пакет несколько раз сверяется с таблицей маршрутизации.
-----------------------------------------------------------------------------
Механизм определения состояний (conntrack)
-----------------------------------------------------------------------------
Выше в тексте несколько раз указывалось понятие "определение состояний",
оно заслуживает отдельной темы для обсуждения, но тем не менее я кратко затрону
данный вопрос в текущем посте. В общем, механизм определения состояний
(он же state machine, он же connection tracking, он же conntrack) является
частью пакетного фильтра и позволяет определить определить к какому соединению/сеансу
принадлежит пакет. Conntrack анализирует состояние всех пакетов, кроме тех,
которые помечены как NOTRACK в таблице raw. На основе этого состояния
определяется принадлежит пакет новому соединению (состояние NEW), уже
установленному соединению (состояние ESTABLISHED), дополнительному к уже существующему
(RELATED), либо к "другому" (неопределяемому) соединению (состояние INVALID).
Состояние пакета определяется на основе анализа заголовков передаваемого
TCP-пакета. Модуль conntrack позволяет реализовать межсетевой экран сеансового
уровня (пятого уровня модели OSI). Для управления данным механизмом используется
утилита conntrack, а так же параметр утилиты iptables: -m conntrack или
-m state (устарел). Состояния текущих соединений conntrack хранит в ядре. Их можно
просмотреть в файле /proc/net/nf_conntrack (или /proc/net/ip_conntrack).
-----------------------------------------------------------------------------
iptables [-t table] command [match] [target/jump]
iptables [-t таблица] команда [критерии] [действие]

Все параметры в квадратных скобках - необязательны.
-----------------------------------------------------------------------------
Таблицы
-----------------------------------------------------------------------------
        filter:
          This is the default table (if no -t option is passed).		
		chains:
		INPUT
		FORWARD
		OUTPUT
        nat:
	  трансляции сетевых адресов
            	PREROUTING
		OUTPUT
		POSTROUTING
	  Действия
		DNAT – преобразование адреса назначения в заголовке пакета
		SNAT – изменение исходного адреса пакета
		MASQUERADE – тоже, что и SNAT, но позволяет работать с
        mangle:
	  маркировка пакетов, изменение заголовков пакетов
            	PREROUTING
		OUTPUT
		INPUT
		FORWARD
		POSTROUTING
	  Действия
		TOS – type of Service
		TTL – установка поля
		MARK – метка на пакет
        raw:
	  пакет проходит данную таблицу до передачи системе определения состояний.
Используется редко, например для маркировки пакетов, которые НЕ должны 
		обрабатываться системой определения состояний. Для этого в правиле
		указывается действие NOTRACK. Содержитcя в цепочках PREROUTING и OUTPUT.
            	PREROUTING
		OUTPUT
        security:
          This table is used for Mandatory Access Control (MAC) AND implemented by Linux 			
		Security Modules such as SELinux. The security table is called after the			
		filter table, allowing any Discretionary Access Control (DAC) rules in the
		filter table to take effect before MAC rules. 
		chains:
		INPUT
		OUTPUT
		FORWARD


-----------------------------------------------------------------------------
Параметр	Описание 		Пример
-----------------------------------------------------------------------------
Команды
-----------------------------------------------------------------------------
--append (-A) 	Добавить в указанную цепочку и указанную таблицу заданное
правило в КОНЕЦ списка. 	
# iptables -A FORWARD критерии -j действие

--delete (-D) 	Удаляет заданное номером(ами) или правилом(ами) правило(а).
Первый пример удаляет все правила с номерами 10,12 во всех цепочках,
в таблицах filter, второй пример удаляет заданное правило из таблицы mangle
в цепочке PREROUTING. 
# iptables -D 10,12
# iptables -t mangle -D PREROUTING критерии -j действие

--rename-chain (-E) 	Изменить имя цепочки.
# iptables -E OLD_CHAIN NEW_CHAIN

--flush (-F) 	Очистка всех правил текущей таблицы. Ко всем пакетам, которые
относятся к уже установленным соединениям, применяем терминальное действие ACCEPT — пропустить
# iptables -F

--insert (-I) 	Вставляет заданное правило в место, заданное номером.
# iptables -I FORWARD 5 критерии -j действие

--list (сокр. -L) 	Просмотр существующих правил (без явного указания
таблицы - отображается таблица filter всех цепочек).
# iptables -L

--policy (-P) 	Устанавливает стандартную политику для заданной цепочки.
# iptables -t mangle -P PREROUTING DROP

--replace (-R) 	Заменяет заданное номером правило на заданное в критериях.
# iptables -R POSROUTING 7 | критерии -j действие

--delete-chain (-X) 	Удалить ВСЕ созданные вручную цепочки (оставить
только стандартные INPUT, OUTPUT, FORWARD, PREROUTING и POSTROUTING).
# iptables -X

--zero (-Z) 	Обнуляет счетчики переданных данных в цепочке.
# iptables -Z INPUT
-----------------------------------------------------------------------------
Параметры
-----------------------------------------------------------------------------
--numeric (-n) 	Не резолвит адреса и протоколы при выводе. 	

--line-numbers 	Указывать номера правил при выводе (может использоваться
совместно с -L). 	# iptables -L --line-numbers

--help (-h) 	куда же без нее :) 	

-t таблица 	Задает название таблицы, над которой необходимо совершить действие.
В примере сбрасывается таблица nat во всех цепочках.
# iptables -t nat -F

--verbose (-v) 	Детальный вывод.
# iptables -L -v
-----------------------------------------------------------------------------
Критерии (параметры) отбора сетевых пакетов команды iptables
-----------------------------------------------------------------------------
Критерии отбора сетевых пакетов негласно делятся на несколько групп: Общие
критерии, Неявные критерии, Явные критерии. Общие критерии допустимо употреблять
в любых правилах, они не зависят от типа протокола и не требуют подгрузки модулей
расширения. Неявные критерии (я бы из назвал необщие),  те критерии, которые
подгружаются неявно и становятся доступны, например при указании общего критерия
--protocol tcp|udp|icmp. Перед использованием Явных критериев, необходимо
подключить дополнительное расширение (это своеобразные плагины для netfilter).
Дополнительные расширения подгружаются с помощью параметра -m или --match. Так,
например, если мы собираемся использовать критерии state, то мы должны явно
указать это в строке правила: -m state левее используемого критерия. Отличие
между явными и неявными необщими критериями заключается в том, что явные нужно
подгружать явно, а неявные подгружаются автоматически.
-----------------------------------------------------------------------------
Во всех критериях можно использовать знак ! перед значением критерия. Это будет
означать, что под данное правило подпадают все пакеты, которые не соответствуют
данному параметру. Например: критерий --protocol ! tcp будет обозначать, что
все пакеты, которые не являются TCP-протоколом подходят под действие правила.
Однако последние версии iptables (в частности, 1.4.3.2 и выше), уже не
поддерживают этот синтаксис и требуют использования не --protocol ! tcp, а
! --protocol tcp,  выдавая следующую ошибку:
-----------------------------------------------------------------------------
Using intrapositioned negation (`--option ! this`) is deprecated in favor of
extrapositioned (`! --option this`).
-----------------------------------------------------------------------------
Ниже в виде таблицы приведены часто используемые параметры отбора пакетов:
-----------------------------------------------------------------------------
Параметр 	Описание 	Пример
-----------------------------------------------------------------------------
Общие параметры
-----------------------------------------------------------------------------
--protocol
(сокр. -p) 	Определяет протокол транспортного уровня. Опции tcp, udp,
icmp, all или любой другой протокол определенный в /etc/protocols 	
# iptables -A INPUT -p tcp

--source
(-s, --src) 	IP адрес источника пакета. Может быть определен несколькими путями:

    Одиночный хост: host.domain.tld, или IP адрес: 10.10.10.3
    Пул-адресов (подсеть): 10.10.10.3/24 или 10.10.10.3/255.255.255.0

Настойчиво не рекомендуется использовать доменные имена, для разрешения
(резольва) которых требуются DNS-запросы, так как на этапе конфигурирования
netfilter DNS может работать некорректно. Также, заметим, имена резольвятся
всего один раз — при добавлении правила в цепочку. Впоследствии соответствующий
этому имени IP-адрес может измениться, но на уже записанные правила это никак
не повлияет (в них останется старый адрес). Если указать доменное имя, которое
резольвится в несколько IP-адресов, то для каждого адреса будет добавлено
отдельное правило.
# iptables -A INPUT -s 10.10.10.3

--destination
(-d) 	IP адрес назначения пакета. Может быть определен несколькими путями
(см. --source). 	# iptables -A INPUT --destination 192.168.1.0/24

--in-interface
(-i) 	Определяет интерфейс, на который прибыл пакет. Полезно для NAT и
машин с несколькими сетевыми интерфейсами. Применяется в цепочках INPUT,
FORWARD и PREROUTING. Возможно использование знака "+", тогда подразумевается
использование всех интерфейсов, начинающихся на имя+ (например eth+ - все интерфейсы eth).
# iptables -t nat -A PREROUTING --in-interface eth0

--out-interface
(-o) 	Определяет интерфейс, с которого уйдет пакет. Полезно для NAT и машин
с несколькими сетевыми интерфейсами. Применяется в цепочках OUTPUT, FORWARD и POSTROUTING.
Возможно использование знака "+".
# iptables -t nat -A POSTROUTING --in-interface eth1
-----------------------------------------------------------------------------
Неявные (необщие) параметры
-----------------------------------------------------------------------------
-p proto -h 	вывод справки по неявным параметрам протокола proto.
# iptables -p icmp -h

--source-port
(--sport) 	Порт источник, возможно только для протоколов --protocol tcp, или --protocol udp
# iptables -A INPUT --protocol tcp --source-port 25

--destination-port
(--dport) 	Порт назначения, возможно только для протоколов --protocol tcp, или --protemocol udp 
# iptables -A INPUT --protocol udp --destination-port 67
-----------------------------------------------------------------------------
Явные параметры
-----------------------------------------------------------------------------
iptables can use extended packet matching modules
These are loaded in two ways: implicitly, when 
-p or --protocol is specified,
or with the 
-----------------------------------------------------------------------------
-m or --match options, followed by the matching module name;
-----------------------------------------------------------------------------
after these, various extra command line options become available, depending 
on the specific module. You can specify multiple extended match modules in one
line, and you can use the 
-----------------------------------------------------------------------------
-h or --help 
-----------------------------------------------------------------------------
options after the module has been specified to receive help specific to that module. 
-----------------------------------------------------------------------------
		-m or --match
-----------------------------------------------------------------------------
comment
-----------------------------------------------------------------------------
--comment comment
# iptables -A INPUT -s 192.168.0.0/16 -m comment --comment "A privatized IP block" 
-----------------------------------------------------------------------------
tcp
-----------------------------------------------------------------------------
These extensions are loaded if '--protocol tcp' is specified. It provides
the following options:
--source-port [!] port[:port]
--destination-port [!] port[:port]
--tcp-flags
# iptables -A FORWARD -p tcp --tcp-flags SYN,ACK,FIN,RST SYN
    will only match packets with the SYN flag set, and the ACK, FIN and RST flags unset. 
...
-----------------------------------------------------------------------------
conntrack
-----------------------------------------------------------------------------
--ctstate state

    Состояние соединения. Доступные опции:

    NEW (Все пакеты устанавливающие новое соединение)
    ESTABLISHED (Все пакеты, принадлежащие установленному соединению)
    RELATED (Пакеты, не принадлежащие установленному соединению, но связанные
с ним. Например - FTP в активном режиме использует разные соединения для передачи
данных. Эти соединения связаны.)
    INVALID (Пакеты, которые не могут быть по тем или иным причинам
идентифицированы. Например, ICMP ошибки не принадлежащие существующим соединениям)
    и др. (более подробно в документации)

# iptables -A INPUT -m state --state NEW,ESTABLISHED
# iptables -A INPUT -m conntrack --ctstate NEW,ESTABLISHED
-----------------------------------------------------------------------------
-m state --state (устарел)
он же
-m conntrack --ctstate 	
-----------------------------------------------------------------------------
mac
-----------------------------------------------------------------------------
--mac-source 	Задает MAC адрес сетевого узла, передавшего пакет. MAC
адрес должен указываться в форме XX:XX:XX:XX:XX:XX. 
# -m mac --mac-source 00:00:00:00:00:0
-----------------------------------------------------------------------------
Действия над пакетами
-----------------------------------------------------------------------------
Данный заголовок правильнее будет перефразировать в "Действия над пакетами,
которые совпали с критериями отбора". Итак, для совершения какого-либо действия
над пакетами, необходимо задать ключ -j (--jump) и указать, какое конкретно
действие совершить.
-----------------------------------------------------------------------------
Действия над пакетами могут принимать следующие значения:
-----------------------------------------------------------------------------
    ACCEPT - пакет покидает данную цепочку и передается в следующую (дословно - ПРИНЯТЬ).
    DROP - отбросить удовлетворяющий условию пакет, при этом пакет не передается в другие таблицы/цепочки.
    REJECT - отбросить пакет, отправив отправителю ICMP-сообщение, при этом пакет не передается в другие таблицы/цепочки.
    RETURN - возвратить пакет в предыдущую цепочку и продолжить ее прохождение начиная со следующего правила.
    SNAT - применить трансляцию адреса источника в пакете. Может использоваться только в цепочках POSTROUTING и OUTPUT в таблицах nat.
    DNAT - применить трансляцию адреса назначения в пакете. Может использоваться в цепочке PREROUTING в таблице nat. (в исключительных случаях - в цепочке OUTPUT)
    LOG - протоколировать пакет (отправляется демону syslog) и обработать остальными правилами.
    MASQUERADE — используется вместо SNAT при наличии соединения с динамическим IP (допускается указывать только в цепочке POSTROUTING таблицы nat).
    MARK — используется для установки меток на пакеты, передается для обработки дальнейшим правилам.
    и др.
-----------------------------------------------------------------------------
Кроме указанных действий, существуют и другие, с которыми можно ознакомиться в документации . У некоторых действий есть дополнительные параметры.
-----------------------------------------------------------------------------
В таблице ниже приведены примеры и описания дополнительных параметров:
-----------------------------------------------------------------------------
Параметр 	Описание 	Пример
-----------------------------------------------------------------------------
DNAT (Destination Network Address Translation)
-----------------------------------------------------------------------------
--to-destination 	указывает, какой IP адрес должен быть подставлен в
качестве адреса места назначения. В примере во всех пакетах протокола tcp,
пришедших на адрес 1.2.3.4, данный адрес будет заменен на 4.3.2.1.
# iptables -t nat -A PREROUTING -p tcp -d 1.2.3.4 -j DNAT --to-destination 4.3.2.1
-----------------------------------------------------------------------------
LOG
-----------------------------------------------------------------------------
--log-level 	Используется для задания уровня журналирования (log level).
В примере установлен максимальный уровень логирования для всех tcp пакетов в
таблице filter цепочки FORWARD.
# iptables -A FORWARD -p tcp -j LOG --log-level debug

--log-prefix 	Задает текст (префикс), которым будут предваряться все
сообщения iptables. (очень удобно для дальнейшего парсинга) Префикс может
содержать до 29 символов, включая и пробелы. В примере отправляются в syslog
все tcp пакеты в таблице filter цепочки INPUT с префиксом INRUT-filter.
# iptables -A INPUT -p tcp -j LOG --log-prefix "INRUT-filter"

--log-ip-options 	Позволяет заносить в системный журнал различные
сведения из заголовка IP пакета.
# iptables -A FORWARD -p tcp -j LOG --log-ip-options

-----------------------------------------------------------------------------
fail2ban
-----------------------------------------------------------------------------
http://www.fail2ban.org/wiki/index.php/MANUAL_0_8#Usage
-----------------------------------------------------------------------------
Сервис Fail2ban может смягчить угрозу повторяющиеся попытки входа – это атаки
brute force (атаки методом подбора пароля), при помощи правил, автоматически
меняющих настройки брандмауэра iptables; эти правила срабатывают в случае
поступления определённого количества неудачных попыток входа. Этот инструмент
позволяет защитить сервер от несанкционированного доступа без вмешательства
системного администратора.
-----------------------------------------------------------------------------
yum install epel-release
yum install fail2ban
systemctl enable fail2ban
systemctl start fail2ban
systemctl restart fail2ban
-----------------------------------------------------------------------------
/etc/fail2ban/
├── action.d
│   ├── dummy.conf
│   ├── hostsdeny.conf
│   ├── iptables.conf
│   ├── mail-whois.conf
│   ├── mail.conf
│   └── shorewall.conf
├── fail2ban.conf
├── fail2ban.local
├── filter.d
│   ├── apache-auth.conf
│   ├── apache-noscript.conf
│   ├── couriersmtp.conf
│   ├── postfix.conf
│   ├── proftpd.conf
│   ├── qmail.conf
│   ├── sasl.conf
│   ├── sshd.conf
│   └── vsftpd.conf
├── jail.conf
└── jail.local
-----------------------------------------------------------------------------
jail.conf - перезаписывается при обновлении пакета Fail2ban, потому его
	редактировать нельзя. Вместо этого нужно создать новый файл по имени
jail.local. Значения в файле jail.local будут переопределять jail.conf.
-----------------------------------------------------------------------------
Файл jail.conf содержит раздел [DEFAULT], после которого следует раздел для
индивидуальных сервисов. Файл jail.local может переопределить любое из этих 
значений. Файлы применяются в алфавитном порядке:
-----------------------------------------------------------------------------
    /etc/fail2ban/jail.conf
    /etc/fail2ban/jail.d/*.conf,
    /etc/fail2ban/jail.local
    /etc/fail2ban/jail.d/*.local,
-----------------------------------------------------------------------------
Любой из файлов может содержать раздел [DEFAULT], который выполняется первым,
а затем – разделы для индивидуальных сервисов. Последнее значение,
установленное для данного параметра, имеет приоритет.
-----------------------------------------------------------------------------
Базовая версия jail.local
-----------------------------------------------------------------------------
sudo nano /etc/fail2ban/jail.local
-----------------------------------------------------------------------------
[DEFAULT]
# Ban hosts for one hour:
bantime = 3600
# Override /etc/fail2ban/jail.d/00-firewalld.conf:
banaction = iptables-multiport
[sshd]
enabled = true
-----------------------------------------------------------------------------
Этот файл переопределяет три параметра:
устанавливает новое значение для	bantime		
настраивает поддержку			iptables	
и включает 				sshd.
-----------------------------------------------------------------------------
Сохраните и закройте файл. Перезапустите fail2ban при помощи systemctl:

sudo systemctl restart fail2ban
-----------------------------------------------------------------------------
Проверка

sudo fail2ban-client status
sudo fail2ban-client status sshd
-----------------------------------------------------------------------------
jail.local можно расширить при помощи других параметров настройки.
Откройте jail.conf и изучите его параметры. Чтобы изменить значение любого
из стандартных параметров, скопируйте его в jail.local и установите новое значение.
-----------------------------------------------------------------------------
Стандартные настройки
-----------------------------------------------------------------------------
ignoreip = 127.0.0.1/8	
задаёт белый список адресов. На данный момент он не блокирует исходящий трафик
локальной машины. Можно добавить дополнительные ip-адреса через пробел.
-----------------------------------------------------------------------------
bantime = 600

устанавливает интервал времени, в течение которого клиент будет заблокирован,
если он не смог пройти аутентификацию. Значение параметра измеряется в секундах;
по умолчанию установлено 600 секунд, или 10 минут.
-----------------------------------------------------------------------------
findtime = 600
maxretry = 3

Эти параметры задают условия, при которых клиент должен быть заблокирован.
findtime задаёт длительность интервала, в течение которого событие
должно повториться определённое количество раз, после чего клиент будет заблокирован;
maxretry устанавливает количество неудавшихся попыток входа. Согласно текущим
настройкам, Fail2ban заблокирует клиента после трех неудачных попыток логина,
случившихся в течение 10 минут.
-----------------------------------------------------------------------------
destemail = root@localhost
sendername = Fail2Ban
mta = sendmail

Чтобы настроить уведомления по электронной почте, нужно переопределить параметры
destemail, sendername и mta. Параметр destemail устанавливает адрес электронной
почты, на который нужно отправить сообщения. sendername  устанавливает имя
отправителя сообщения. Параметр mta задаёт почтовый сервис.
-----------------------------------------------------------------------------
action = $(action_)s

Этот параметр задаёт действие, которое выполнит Fail2ban в случае блокировки
 от вредоносного хоста, на интервал времени, установленный в параметре bantime.
-----------------------------------------------------------------------------
Если вы хотите настроить уведомления по электронной почте, нужно переопределить
action_  значением action_mw. Чтобы извещение содержало соответствующие строки
лог-файла, установите значение action_mwl.
-----------------------------------------------------------------------------
Примечание: Не забудьте настроить почту.
-----------------------------------------------------------------------------
Индивидуальные параметры
-----------------------------------------------------------------------------
[sshd]
port    = ssh
logpath = %(sshd_log)s

[ssh-iptables]
enabled  = true
filter   = sshd
action   = iptables[name=SSH, port=22, protocol=tcp]
           sendmail-whois[name=SSH, dest=root, sender=fail2ban@example.com, sendername="Fail2Ban"]
logpath  = /var/log/secure
maxretry = 3

[ssh-ddos]

enabled = true
port    = ssh,sftp
filter  = sshd-ddos
logpath  = /var/log/messages
maxretry = 2

# /var/log/secure
# /var/log/messages
[vsftpd-iptables]
enabled  = true
filter   = vsftpd
action   = iptables[name=VSFTPD, port=21, protocol=tcp]
           sendmail-whois[name=VSFTPD, dest=you@example.com]
logpath  = /var/log/vsftpd.log
maxretry = 5
bantime  = 1800
-----------------------------------------------------------------------------
/etc/fail2ban/filter.d/vsftpd.conf:
-----------------------------------------------------------------------------
# Fail2Ban filter for vsftp
#

[INCLUDES]

before = common.conf

[Definition]

__pam_re=\(?pam_unix(?:\(\S+\))?\)?:?
_daemon =  vsftpd

failregex = ^%(__prefix_line)s%(__pam_re)s\s+authentication failure; logname=\S* uid=\S* euid=\S* tty=(ftp)? ruser=\S* rhost=<HOST>(?:\s+user=.*)?\s*$
            ^ \[pid \d+\] \[.+\] FAIL LOGIN: Client "<HOST>"\s*$

ignoreregex = 

# Author: Cyril Jaquier
-----------------------------------------------------------------------------
/etc/vsftpd/vsftpd.conf
-----------------------------------------------------------------------------
dual_log_enable=YES
-----------------------------------------------------------------------------
ВНИМАНИЕ
fail2ban хочет видеть IP, а vsftpd ресолвит их в DNS-имена.
Здесь: www.fail2ban.org/wiki/index.php/FAQ_english внизу есть совет:

Scenario: VSFTP configuration is set for PAM authentication, using xferlog
in standard format. Fail2ban for vsftpd is watching /var/log/secure
Problem: PAM sends failed login information to /var/log/secure, but the
remote server's IP address has been replaced by a DNS name. Resulting DNS
name does not resolve or does not resolve correctly, thus fail2ban is
unable to ban the IP address.
Fix: Configure VSFTP for "dual_log_enable=YES", and have fail2ban watch
/var/log/vsftpd.log instead. This log file shows the incoming ip address
instead of the DNS name.
-----------------------------------------------------------------------------
В данном случае ssh – это предопределенная переменная для стандартного порта
SSH, а %(sshd_log)s использует значение, определённое в стандартных настройках
Fail2ban (таким образом jail.conf остаётся переносимым между различными
операционными системами).

Следующий параметр — filter — указывает, является ли строка в логе неудачной
попыткой аутентификации.

Значение filter – это ссылка на файл, который находится в каталоге
/etc/fail2ban/filter.d. Регулярные выражения данного файла позволяют определить,
является ли строка в логе вредоносной.
-----------------------------------------------------------------------------
Доступные фильтры можно просмотреть в каталоге:

ls /etc/fail2ban/filter.d
-----------------------------------------------------------------------------
Мониторинг логов Fail2ban и настроек брандмауэра
-----------------------------------------------------------------------------
sudo systemctl status fail2ban
sudo journalctl -b -u fail2ban
sudo fail2ban-client status
sudo fail2ban-client status jail_name
sudo tail -F /var/log/fail2ban.log
sudo iptables -L
sudo iptables -S
-----------------------------------------------------------------------------
Nginx с fail2ban
-----------------------------------------------------------------------------
sudo cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local
-----------------------------------------------------------------------------
[DEFAULT]
. . .
ignoreip = 127.0.0.1/8 your_home_IP
bantime = 3600
findtime = 3600   # эти параметры заблокируют пользователей
maxretry = 6      # которые не смогли предоставить учетные данные 6 раз в течение 30 минут
mta = mail
destemail = youraccount@email.com
sendername = Fail2BanAlerts
action = %(action_mwl)s	# оповещения по электронной почте с логами

# Чтобы включить поддержку мониторинга логов Nginx, нужно включить раздел [nginx-http-auth].

[nginx-http-auth]
enabled  = true
filter   = nginx-http-auth
port     = http,https
logpath  = /var/log/nginx/error.log
maxretry = 6

#  будет банить клиентов, которые ищут на веб-сайте уязвимые сценарии.
[nginx-noscript]
enabled  = true
port     = http,https
filter   = nginx-noscript
logpath  = /var/log/nginx/access.log
maxretry = 6

# может распознавать известные шаблоны запросов вредоносных ботов и блокировать их:
[nginx-badbots] 

[nginx-badbots]
enabled  = true
port     = http,https
filter   = nginx-badbots
logpath  = /var/log/nginx/access.log
maxretry = 2

# заблокировать пользователей, которые запрашивают веб-контенту в домашних
# каталогах пользователей, добавив раздел [nginx-nohome]:
[nginx-nohome]
enabled  = true
port     = http,https
filter   = nginx-nohome
logpath  = /var/log/nginx/access.log
maxretry = 2

#  блокировать клиентов, которые пытаются использовать Nginx как открытый прокси-сервер
[nginx-noproxy]
enabled  = true
port     = http,https
filter   = nginx-noproxy
logpath  = /var/log/nginx/access.log
maxretry = 2
-----------------------------------------------------------------------------
Настройка фильтров fail2ban
-----------------------------------------------------------------------------
/etc/fail2ban/filter.d
-----------------------------------------------------------------------------
sudo nano nginx-http-auth.conf
-----------------------------------------------------------------------------
[Definition]
failregex = ^ \[error\] \d+#\d+: \*\d+ user "\S+":? (password mismatch|was not found in ".*"), client: <HOST>, server: \S+, request: "\S+ \S+ HTTP/\d+\.\d+", host: "\S+"\s*$
^ \[error\] \d+#\d+: \*\d+ no user/password was provided for basic authentication, client: <HOST>, server: \S+, request: "\S+ \S+ HTTP/\d+\.\d+", host: "\S+"\s*$
ignoreregex =
-----------------------------------------------------------------------------
cp apache-badbots.conf nginx-badbots.conf
-----------------------------------------------------------------------------
sudo nano nginx-noscript.conf
-----------------------------------------------------------------------------
[Definition]
failregex = ^<HOST> -.*GET.*(\.php|\.asp|\.exe|\.pl|\.cgi|\.scgi)
ignoreregex =
-----------------------------------------------------------------------------
sudo nano nginx-nohome.conf
-----------------------------------------------------------------------------
[Definition]
failregex = ^<HOST> -.*GET .*/~.*
ignoreregex =
-----------------------------------------------------------------------------
sudo nano nginx-noproxy.conf
-----------------------------------------------------------------------------
[Definition]
failregex = ^<HOST> -.*GET http.*
ignoreregex =
-----------------------------------------------------------------------------
sudo service fail2ban restart
sudo fail2ban-client status
sudo iptables -S
sudo fail2ban-client status nginx-http-auth
-----------------------------------------------------------------------------
РАЗБЛОКИРУЙТЕ
свой IP вручную с помощью fail2ban-client.

sudo fail2ban-client set nginx-http-auth unbanip 111.111.111.111
-----------------------------------------------------------------------------
Apache с Fail2ban
-----------------------------------------------------------------------------
[DEFAULT]
. . .
ignoreip = 127.0.0.1/8 your_home_IP
bantime = 3600
findtime = 3600   # эти параметры заблокируют пользователей
maxretry = 6      # которые не смогли предоставить учетные данные 6 раз в течение 30 минут
mta = mail
destemail = youraccount@email.com
sendername = Fail2BanAlerts
action = %(action_mwl)s	# оповещения по электронной почте с логами

# Чтобы включить поддержку мониторинга логов Nginx, нужно включить раздел [nginx-http-auth].

[apache]
enabled  = true
filter   = apache-auth
port     = http,https
logpath  = /var/log/apache*/*error.log
maxretry = 3
findtime = 600

#  будет банить клиентов, которые ищут на веб-сайте уязвимые сценарии.
[apache-noscript]
enabled  = true
port     = http,https
filter   = nginx-noscript
logpath  = /var/log/nginx/access.log
maxretry = 6

# блокирует клиентов, которые запрашивают необычно длинные и подозрительные
# буфера и таким образом использовать уязвимость Apache. 
[apache-overflows]
enabled  = true
port     = http,https
filter   = apache-overflows
logpath  = /var/log/apache*/*error.log
maxretry = 2

# может распознавать известные шаблоны запросов вредоносных ботов и блокировать их:
[apache-badbots]
enabled  = true
port     = http,https
filter   = apache-badbots
logpath  = /var/log/apache*/*error.log
maxretry = 2


# заблокировать пользователей, которые запрашивают веб-контенту в домашних
# каталогах пользователей, добавив раздел:
[apache-nohome]
enabled  = true
port     = http,https
filter   = apache-nohome
logpath  = /var/log/apache*/*error.log
maxretry = 2

# блокирует попытки злоумышленников использовать определенное поведение PHP.
[php-url-fopen]
enabled = true
port    = http,https
filter  = php-url-fopen
logpath = /var/log/apache*/*access.log

-----------------------------------------------------------------------------
sudo service fail2ban restart
sudo fail2ban-client status
sudo iptables -S
sudo fail2ban-client status apache
-----------------------------------------------------------------------------
sudo fail2ban-client set apache unbanip 111.111.111.111
-----------------------------------------------------------------------------
nmap
-----------------------------------------------------------------------------
nmap host - просканировать порты на хосте host

    -p ports - просканировать указанные порты
    -o - определить ОС при сканировании порта

Увеличить Уровень Детализации результатов сканирования:

$ nmap -v server.shellhacks.com
$ nmap -vv server.shellhacks.com
-----------------------------------------------------------------------------
Сканировать Множество IP Адресов:

$ nmap 192.168.1.1 192.168.1.2 192.168.1.3
$ namp 192.168.1.1,2,3
-----------------------------------------------------------------------------
Сканировать Подсеть:

$ nmap 192.168.1.0/24
$ nmap 192.168.1.*
-----------------------------------------------------------------------------
Сканировать Диапазон IP Адресов (192.168.1.0 — 192.168.1.200):

$ nmap 192.168.1.0-200
-----------------------------------------------------------------------------
Поиск Активных Компьютеров в Сети
-----------------------------------------------------------------------------
Дельный Совет: Сканируйте сеть с помощью одной лишь команды ping! Вычислите все активные компьютеры:
$ echo 192.168.1.{1..254}|xargs -n1 -P0 ping -c1|grep "bytes from"
-----------------------------------------------------------------------------
Сканировать сеть в поиске Активных Хостов:
$ nmap -sn 192.168.1.0/24
-----------------------------------------------------------------------------
Обнаружение Компьютеров за Фаерволом
-----------------------------------------------------------------------------
Хосты, использующие сетевой экран (firewall), могут не отвечать на стандартные ICMP пинги.

Попробуйте следующие методы обнаружения подключенных хостов, если фаервол блокирует стандартные ICMP пинги:

# TCP SYN Пинг
$ nmap -sn -PS 192.168.1.0/24

# TCP ACK Пинг
$ nmap -sn -PA 192.168.1.0/24

# UDP Пинг
$ nmap -sn -PU 192.168.1.0/24

# Пинг по IP Протоколу
$ nmap -sn -PO 192.168.1.0/24

# ARP Пинг
$ nmap -sn -PR 192.168.1.0/24

Последние три команды должны выполняться с правами пользователя root.
-----------------------------------------------------------------------------
Сканирование Списка Хостов из Файла
-----------------------------------------------------------------------------
Сканирование списка хостов/сетей из Файла:

$ nmap -iL input.txt
-----------------------------------------------------------------------------
Формат файла:

# Записи могут быть представлены в любом из форматов, с которыми работает
# Nmap из командной строки (IP адреса, имена хостов, CIDR, IPv6, или октетные
# диапазоны). Записи должны разделятся одним или более пробелами, табуляциями
# или переходами на новую строку.

$ cat input.txt
server.shellhacks.com
192.168.1.0/24
192.168.2.1,2,3
192.168.3.0-200
-----------------------------------------------------------------------------
Исключение IP/Хостов/Сетей из Сканирования
-----------------------------------------------------------------------------
Исключить Цели из сканирования Nmap-ом:

$ nmap 192.168.1.0/24 --exclude 192.168.1.1
$ nmap 192.168.1.0/24 --exclude 192.168.1.1 192.168.1.5
$ nmap 192.168.1.0/24 --exclude 192.168.1.1,2,3

Исключить Список хостов, взятых из файла:

$ nmap 192.168.1.0/24 --excludefile exclude.txt
-----------------------------------------------------------------------------
Сканирование Определенных Портов
-----------------------------------------------------------------------------
Сканировать Один Порт:

$ nmap -p 80 192.168.1.1

Сканировать Несколько Портов:

$ nmap -p 80,443 192.168.1.1

Сканировать Диапазон Портов:

$ nmap -p 80-1000 192.168.1.1

Сканировать Все Порты:

$ nmap -p "*" 192.168.1.1

Сканировать несколько самых Распространенных Портов:

$ nmap --top-ports 5 192.168.1.1
$ nmap --top-ports 10 192.168.1.1
-----------------------------------------------------------------------------
Определение Поддерживаемых IP Протоколов
-----------------------------------------------------------------------------
Определить какие IP Протоколы (TCP, UDP, ICMP, и т.д.) поддерживает сканируемый хост:

$ nmap -sO 192.168.1.1
-----------------------------------------------------------------------------
Сканирование TCP/UDP Портов
-----------------------------------------------------------------------------
Сканировать все TCP Порты:

$ nmap -sT 192.168.1.1

Сканировать определенные TCP Порты:

$ nmap -p T:80 192.168.1.1

Сканировать все UDP Порты:

$ nmap -sU 192.168.1.1

Сканировать определенные UDP Порты:

$ nmap -p U:53 192.168.1.1

Объединение сканирования разных портов:

$ nmap -p U:53,79,113,T:21-25,80,443,8080 192.168.1.1
-----------------------------------------------------------------------------
Быстрое Сканирование
-----------------------------------------------------------------------------
Активировать Быстрый Режим сканирования:

$ nmap -F 192.168.1.1
-----------------------------------------------------------------------------
Показывать Причину Состояния Порта
-----------------------------------------------------------------------------
Показать Причину, по которой Nmap считает что порт находится в определенном состоянии:

$ nmap --reason 192.168.1.1
-----------------------------------------------------------------------------
Показывать Только Открытые Порты
-----------------------------------------------------------------------------
Показать Только Открытые Порты (либо возможно открытые):

$ nmap --open 192.168.1.1
-----------------------------------------------------------------------------
Определение Версии Сервисов
-----------------------------------------------------------------------------
Включить Определение Версии Сервисов:

$ nmap -sV 192.168.1.1
-----------------------------------------------------------------------------
Обнаружение Фаервола
-----------------------------------------------------------------------------
Узнать, защищен ли компьютер какими-либо Пакетными Фильтрами или Фаерволом:

$ nmap -sA 192.168.1.1
-----------------------------------------------------------------------------
Подмена MAC Адреса
-----------------------------------------------------------------------------
Подменить MAC Адреса:

$ nmap --spoof-mac 00:11:22:33:44:55 192.168.1.1

Подменить MAC Адрес Случайным MAC-ом:

$ nmap --spoof-mac 0 192.168.1.1
-----------------------------------------------------------------------------
Сканирование Фаервола на Уязвимости
-----------------------------------------------------------------------------
Эти три типа сканирования используют незаметную лазейку в TCP RFC, чтобы
разделять порты на открытые и закрытые.

Когда сканируется система отвечающая требованиям RFC, любой пакет, не содержащий
установленного бита SYN, RST или ACK, повлечет за собой отправку RST в ответ
в случае, если порт закрыт, или не повлечет никакого ответа, если порт открыт.

Т.к. ни один из этих битов не установлен, то любая комбинация трех оставшихся
(FIN, PSH и URG) будет являться правильной.

TCP Null сканирование:

$ nmap -sN 192.168.1.1

* Не устанавливаются никакие биты (Флагов в TCP заголовоке 0).

TCP Fin сканирование:

$ nmap -sF 192.168.1.1

* Устанавливается только TCP FIN бит.

TCP Xmas сканирование:

$ nmap -sX 192.168.1.1

* Устанавливаются FIN, PSH и URG флаги (пакет светится как новогодняя елка).
-----------------------------------------------------------------------------
Скрытое Сканирование
-----------------------------------------------------------------------------
Дельный Совет: Сохраняйте анонимность во время сканирования портов!
Используйте Nmap + Tor + ProxyChains! Безопасное и простое тестирование на
проникновение! Читать далее →

TCP SYN сканирование:

$ nmap -sS 192.168.0.1

* Известное как сканированием с использованием полуоткрытых соединений, так
как не отрывает полных TCP соединений.
-----------------------------------------------------------------------------
Установка Tor + Nmap + ProxyChains

Для осуществления анонимного сканирования портов нам необходимо установить следующие программы:
Программа 	Описание
tor 	Анонимизирующая сеть для TCP
nmap 	Сетевой сканер портов
proxychains 	Перенаправляет соединения через прокси-сервера
-----------------------------------------------------------------------------
Tor

Установите Tor клиент из стандартных репозиториев:

$ sudo apt-get install tor

Nmap

Установите Nmap:

$ sudo apt-get install nmap

ProxyChains

Установите ProxyChains:

$ sudo apt-get install proxychains

ProxyChains по умолчанию уже настроен на работу с Tor.

В этом можно убедиться заглянув в /etc/proxychains.conf.

Последние строки конфига должны выглядеть следующим образом:

[ProxyList]
# add proxy here ...
# meanwile
# defaults set to "tor"
socks4 127.0.0.1 9050
-----------------------------------------------------------------------------
Анонимное Сканирование Портов Через Tor

Выполните следующую команду для анонимного сканирования Nmap-ом через cеть Tor:

$ proxychains nmap -sT -PN -n -sV -p 80,443,21,22 217.xx.xx.xx
ProxyChains-3.1 (http://proxychains.sf.net)

Starting Nmap 6.00 ( http://nmap.org ) at 2014-03-24 17:34 EET
|S-chain|-<>-127.0.0.1:9050-<><>-217.xx.xx.xx:443-<><>-OK
|S-chain|-<>-127.0.0.1:9050-<><>-217.xx.xx.xx:21-<><>-OK
|S-chain|-<>-127.0.0.1:9050-<><>-217.xx.xx.xx:80-<><>-OK
|S-chain|-<>-127.0.0.1:9050-<><>-217.xx.xx.xx:22-<--denied

Nmap scan report for 217.xx.xx.xx
Host is up (0.14s latency).
PORT    STATE  SERVICE  VERSION
21/tcp  open   ftp      Pure-FTPd
22/tcp  closed ssh
80/tcp  open   http     Apache httpd 2.2.26 ((CentOS))
443/tcp open   ssl/http Apache httpd 2.2.26 ((CentOS))

В логах сканирования мы можем увидеть ‘цепочку’, которая идет от Tor-прокси
(127.0.0.1:9050) к сканируемому хосту (217.xx.xx.xx).
-----------------------------------------------------------------------------
Nmap через Tor: Обходим Блокировку Нод

Мы можем столкнуться с ситуацией когда сканирование не удается из-за того,
что выходные ноды Tor-а попадают под блокировку (банятся сканируемым хостом).

Выходом из этой ситуации может быть добавление в ‘цепочку’ обыкновенного
публичного прокси-сервера.

Это делается путем редактирования /etc/proxychains.conf и добавления новой
записи в конце [ProxyList] (также убедитесь что опция random_chain отключена).

[ProxyList]
# add proxy here ...
# meanwile
# defaults set to "tor"
socks4  127.0.0.1 9050
socks4 115.71.237.212 1080

Новая ‘цепочка’ идет через Tor-прокси (127.0.0.1:9050) к указанному нами
публичному прокси-серверу (115.71.237.212:1080), а затем к сканируемому
хосту (217.xx.xx.xx).

$ proxychains nmap -sT -PN -n -sV -p 21 217.xx.xx.xx
ProxyChains-3.1 (http://proxychains.sf.net)

Starting Nmap 6.00 ( http://nmap.org ) at 2014-03-25 11:05 EET
|S-chain|-<>-127.0.0.1:9050-<>-115.71.237.212:1080-<><>-217.xx.xx.xx:21-<><>-OK
|S-chain|-<>-127.0.0.1:9050-<>-115.71.237.212:1080-<><>-217.xx.xx.xx:21-<><>-OK
Nmap scan report for 217.xx.xx.xx
Host is up (1.2s latency).
PORT   STATE SERVICE VERSION
21/tcp open  ftp     Pure-FTPd

В примерах выше, я запускаю Nmap со следующими опциями:
Опция 	Описание
-sT 	полное TCP сканирование
-PN 	пропустить обнаружение хостов
-n 	никогда не резолвить DNS (во избежание утечки через DNS)
-sV 	определять версию сервиса
-p 	какие порты сканировать

Сканирование через Tor очень медленное. Поэтому, в примерах выше, я сканировал
только определенные порты. 
-----------------------------------------------------------------------------
Списки Бесплатных Публичных Прокси-Серверов

    Hide My Ass
    Proxy Server List
    Anonymous Public Proxy Servers
    Daily HTTP Proxies
    Valid-Proxy.com

Даже если Вы используете прокси, все Ваши DNS запроси все равно направляются
на DNS сервера Вашего Интернет-Провайдера.

Во избежание утечек через DNS, используйте команду tor-resolve, для
преобразования имени хоста в IP-адрес, через сеть Tor:

$ tor-resolve google.com
173.194.34.174
-----------------------------------------------------------------------------
Отключение Обнаружения Хостов (No Ping)
-----------------------------------------------------------------------------
Не пинговать хосты перед сканированием:

$ nmap -Pn 192.168.1.1
-----------------------------------------------------------------------------
Отключение Использования DNS
-----------------------------------------------------------------------------
Дельный Совет: Необходимо усилить безопасность в Linux? Шифруйте DNS трафик
для защиты от спуфинга! Читать далее →

Никогда не производить обратное преобразование DNS имен для каждого обнаруженного активного IP адреса:

$ nmap -n 192.168.1.1
-----------------------------------------------------------------------------
Шифрование DNS Трафика с Помощью DNSCrypt
-----------------------------------------------------------------------------
DNSCrypt Proxy — это утилита для безопасной связи между клиентом и DNS сервером.

Она шифрует DNS запросы по протоколу DNSCrypt и передает их вышестоящему
серверу, по умолчанию OpenDNS.
Разрешение зависимостей

Установите пакеты, необходимые для компиляции DNSCrypt.

$ sudo apt-get install build-essential

Скачайте и разархивируйте последнюю версию библиотеки libsodium:

$ wget http://download.libsodium.org/libsodium/releases/libsodium-0.4.2.tar.gz  -O - | tar -xz

Установите библиотеку:

$ cd libsodium-0.4.2/
$ ./configure && make
$ sudo make install
$ sudo ldconfig
$ cd ..
$ rm -rf libsodium*

Установка DNSCrypt Proxy

Скачайте и разархивируйте последнюю версию DNSCrypt Proxy:

$ wget http://download.dnscrypt.org/dnscrypt-proxy/dnscrypt-proxy-1.3.3.tar.gz  -O - | tar -xz

Установите DNSCrypt Proxy:

$ cd dnscrypt-proxy-1.3.3/
$ ./configure  && make
$ sudo make install
$ cd ..
$ rm -rf dnscrypt-proxy*

Запустите DNSCrypt с помощью следующей команды:

$ sudo /usr/local/sbin/dnscrypt-proxy --daemonize --pidfile=/run/dnscrypt-proxy.pid --edns-payload-size=4096

Настройте Network Manager для работы с DNSCrypt:

    Откройте Сетевые Подключения (Network Connections).
    Выберите Ваше активное подключение к Интернету.
    Нажмите «Изменить».
    Во вкладке «Настройка IPv4», выберите метод «Automatic (DHCP)
addresses only» и пропишите DNS сервер «127.0.0.1».
    Нажмите «Сохранить».
    Нажмите «Закрыть».

Перезапустите Network Manager:

$ sudo restart network-manager

Финальный тест

Перейдите по ссылке http://www.opendns.com/welcome для проверки вашего соединения.

Вас должен поприветствовать OpenDNS.
-----------------------------------------------------------------------------
Запуск DNSCrypt Proxy при Загрузки Системы

Как только все заработало как надо, необходимо добавить dnscrypt-proxy в
автозагрузку, чтобы он автоматически запускался каждый раз при старте системы.

Для этого откройте файл /etc/rc.local:

$ sudo vi /etc/rc.local

Вставьте следующую стоку перед строкой содержащей exit 0.

exec /usr/local/sbin/dnscrypt-proxy --daemonize --pidfile=/run/dnscrypt-proxy.pid --edns-payload-size=4096
-----------------------------------------------------------------------------
Сохранение Результатов Сканирования Nmap в Файл
-----------------------------------------------------------------------------
Сохранить результат сканирования Nmap в Текстовый Файл:

$ nmap 192.168.1.1 > output.txt
$ nmap -oN output.txt 192.168.1.1

Сохранить результат сканирования Nmap в XML Файл:

$ nmap -oX output.xml 192.168.1.1
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
####################
#SCAN NETWORK 
####################
----------------------------------------------------------------------------------
https://nmap.org/man/ru/
https://ip-calculator.ru/#!ip=185.35.100.0/20
----------------------------------------------------------------------------------
1. Уточняем, можно ли это делать у владельца сети.
2. Считаем сеть https://ip-calculator.ru/ -> получаем диапазон
3. Запускаем Nmap https://nmap.org/man/ru/ c проверкой служб на 22,53,80,443,3389,8080
и тд -> Лог файл.
4. Парсим Лог.
5. Проверяем соответствие IP -> DNS именам.
6. Определяем дейтсвующие вебсайты, сервера unix, windows.
----------------------------------------------------------------------------------
nmap -v -A scanme.nmap.org
----------------------------------------------------------------------------------
Доролнение
1. Просканить порты на наличие открытых сервисов (суммарно)
2. На открытые 25 порты поузнавать заголовок сервера (смотреть на хост), то же с
портами 22 и 21.
3. Пробить порты 80, 443 курлом - открытые спарсить на наличие HTML ссылок. Страницы
4xx тоже могут отдавать хостнейм.
4. получить PTR
5. взять списки доменов (конечно не только украинские), пройтись по каждому домену,
взять часто используемые субдомены,
SRV (AD, DC, XMPP, автокофигурация почты и т.д.) и проверить вхождение в подсети WP.
6. еще есть сервисы где вбиваешь IP сервера - он показывает какие сайты на нем,
но там обычно капча. 
-----------------------------------------------------------------------------
===============
L4.HDD
===============
-----------------------------------------------------------------------------
raid_0_60
-----------------------------------------------------------------------------
RAID (англ. redundant array of independent disks — избыточный массив
независимых дисков) — технология виртуализации данных, которая объединяет несколько дисков в логический элемент для избыточности и повышения производительности.
-----------------------------------------------------------------------------
    RAID 1 — зеркальный дисковый массив;
-----------------------------------------------------------------------------
    RAID 5 — дисковый массив с чередованием и отсутствием выделенного диска чётности.
-----------------------------------------------------------------------------
Достоинства
-----------------------------------------------------------------------------
1. экономичный.
«потеряется» всего 25 % против 50 % RAID 10. 
Cувеличением количества дисков в массиве экономия продолжает увеличиваться.

2. Высокую скорость чтения — выигрыш достигается за счёт независимых потоков
данных с нескольких дисков массива, которые могут обрабатываться параллельно.
-----------------------------------------------------------------------------
Недостатки
-----------------------------------------------------------------------------
Производительность RAID 5 заметно ниже на операциях типа Random Write
(записи в произвольном порядке). Каждая операция записи заменяется на
контроллере RAID на четыре — две операции чтения и две операции записи).
-----------------------------------------------------------------------------
В современных RAID-контроллерах предоставлены дополнительные уровни спецификации RAID:
-----------------------------------------------------------------------------
    RAID 0 — дисковый массив повышенной производительности с чередованием,
		без отказоустойчивости. Строго говоря, RAID-массивом не является, поскольку
		избыточность (redundancy) в нём отсутствует;
-----------------------------------------------------------------------------
    RAID 6 — дисковый массив с чередованием, использующий две контрольные суммы,
		вычисляемые двумя независимыми способами;
-----------------------------------------------------------------------------
Имеет более высокую степень надёжности — три диска данных и два диска
контроля чётности.
-----------------------------------------------------------------------------
Обычно использование RAID-6 вызывает примерно 10-15 % падение производительности
дисковой группы, относительно RAID 5, что вызвано бо́льшим объёмом работы для
контроллера (более сложный алгоритм расчета контрольных сумм), а также
необходимостью читать и перезаписывать больше дисковых блоков при записи
каждого блока.

-----------------------------------------------------------------------------
    RAID 10 — массив RAID 0, построенный из массивов RAID 1;
-----------------------------------------------------------------------------
RAID 10 объединяет в себе высокую отказоустойчивость и производительность.
-----------------------------------------------------------------------------
является самым надёжным вариантом для хранения данных вполне обосновано тем,
что весь массив RAID 10 будет выведен из строя только после выхода из строя
всех накопителей в одном и том же массиве RAID 1
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
    RAID 01 — массив RAID 1, построенный из массивов RAID 0 (имеет низкую отказоустойчивость);
-----------------------------------------------------------------------------
Для сравнения: RAID 0+1 выйдет из строя при двух накопителях, вышедших из строя в разных массивах. 
-----------------------------------------------------------------------------
    RAID 50 — массив RAID 0, построенный из массивов RAID 5;
-----------------------------------------------------------------------------
появление чередования в уровне RAID 5+0 нисколько не добавляет ему надёжности,
но зато положительно отражается на производительности.
----------------------------------------------------------------------------
    RAID 60 — массив RAID 0, построенный из массивов RAID 6;
-----------------------------------------------------------------------------
Нестандартные уровни спецификации RAID
-----------------------------------------------------------------------------
    RAID-Z — массив RAID 5, имеющий ряд модификаций, включая ZFS, динамический
		размер страйпа и 256 битную хеш-сумму.
-----------------------------------------------------------------------------
Уровень		Количество	Допустимое	Надёжность 	Скорость 	Скорость 
		дисков		количество			чтения		записи
				вышедших из
				строя дисков
-----------------------------------------------------------------------------
5		от 3		1 диск		средняя 	высокая 	средняя 	
-----------------------------------------------------------------------------
6		от 4		2 диска		высокая 	высокая 	низкая
-----------------------------------------------------------------------------
10		от 4, чётное	от 1 до N/2	средняя 	высокая 	высокая
				дисков**
-----------------------------------------------------------------------------
50 		от 6, чётное 	от 1 до 2 	средняя 	высокая 	высокая
				дисков***
-----------------------------------------------------------------------------
60		от 8, чётное	от 2 до 4	средняя 	высокая 	средняя
				дисков***
------------------------------------------------------------
* N — количество дисков в массиве, S — объём наименьшего диска[4][5][6][7].
** Информация не потеряется, если выйдут из строя диски в пределах разных зеркал.
*** Информация не потеряется, если выйдет из строя одинаковое кол-во дисков в разных stripe’ах.

-----------------------------------------------------------------------------
lvm
-----------------------------------------------------------------------------
Список команд для работы с LVM
-----------------------------------------------------------------------------
lvchange
    Изменить атрибуты логического тома 
lvcreate
    Создать логический том 
lvdisplay
    Показать информацию о логическом томе 
lvextend
    Добавить места в логический том 
lvmchange
    (команда устарела, её лучше не использовать) 
lvmdiskscan
    Показать список устройств, которые могут быть использованы как физический том 
lvmsadc
    Собрать данные об активности использования LVM 
lvmsar
    Создать отчёт об активности использования LVM 
lvreduce
    Уменьшить размер логического тома 
lvremove
    Удалить логический том из системы 
lvrename
    Переименовать логический том 
lvresize
    Изменить размер логического тома 
lvs
    Показать информацию о логическом томе 
lvscan
    Показать список логических томов во всех группах томов 
-----------------------------------------------------------------------------
pvchange
    Изменить атрибуты физического тома 
pvcreate
    Инициализировать физический том для использования в LVM 
pvdata
    Показать информацию (из метаданных на диске) о физическом томе 
pvdisplay
    Показать информацию о физическом томе 
pvmove
    Переместить эстенты с одного физического тома на другой 
pvremove
    Удалить метку LVM с физического тома 
pvresize
    Изменить размер физического тома, использующегося в группе томов 
pvs
    Показать информацию о физическом томе 
pvscan
    Показать список всех физических томов
----------------------------------------------------------------------------- 
vgcfgbackup
    Сделать резервную копию конфигурации группы томов 
vgcfgrestore
    Восстановить из резервной копии конфигурацию группы томов 
vgchange
    Изменить атрибуты группы томов 
vgck
    Проверить целостность группы томов 
vgconvert
    Изменить формат метаданных группы томов 
vgcreate
    Создать группу томов 
vgdisplay
    Показать информацию о группе томов 
vgexport
    Разрегистрировать группу томов в системе 
vgextend
    Добавить физический том в группу томов 
vgimport
    Зарегистрировать эскпортированную группу томов в системе 
vgmerge
    Объединить группы томов 
vgmknodes
    Создать файлы устройств для групп томов в каталоге /dev/ 
vgreduce
    Удалить физический том из группы томов 
vgremove
    Удалить группу томов 
vgrename
    Переименовать группу томов 
vgs
    Показать информацию о группах томов 
vgscan
    Выполнить поиск групп томов 
vgsplit
    Переместить физический том в новую группу томов 
-----------------------------------------------------------------------------
Терминология
-----------------------------------------------------------------------------
взаимосвязь понятий системы LVM:

sda1     sda2     sdb     sdc       <-- PV
 |        |        |       |
 |        |        |       |
 +--------+- VG00 -+-------+        <-- VG
              |
 +-------+-------+---------+
 |       |       |         |
root    usr     home      var       <-- LV
 |       |       |         | 
ext3 reiserfs reiserfs    xfs       <-- Файловые системы

-----------------------------------------------------------------------------
     PV, Physical volume, физический том. Обычно это раздел на диске или весь
диск. В том числе, устройства программного и аппаратного RAID (которые уже могут включать в себя несколько физических дисков). Физические тома входят в
состав группы томов.
-----------------------------------------------------------------------------
    VG, Volume group, группа томов. Это самый верхний уровень абстрактной
модели, используемой системой LVM. С одной стороны группа томов состоит из физических томов, с другой -- из логических и представляет собой единую
административную единицу.
-----------------------------------------------------------------------------
    LV, Logical volume, логический том. Раздел группы томов, эквивалентен
разделу диска в не-LVM системе. Представляет собой блочное устройство и, как следствие, может содержать файловую систему.
-----------------------------------------------------------------------------
    PE, Physical extent, физический экстент. Каждый физический том делится
на порции данных, называющиеся физическими экстентами. Их размеры те же, что и у логических экстентов.
-----------------------------------------------------------------------------
    LE, Logical extent, логический экстент. Каждый логический том делится
на порции данных, называющиеся логическими экстентами. Размер логических
экстентов не меняется в пределах группы томов. 
-----------------------------------------------------------------------------
Работа с LVM 
-----------------------------------------------------------------------------
для работы с системой LVM ее нужно инициализировать командами: 
-----------------------------------------------------------------------------
# vgscan
# vgchange -ay
-----------------------------------------------------------------------------
Первая команда сканирует диски на предмет наличия групп томов, вторая
активирует все найденные группы томов. Аналогично для завершения всех работ,
связанных с LVM, нужно выполнить деактивацию групп: 
-----------------------------------------------------------------------------
# vgchange -an
-----------------------------------------------------------------------------
Первые две строки нужно будет поместить в скрипты автозагрузки
(если их там нет), а последнюю можно дописать в скрипт shutdown. 
-----------------------------------------------------------------------------
Инициализация дисков и разделов
-----------------------------------------------------------------------------
Перед использованием диска или раздела в качестве физического тома необходимо
его инициализировать:
-----------------------------------------------------------------------------
# pvcreate /dev/hdb	Эта команда создает в начале диска дескриптор группы томов.
-----------------------------------------------------------------------------
Если вы получили ошибку инициализации диска с таблицей разделов -- проверьте,
что работаете именно с нужным диском, и когда полностью будете уверены в том,
что делаете, выполните следующие команды
-----------------------------------------------------------------------------
# dd if=/dev/zero of=/dev/diskname bs=1k count=1
# blockdev --rereadpt /dev/diskname

Эти команды уничтожат таблицу разделов на целевом диске. 
-----------------------------------------------------------------------------
Для разделов:
Установите программой fdisk тип раздела в 0x8e.
-----------------------------------------------------------------------------
# pvcreate /dev/hdb1	Команда создаст в начале раздела /dev/hdb1 дескриптор
			группы томов. 
-----------------------------------------------------------------------------
Создание группы томов 
-----------------------------------------------------------------------------
# vgcreate vg00  /dev/hda1 /dev/hdb1 
-----------------------------------------------------------------------------
Если вы используете devfs важно указывать полное имя в devfs, а не ссылку в
каталоге /dev. Таким образом приведенная команда должна выглядеть в системе с
devfs так:

# vgcreate vg00  /dev/ide/host0/bus0/target0/lun0/part1 /dev/ide/host0/bus0/target1/lun0/part1

Кроме того, вы можете задать размер экстента при помощи ключа "-s", если
значение по умолчанию в 4Мб вас не устраивает. Можно, также, указать
ограничения возможного количества физических и логических томов. 
-----------------------------------------------------------------------------
Активация группы томов
-----------------------------------------------------------------------------
После перезагрузки системы или выполнения команды vgchange -an, ваши группы
томов и логические тома находятся в неактивном состоянии. Для их активации
необходимо выполнить команду
-----------------------------------------------------------------------------
# vgchange -a y vg00
-----------------------------------------------------------------------------
Удаление группы томов 
-----------------------------------------------------------------------------
Убедитесь, что группа томов не содержит логических томов. Как это сделать,
показано в следующих разделах.

# vgchange -a n vg00		Деактивируйте группу томов
# vgremove vg00			Теперь можно удалить группу томов командой
-----------------------------------------------------------------------------
Добавление физических томов в группу томов
-----------------------------------------------------------------------------
Для добавления предварительно инициализированного физического тома в
существующую группу томов используется команда 'vgextend':
-----------------------------------------------------------------------------
# vgextend vg00 /dev/hdc1
-----------------------------------------------------------------------------
Удаление физических томов из группы томов 
-----------------------------------------------------------------------------
Убедитесь, что физический том не используется никакими логическими томами.
Для этого используйте команду 'pvdisplay':
-----------------------------------------------------------------------------
# pvdisplay /dev/hda1
# vgreduce vg00 /dev/hda1
-----------------------------------------------------------------------------
Создание логического тома 
-----------------------------------------------------------------------------
Для того, чтобы создать логический том "lv00", размером 1500Мб, выполните команду:
-----------------------------------------------------------------------------
# lvcreate -L1500 -n lv00 vg00
-----------------------------------------------------------------------------
Для создания логического тома размером в 100 логических экстентов с
расслоением по двум физическим томам и размером блока данных 4 KB:
-----------------------------------------------------------------------------
# lvcreate -i2 -I4 -l100 -n lv01 vg00
-----------------------------------------------------------------------------
Если вы хотите создать логический том, полностью занимающий группу томов,
выполните команду vgdisplay, чтобы узнать полный размер группы
-----------------------------------------------------------------------------
# vgdisplay vg00 | grep "Total PE"
 Total PE        10230

# lvcreate -l 10230 vg00 -n lv02
или
# lvcreate -l100%FREE vg00 -n lv02
-----------------------------------------------------------------------------
Удаление логических томов
-----------------------------------------------------------------------------
Логический том должен быть размонтирован перед удалением:
-----------------------------------------------------------------------------
# umount /dev/vg00/home
# lvremove /dev/vg00/home
-----------------------------------------------------------------------------
Увеличение логических томов
-----------------------------------------------------------------------------
Для увеличения логического тома вам нужно просто указать команде lvextend до какого размера вы хотите увеличить том:
-----------------------------------------------------------------------------
# lvextend -L12G /dev/vg00/home
-----------------------------------------------------------------------------
В результате /dev/vg00/home увеличится до 12Гбайт.
-----------------------------------------------------------------------------
# lvextend -L+1G /dev/vg00/home
-----------------------------------------------------------------------------
Эта команда увеличивает размер логического тома на 1Гб.
-----------------------------------------------------------------------------
# lvextend -l +100%FREE /dev/vg00/home
-----------------------------------------------------------------------------
А эта команда увеличивает размер логического тома до максимально доступного.
-----------------------------------------------------------------------------
После того как вы увеличили логический том, необходимо соответственно
увеличить размер файловой системы. Как это сделать зависит от типа
используемой файловой системы.

По умолчанию большинство утилит изменения размера файловой системы увеличивают
ее размер до размера соответствующего логического тома. Так что вам не нужно
беспокоится об указании одинаковых размеров для всех команд. 
-----------------------------------------------------------------------------
ext2/ext3/ext4
-----------------------------------------------------------------------------
Если вы не пропатчили ваше ядро патчем ext2online, вам будет необходимо
размонтировать файловую систему перед изменением размера:
-----------------------------------------------------------------------------
    # umount /dev/vg00/home
    # resize2fs /dev/vg00/home
    # mount /dev/vg00/home /home
-----------------------------------------------------------------------------
Если у вас нет пакета e2fsprogs 1.19 его можно загрузить с сайта ext2resize.sourceforge.net.
-----------------------------------------------------------------------------
Для файловой системы ext2 есть и другой путь. В состав LVM входит утилита
e2fsadm, которая выполняет и lvextend, и resize2fs (она также выполняет и
уменьшение размера файловой системы, это описано в следующем разделе). Так
что можно использовать одну команду:

    # e2fsadm -L+1G /dev/vg00/home

что эквивалентно двум следующим:

    # lvextend -L+1G /dev/vg00/home
    # resize2fs /dev/vg00/home


вам все равно нужно будет размонтировать файловую систему перед выполнением e2fsadm.
-----------------------------------------------------------------------------
 jfs
-----------------------------------------------------------------------------
mount -o remount,resize /home
-----------------------------------------------------------------------------
 reiserfs
-----------------------------------------------------------------------------
Увеличивать размер файловых систем Reiserfs можно как в смонтированном, так и
в размонтированном состоянии.
-----------------------------------------------------------------------------
Увеличить размер смонтированной файловой системы:
-----------------------------------------------------------------------------
    # resize_reiserfs -f /dev/vg00/home

Увеличить размер размонтированной файловой системы:

    # umount /dev/vg00/homevol
    # resize_reiserfs /dev/vg00/homevol
    # mount -treiserfs /dev/vg00/homevol /home
-----------------------------------------------------------------------------
 xfs
-----------------------------------------------------------------------------
Размер файловой системы XFS можно увеличить только в смонтированном состоянии.
Кроме того, утилите в качестве параметра нужно передать точку монтирования, а
не имя устройства:
-----------------------------------------------------------------------------
    # xfs_growfs /home
-----------------------------------------------------------------------------
Уменьшение размера логического тома
-----------------------------------------------------------------------------
Логические тома могут быть уменьшены в размере, точно также как и увеличены.
Однако очень важно помнить, что нужно в первую очередь уменьшить размер файловой
системы, и только после этого уменьшать размер логического тома. Если вы нарушите
последовательность, вы можете потерять данные.
-----------------------------------------------------------------------------
ext2
-----------------------------------------------------------------------------
При использовании файловой системы ext2, как уже указывалось ранее, можно
использовать команду e2fsadm:
-----------------------------------------------------------------------------
   # umount /home
   # e2fsadm -L-1G /dev/vg00/home
   # mount /home
-----------------------------------------------------------------------------
Если вы хотите выполнить операцию по уменьшению логического тома вручную, вам
нужно знать размер тома в блоках:
-----------------------------------------------------------------------------
   # umount /home
   # resize2fs /dev/vg00/home 524288
   # lvreduce -L-1G /dev/vg00/home
   # mount /home
-----------------------------------------------------------------------------
reiserfs
-----------------------------------------------------------------------------
При уменьшении размера файловой системы Reiserfs, ее нужно размонтировать:
-----------------------------------------------------------------------------
   # umount /home
   # resize_reiserfs -s-1G /dev/vg00/home
   # lvreduce -L-1G /dev/vg00/home
   # mount -treiserfs /dev/vg00/home /home
-----------------------------------------------------------------------------
xfs
-----------------------------------------------------------------------------
Уменьшить размер файловой системы XFS нельзя.
-----------------------------------------------------------------------------
Примечание: обратите внимание на то, что для уменьшения размера файловых
систем, необходимо их размонтировать. Это вносит определенные трудности,
если вы желаете уменьшить размер корневой файловой системы. В этом случае
можно применить следующий метод: загрузится с CD дистрибутива, поддерживающего
LVM. Перейти в командный режим (обычно это делается нажатием клавиш Alt+F2) и
выполнить команды сканирования и активации группы томов:
-----------------------------------------------------------------------------
# vgscan
# vgchange -a y
-----------------------------------------------------------------------------
Теперь вы имеете доступ к логическим томам и можете изменять их размеры:
-----------------------------------------------------------------------------
# resize_reiserfs -s-500M /dev/vg00/root
# lvreduce -L-500M /dev/vg00/root
# reboot

-----------------------------------------------------------------------------
Примеры
-----------------------------------------------------------------------------
Настройка LVM на трех SCSI дисках
-----------------------------------------------------------------------------
В первом примере мы настроим логический том из трех SCSI дисков.
Устройства дисков: /dev/sda, /dev/sdb и /dev/sdc.
-----------------------------------------------------------------------------
Перед добавлением в группу томов диски нужно инициализировать:

# pvcreate /dev/sda
# pvcreate /dev/sdb
# pvcreate /dev/sdc
-----------------------------------------------------------------------------
После выполнения этих команд в начале каждого диска создастся область
дескрипторов группы томов.
-----------------------------------------------------------------------------
Теперь создадим группу томов vg01, состоящую из этих дисков:
-----------------------------------------------------------------------------
# vgcreate vg01 /dev/sda /dev/sdb /dev/sdc
-----------------------------------------------------------------------------
Проверим статус группы томов командой vgdisplay:
-----------------------------------------------------------------------------
# vgdisplay
-----------------------------------------------------------------------------
Создание логического тома
-----------------------------------------------------------------------------
После успешного создания группы томов, можно начать создавать логические тома
в этой группе. Размер тома может быть любым, но, естественно, не более всего
размера группы томов. В этом примере мы создадим один логический том размером
1 Гб. Мы не будем использовать "расслоение", поскольку при этом невозможно
добавить диск в группу томов после создания логического тома, использующего
данный алгоритм.
-----------------------------------------------------------------------------
# lvcreate -L1G -nusrlv vg01
-----------------------------------------------------------------------------
Создание файловой системы
-----------------------------------------------------------------------------
Создадим на логическом томе файловую систему ext2:
-----------------------------------------------------------------------------
# mke2fs /dev/vg01/usrlv
-----------------------------------------------------------------------------
Тестирование файловой системы
-----------------------------------------------------------------------------
Смонтируйте логический том и проверьте все ли в порядке:
-----------------------------------------------------------------------------
# mount /dev/vg01/usrlv /mnt
# df
-----------------------------------------------------------------------------
Если вы все сделали правильно, у вас должен появиться логический том с файловой
системой ext2, смонтированный в точке /mnt. 
-----------------------------------------------------------------------------
Добавление нового диска
-----------------------------------------------------------------------------
Рассмотрим систему со следующей конфигурацией:
-----------------------------------------------------------------------------
# pvscan
pvscan -- ACTIVE   PV "/dev/sda"  of VG "dev"   [1.95 GB / 0 free]
pvscan -- ACTIVE   PV "/dev/sdb"  of VG "sales" [1.95 GB / 0 free]
pvscan -- ACTIVE   PV "/dev/sdc"  of VG "ops"   [1.95 GB / 44 MB free]
pvscan -- ACTIVE   PV "/dev/sdd"  of VG "dev"   [1.95 GB / 0 free]
pvscan -- ACTIVE   PV "/dev/sde1" of VG "ops"   [996 MB / 52 MB free]
pvscan -- ACTIVE   PV "/dev/sde2" of VG "sales" [996 MB / 944 MB free]
pvscan -- ACTIVE   PV "/dev/sdf1" of VG "ops"   [996 MB / 0 free]
pvscan -- ACTIVE   PV "/dev/sdf2" of VG "dev"   [996 MB / 72 MB free]

# df
Filesystem           1k-blocks      Used Available Use% Mounted on
/dev/dev/users         2064208   2060036      4172 100% /mnt/dev/users
/dev/ops/batch         1032088    897122    134966  86% /mnt/ops/batch
-----------------------------------------------------------------------------
Как видно из листинга, группы томов "dev" и "ops" практически заполнены.
В систему добавили новый диск /dev/sdg. Его необходимо разделить между
группами "ops" и "dev", поэтому разобьем его на разделы:
-----------------------------------------------------------------------------
# fdisk /dev/sdg
-----------------------------------------------------------------------------
Перед тем как добавить разделы в группу томов, их необходимо инициализировать:
-----------------------------------------------------------------------------
# pvcreate /dev/sdg1
pvcreate -- physical volume "/dev/sdg1" successfully created

# pvcreate /dev/sdg2
pvcreate -- physical volume "/dev/sdg2" successfully created
-----------------------------------------------------------------------------
Теперь можно добавлять физические тома в группы томов:
-----------------------------------------------------------------------------
# vgextend ops /dev/sdg1
# vgextend dev /dev/sdg2
-----------------------------------------------------------------------------
# pvscan
pvscan -- ACTIVE   PV "/dev/sdg1" of VG "ops"   [996 MB / 996 MB free]
pvscan -- ACTIVE   PV "/dev/sdg2" of VG "dev"   [996 MB / 996 MB free]
-----------------------------------------------------------------------------
Наконец, увеличим размеры логических томов и расширим файловые системы до
размеров логических томов:
-----------------------------------------------------------------------------
# umount /mnt/ops/batch
# umount /mnt/dev/users
-----------------------------------------------------------------------------
# export E2FSADM_RESIZE_CMD=ext2resize
# e2fsadm /dev/ops/batch -L+500M
# e2fsadm /dev/dev/users -L+900M
-----------------------------------------------------------------------------
Нам осталось смонтировать системы и посмотреть их размеры:
-----------------------------------------------------------------------------
# mount /dev/ops/batch
# mount /dev/dev/users
# df
Filesystem           1k-blocks      Used Available Use% Mounted on
/dev/dev/users         2969360   2060036    909324  69% /mnt/dev/users
/dev/ops/batch         1535856    897122    638734  58% /mnt/ops/batch

-----------------------------------------------------------------------------
Резервное копирование при помощи "снапшотов"
-----------------------------------------------------------------------------
Развивая приведенный пример, предположим, что нам нужно выполнить
резервирование базы данных. Для этой задачи мы будем использовать
устройство-"снапшот".

Этот тип устройства представляет собой доступную только на чтение
(при использовании опции --permission r) копию другого тома на момент
выполнения процедуры "снапшот". Это дает возможность продолжать работу не
заботясь о том, что данные могут измениться в момент резервного копирования.
Следовательно, нам не нужно останавливать работу базы данных на время выполнения
резервного копирования. Остановка нужна только на момент создания
устройства-"снапшот", который значительно короче самого копирования.
-----------------------------------------------------------------------------
В группе томов ops у нас осталось около 600Мб свободного места, его мы и
задействуем для "снапшот"-устройства. Размер "снапшот"-устройства не
регламентируется, но должен быть достаточен для сохранения всех изменений,
которые могут произойти с томом, с которого он сделан, за время жизни
снапшота. 600Мб должно хватить для наших целей:
-----------------------------------------------------------------------------
# lvcreate -L592M -s -n dbbackup -p r /dev/ops/databases
-----------------------------------------------------------------------------
Если вы делаете "снапшот" файловой системы XFS, нужно выполнить на
смонтированной файловой системе команду xfs_freeze, и лишь после этого
создавать "снапшот":
-----------------------------------------------------------------------------
# xfs_freeze -f /mnt/point;
# lvcreate -L592M -s -n dbbackup /dev/ops/databases;
# xfs_freeze -u /mnt/point
-----------------------------------------------------------------------------
Если устройство-"снапшот" полностью заполняется, оно автоматически
деактивируется. В этом случае "снапшот" не может более использоваться, потому
крайне важно выделять достаточное пространство для него.
-----------------------------------------------------------------------------
После того как мы создали "снапшот", его нужно смонтировать:
-----------------------------------------------------------------------------
# mkdir /mnt/ops/dbbackup
# mount /dev/ops/dbbackup /mnt/ops/dbbackup
-----------------------------------------------------------------------------
Если вы работаете с файловой системой XFS, вам будет нужно при монтировании
указать опцию nouuid:
-----------------------------------------------------------------------------
# mount -o nouuid,ro /dev/ops/dbbackup /mnt/ops/dbbackup
-----------------------------------------------------------------------------
Выполним резервное копирование раздела:
-----------------------------------------------------------------------------
# tar -cf /dev/rmt0 /mnt/ops/dbbackup
-----------------------------------------------------------------------------
После выполнения необходимых процедур, нужно удалить устройство-"снапшот":
-----------------------------------------------------------------------------
# umount /mnt/ops/dbbackup
# lvremove /dev/ops/dbbackup 
-----------------------------------------------------------------------------	
Запись данных на том, с которого сделан снимок, очень сильно замедлена по
сравнению с обычной работой!
-----------------------------------------------------------------------------
Элементарное сравнение производительности, наглядно демонстрирующее разницу
между скоростью работы с томом, у которого нет снапшотов
(смонтирован в /data/lv3/xxxx), и с томом, на котором есть снапшот
(смонтирован в /data/lv4/qqqq).
-----------------------------------------------------------------------------
# dd if=/dev/zero of=/data/lv3/xxxx count=100 bs=1024k
# dd if=/dev/zero of=/data/lv4/qqqq count=100 bs=1024k
-----------------------------------------------------------------------------
Удаление диска из группы томов
-----------------------------------------------------------------------------
Скажем, вы хотите освободить один диск из группы томов. Для этого необходимо
выполнить процедуру переноса использующихся физических экстентов. Естественно,
что на других физических томах должно быть достаточно свободных физических
экстентов.
-----------------------------------------------------------------------------
Выполните команду:
-----------------------------------------------------------------------------
# pvmove /dev/hdb
-----------------------------------------------------------------------------
Учтите, что операция переноса физических экстентов занимает много времени.
Если вы хотите наблюдать за процессом переноса экстентов, укажите в команде
ключ -v .
-----------------------------------------------------------------------------
После окончания процедуры переноса, удалите физический том из группы томов:
-----------------------------------------------------------------------------
# vgreduce dev /dev/hdb
-----------------------------------------------------------------------------
Теперь данный диск может быть физически удален из системы или использован в
других целях. Например, добавлен в другую группу томов. 
-----------------------------------------------------------------------------
Перенос группы томов на другую систему
-----------------------------------------------------------------------------
Физический перенос группы томов на другую систему организовывается при помощи
команд vgexport и vgimport.
-----------------------------------------------------------------------------
Сперва необходимо размонтировать все логические тома группы томов и
деактивировать группу:
-----------------------------------------------------------------------------
# unmount /mnt/design/users
# vgchange -an design
-----------------------------------------------------------------------------
После этого экспортируем группу томов. Процедура экспорта запрещает доступ к
группе на данной системе и готовит ее к удалению:
-----------------------------------------------------------------------------
# vgexport design
-----------------------------------------------------------------------------
Теперь можно выключить машину, отсоединить диски, составляющие группу томов и
подключить их к новой системе. Остается импортировать группу томов на новой
машине и смонтировать логические тома:
-----------------------------------------------------------------------------
# pvscan
pvscan -- inactive PV "/dev/sdb1"  is in EXPORTED VG "design" [996 MB / 996 MB free]
pvscan -- inactive PV "/dev/sdb2"  is in EXPORTED VG "design" [996 MB / 244 MB free]
-----------------------------------------------------------------------------
# vgimport design /dev/sdb1 /dev/sdb2
-----------------------------------------------------------------------------
# mkdir -p /mnt/design/users
# mount /dev/design/users /mnt/design/users
-----------------------------------------------------------------------------
Все! Группа томов готова к использованию на новой системе. 

-----------------------------------------------------------------------------
lvm и fsck
-----------------------------------------------------------------------------
Установочный диск с RHEL позволяет при загрузке выбрать режим Rescue 
(или передать ядру соответствующий параметр в меню GRUB: «linux rescue»).
Когда будет получен доступ к системной консоли, файловые системы можно
проверять на наличие ошибок с помощью утилиты fsck. Конфигурация RHEL по
умолчанию подразумевает использование LVM (Logical Volume Manager), и в
случае работы с ней могут возникнуть трудности.
-----------------------------------------------------------------------------
Для начала, чтобы загруженная система смогла определить и подгрузить LVM,
выполните команду:
-----------------------------------------------------------------------------
# vgscan
-----------------------------------------------------------------------------
После этого можно получить список имеющихся томов:
-----------------------------------------------------------------------------
# vgdisplay
-----------------------------------------------------------------------------
Теперь надо проверить нужные разделы на ошибки с помощью команды fsck. 
-----------------------------------------------------------------------------
Среди доступных ключей к ней:
> -p - автоматически восстанавливать (без вопросов);
> -n - не делать изменений в файловой системе;
> -у - ответить «Да» на все запросы;
> -с - проверить сектора на повреждения (bad blocks) и добавить их в список badblock list;
> -f - принудительно проверить, даже если в файловой системе нет ошибок.
-----------------------------------------------------------------------------
# ls /dev/VolGroup00/*

/dev/VolGroup00/LogVol00 /dev/VolGroup00/LogVol03
/dev/VolGroup00/LogVol01 /dev/VolGroup00/LogVol04
/dev/VolGroup00/LogVol02

# fsck /dev/VolGroup00/LogVol02 -c -f –v
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------

-----------------------------------------------------------------------------

-----------------------------------------------------------------------------

-----------------------------------------------------------------------------

fdisk/fsck
-----------------------------------------------------------------------------
# /sbin/fdisk -l /dev/sda

# ls /dev | grep sd
sda
-----------------------------------------------------------------------------
# fdisk /dev/sda
-----------------------------------------------------------------------------
Список доступных командам можно получить введя «m»

Команды
a   установить/снять флаг загрузочного раздела
b   редактировать метки bsd диска
c   переключить флаг совместности с dos
d   удалить раздел
l   вывести список известных типов разделов
m   показать это меню
n   добавить новый раздел
o   создать новую пустую таблицу разделов в стиле DOS
p   показать существующею таблицу разделов
q   выйти без сохранения изменений
s   создать новый раздел с меткой Sun
t   изменить метку типа раздела
u   изменить отображения/записи блоков
v   проверить таблицу разделов
w   сохранить изменения и выйти
x   дополнительные возможности (только для экспертов)
-----------------------------------------------------------------------------
Для начала создадим раздел для «boot». Также следует упомянуть, что очередность
имеет значение, чем ближе раздел к началу диска — тем больше скорость
считывания, из-за скорости вращения.
-----------------------------------------------------------------------------
Command (m for help): n
Partition type:
p     primary (0 primary, 0 extended, 4 free)
e     extended
Select (default p): p
Partition number (1-4, default 1): 1
First sector (2048-488397167): 2048
Last sector, +sectors or +size{K,M,G} (2048-488397167, default 488397167): +100M
Partition 1 of type Linux and of size 100 MiB is set
-----------------------------------------------------------------------------
Далее, следует создать «swap» (раздел подкачки). Обычно в 2 раза больше ОЗУ,
об этом я уже писал - Разбить диск для Linux.
-----------------------------------------------------------------------------
Command (m for help): n
Partition type:
p     primary (1 primary, 0 extended, 3 free)
e     extended
Select (default p): p
Partition number (1-4, default 2): 2
First sector (192780-488397167): 192780
Last sector, +sectors or +size{K,M,G} (192780-488397167, default 488397167): +4G
Partition 2 of type Linux and of size 4 GiB is set
-----------------------------------------------------------------------------
После чего, создаем корень «/usr».
-----------------------------------------------------------------------------
Command (m for help): n
Partition type:
p     primary (2 primary, 0 extended, 2 free)
e     extended
Select (default p): p
Partition number (1-4, default 3): 3
First sector (8000370-488397167): 8000370
Last sector, +sectors or +size{K,M,G} (8000370-488397167, default 488397167): +50G
Partition 3 of type Linux and of size 50 GiB is set
-----------------------------------------------------------------------------
Далее, с помощью fdisk, нам нужно создать расширенный раздел «extended».
Если вы планируете обойтись четырьмя разделами (например: /boot, swap, /usr,
/home), тогда создавайте четвертый «primary».
-----------------------------------------------------------------------------
Command (m for help): n
Partition type:
p     primary (3 primary, 0 extended, 1 free)
e     extended
Select (default e): e
Select partition 4
First sector (105659505-488397167): 105659505
Last sector, +sectors or +size{K,M,G} (105659505-488397167, default 488397167):
Using default value 488397167
Partition 4 of type Linux and of size 195 GiB is set

-----------------------------------------------------------------------------
Продолжаем дальше создавать логические разделы «logical». Создадим раздел «/tmp».
-----------------------------------------------------------------------------
Command (m for help): n
All primary partitions are in use
Adding logical partition 5
First sector (105659505-488397167): 105659505
Last sector, +sectors or +size{K,M,G} (105659505-488397167, default 488397167): +10G
Partition 5 of type Linux and of size 10 GiB is set
-----------------------------------------------------------------------------
Создадим место под «/var».
-----------------------------------------------------------------------------
Command (m for help): n
All primary partitions are in use
Adding logical partition 6
First sector (125194608-488397167): 125194608
Last sector, +sectors or +size{K,M,G} (125194608-488397167, default 488397167): +8G
Partition 6 of type Linux and of size 8 GiB is set
-----------------------------------------------------------------------------
И наконец-то, место для «/home» — домашняя директория пользователей.
-----------------------------------------------------------------------------
Command (m for help): n
All primary partitions are in use
Adding logical partition 9
First sector (203318703-488397167): 203318703
Last sector, +sectors or +size{K,M,G} (203318703-488397167, default 488397167):
Using default value 488397167
Partition 9 of type Linux and of size 145 GiB is set
-----------------------------------------------------------------------------
На этом операции с fdisk-ом не закончены.
Нам нужно установить флаг загрузочного раздела.
-----------------------------------------------------------------------------
Command (m for help): a
Partition number (1-6): 1
-----------------------------------------------------------------------------
Тип разметки файловой системы раздела: 
-----------------------------------------------------------------------------
ext2, ext3, ext4
vfat
ntfs
iso9660 и udf
proc
swap
...
-----------------------------------------------------------------------------
Далее, нам нужно изменить метку типа раздела, для «swap». Во время выбора,
fdisk нам предложит напомнить типы известных разделов, для этого после вывода
<Hex code (type L list codes): > введите большую «L» и найдите цифру нужного раздела.
-----------------------------------------------------------------------------
Command (m for help): t
Partition number (1-6): 2
Hex code (type L list codes): 82
-----------------------------------------------------------------------------
Потом, выводим наши созданные разделы на экран, убеждаемся, что все в порядке.
-----------------------------------------------------------------------------
Command (m for help): p
-----------------------------------------------------------------------------
Сохраняемся, на этом все, с fdisk закончили.
-----------------------------------------------------------------------------
Command (m for help): w
-----------------------------------------------------------------------------
Разделы созданы, осталось только ОТФАРМАТИРОВАТЬ, например:
-----------------------------------------------------------------------------
mkfs.ntfs /dev/sda1
-----------------------------------------------------------------------------
 Монтирование диска
-----------------------------------------------------------------------------
После форматирования раздел сразу же можно смонтировать и использовать.

# mkdir /photos				Создаём точку монтирования
# chmod 770 /photos			и даём директории полные права
# mount -t ext4 /dev/sdb1 /photos	И монтируем

Всё, разделы созданы и отформатированы.
-----------------------------------------------------------------------------
Cмонтированный таким образом раздел будет доступен до следующей перезагрузки
системы.
-----------------------------------------------------------------------------
Чтоб сделать подключение диска постоянным, надо прописать в файл /etc/fstab
строку с идентификатором раздела и другими параметрами.

# blkid			Узнаем идентификатор устройства

Далее откроем привычным редактором файл /etc/fstab и впишем туда строку
следующего вида:
-----------------------------------------------------------------------------
UUID=ca7e6047-670a-428f-a2da-452e8b00015b /photos/ ext4 users,defaults,umask=0 0 0
-----------------------------------------------------------------------------
Swap
-----------------------------------------------------------------------------
# swapon -s		есть ли активное swap-пространство в текущей системе
# free -m
-----------------------------------------------------------------------------
# df -h			место на иске
-----------------------------------------------------------------------------
Создание swap-файла
swapfile находится в root-каталоге (/)
-----------------------------------------------------------------------------
Способ 1: традиционный (медленный) 
-----------------------------------------------------------------------------
Чтобы указать размер файла, используйте комбинацию bs (block size – размер блока)
и count (количество блоков). Значения, которые присваиваются каждому параметру,
можно выбрать почти произвольно. Важно лишь то, каким будет результат умножения
этих значений.

К примеру, чтобы создать файл размером 4Гб, можно присвоить bs=1G, а count=4:
-----------------------------------------------------------------------------
# dd if=/dev/zero of=/swapfile bs=1G count=4
-----------------------------------------------------------------------------
# ls -lh /swapfile
-----------------------------------------------------------------------------
Способ 2: быстрый
-----------------------------------------------------------------------------
fallocate мгновенно создает файл заранее выделенного размера, не имея
необходимости писать фиктивное содержимое.
-----------------------------------------------------------------------------
# fallocate -l 4G /swapfile 
-----------------------------------------------------------------------------
Активация swap-файла
-----------------------------------------------------------------------------
# chmod 600 /swapfile		чтобы только root имел право на чтение
-----------------------------------------------------------------------------
Указать системе на swap-пространство с помощью команды:

# mkswap /swapfile
-----------------------------------------------------------------------------
Активируйте его, введя:

# swapon /swapfile
-----------------------------------------------------------------------------
Проверка:

# swapon -s
-----------------------------------------------------------------------------
Автоматизация запуска swap-файла
-----------------------------------------------------------------------------
# nano /etc/fstab

/swapfile   none    swap    sw    0   0
-----------------------------------------------------------------------------
Тонкая настройка swap
-----------------------------------------------------------------------------
Параметр swappiness задает частоту использования системой swap-пространства.
Значение swappiness выражается числом от 0 до 100, которое выражает проценты.
Если это значение близко к нулю, ядро ​​не будет передавать данные в swap без
крайней необходимости.
Система, как правило, работает продуктивнее, если не очень полагается на swap.
-----------------------------------------------------------------------------
cat /proc/sys/vm/swappiness
60
-----------------------------------------------------------------------------
чтобы установить значение 10, нужно набрать:
-----------------------------------------------------------------------------
# sysctl vm.swappiness=10
vm.swappiness = 10
-----------------------------------------------------------------------------
vfs_cache_pressure. Этот параметр  управляет склонностью ядра восстанавливать
память, которая используется для кэширования каталогов и инодов объектов.

В основном, это данные доступа к файловой системе. Как правило, найти их не
так просто, а запрашиваются они часто, так что использовать кэш-память в этом
случае очень удобно. Узнать текущее значение этого параметра можно, снова
запрашивая файловую систему proc:

cat /proc/sys/vm/vfs_cache_pressure
100
-----------------------------------------------------------------------------
Согласно текущим настройкам, система удаляет иноды из кэша слишком быстро.
Установив меньшее значение (например, 50), система будет хранить информацию
дольше:

# sysctl vm.vfs_cache_pressure=50
vm.vfs_cache_pressure = 50
-----------------------------------------------------------------------------
Чтобы значение сохранялось и после перезагрузки сервера, откройте файл
/etc/sysctl.conf в текстовом редакторе:
-----------------------------------------------------------------------------
# nano /etc/sysctl.conf

vm.swappiness=10
vm.vfs_cache_pressure = 50
-----------------------------------------------------------------------------
Расширение пространства подкачки на логическом томе LVM2
-----------------------------------------------------------------------------
Чтобы расширить логический том LVM2, отведённый для подкачки (предположим,
что этот том называется /dev/VolGroup00/LogVol01):
-----------------------------------------------------------------------------
    Запретите подкачку на соответствующем логическом томе:

    # swapoff -v /dev/VolGroup00/LogVol01
-----------------------------------------------------------------------------
    Увеличьте размер логического тома LVM2 на 256 Мбайт:

    # lvm lvresize /dev/VolGroup00/LogVol01 -L +256M
-----------------------------------------------------------------------------
    Отформатируйте новое пространство подкачки:

    # mkswap /dev/VolGroup00/LogVol01
-----------------------------------------------------------------------------
    Включите дополнительный логический том:

    # swapon -va
-----------------------------------------------------------------------------
    Проверьте, был ли логический том расширен правильно:

    # cat /proc/swaps
    # free
-----------------------------------------------------------------------------
Создание логического тома LVM2 для подкачки
-----------------------------------------------------------------------------
Чтобы добавить группу томов для подкачки (предположим, что том называется
/dev/VolGroup00/LogVol02):
-----------------------------------------------------------------------------
    Создайте логический том LVM2 размером 256 Мбайт:

    # lvm lvcreate VolGroup00 -n LogVol02 -L 256M
-----------------------------------------------------------------------------
    Отформатируйте новое пространство подкачки:

    # mkswap /dev/VolGroup00/LogVol02
-----------------------------------------------------------------------------
    Добавьте следующую запись в файл /etc/fstab:

    /dev/VolGroup00/LogVol02   swap     swap    defaults     0 0
-----------------------------------------------------------------------------
    Включите дополнительный логический том:

    # swapon -va
-----------------------------------------------------------------------------

format
-----------------------------------------------------------------------------
 mkfs -t <тип файловой системы>   , где

<тип файловой системы> - один из доступных системе типов, например
ext4, ext3, jfs, xfs ...

- имя форматируемого раздела, например /dev/sdb1. В нашем примере это выглядит
так:

sudo mkfs -t ext4 /dev/sda1
-----------------------------------------------------------------------------
Если флешка примонтировалась автоматически, то сначала нужно её отмонтировать:

sudo umount /dev/sdX

Форматируем в fat:
sudo mkfs.vfat /dev/sdX #где sdX - ваша флешка (например sdb1).

Форматируем в ext2:
sudo mkfs.ext2 /dev/sdX

Форматируем в ext3:
sudo mkfs.ext3 /dev/sdX

Форматируем в ext4:
sudo mkfs.ext4 /dev/sdX

Форматируем в MSDOS:
sudo mkfs.msdos /dev/sdX

Форматируем в ReiserFS:
sudo mkfs.reiserfs /dev/sdX

Форматируем в NTFS:
sudo mkfs.ntfs /dev/sdX
-----------------------------------------------------------------------------
file sistems
-----------------------------------------------------------------------------
 - Ext4: журналируемая файловая система, используемая Linux. Основана на
файловой системе ext3, которая является файловой системой по умолчанию во
многих дистрибутивах Linux.

- Ext3: надёжная, протестированная и многократно проверенная файловая система
Linux систем, рекордов скорости не ставит, в большинстве случаев - оптимальный
выбор.

- Xfs: лучший выбор для файловых хранилищ, особенно файлов огромных размеров
(iso-образы дистрибутивов и фильмы).

- ZFS: Эта файловая система поддерживает большие объёмы данных, объединяет
концепции файловой системы и менеджера логических дисков (томов) и физических
носителей, новаторскую структуру данных на дисках, легковесные файловые системы,
а также простое управление томами хранения данных.

Основное преимущество ZFS — это её полный контроль над физическими и логическими
носителями. Зная, как именно расположены данные на дисках, ZFS способна
обеспечить высокую скорость доступа к ним, контроль их целостности, а также
минимизацию фрагментации данных. Это позволяет динамически выделять или
освобождать дисковое пространство на одном или более носителях для логической
файловой системы. Кроме того, имеет место переменный размер блока, что лучшим
образом влияет на производительность, параллельность выполнения операций
чтения-записи, а также 64-разрядный механизм использования контрольных сумм,
сводящий к минимуму вероятность незаметного разрушения данных.
-----------------------------------------------------------------------------
zfs
-----------------------------------------------------------------------------
dkms status
modprobe zfs
-----------------------------------------------------------------------------
﻿19.2.1.2. Настройка ядра FreeBSD
-----------------------------------------------------------------------------
options         KVA_PAGES=512

Чтобы найти наиболее подходящее значение для этой опции, разделите имеющийся
объем ОЗУ, выраженный в мегабайтах, на 4. Приведенное выше значение 512
рекомендуется для систем с 2 ГБ оперативной памяти.
-----------------------------------------------------------------------------
19.2.1.3. Параметры loader.conf, которые необходимо внести в файл
	/boot/loader.conf и перезагрузить систему.
-----------------------------------------------------------------------------
vm.kmem_size="330M"
vm.kmem_size_max="330M"
vfs.zfs.arc_max="40M"
vfs.zfs.vdev.cache.size="5M"

За более деталями обратитесь к странице: http://wiki.freebsd.org/ZFSTuningGuide.
-----------------------------------------------------------------------------
19.2.2. Использование ZFS
-----------------------------------------------------------------------------
Существует стартовый механизм, позволяющий монтировать ZFS пулы во время
инициализации системы. Чтобы его задействовать, выполните следующие команды:

# echo 'zfs_enable="YES"' >> /etc/rc.conf
# /etc/rc.d/zfs start

SCSI диски с именами устройств da0, da1 и da2. 
-----------------------------------------------------------------------------
19.2.2.1. Простой дисковый пул
-----------------------------------------------------------------------------
# zpool create example /dev/da0

# df
# cd /example

Создайте файловую систему в этом пуле и активируйте сжатие данных на ней:

# zfs create example/compressed
# zfs set compression=gzip example/compressed

А вот как можно отключить сжатие данных:
# zfs set compression=off example/compressed

Для того чтобы размонтировать файловую систему:
# zfs umount example/compressed

Снова смонтируйте файловую систему:
# zfs mount example/compressed

Пул и файловая система также отображается в выводе команды mount:
# mount
example on /example (zfs, local)
example/compressed on /example/compressed (zfs, local)

файловая система сконфигурирована хранить две копии каждого блока:
# zfs create example/data
# zfs set copies=2 example/data

Уничтожьте файловые системы, потом уничтожьте пул, так как в них уже нет нужды:
# zfs destroy example/compressed
# zfs destroy example/data
# zpool destroy example

-----------------------------------------------------------------------------
19.2.2.2. ZFS RAID-Z, от трех до девяти жестких дисков.Если есть необходимость
	в использовании 10 или более дисков, подумайте над тем, чтобы разбит
	их на меньшие группы RAID-Z.
-----------------------------------------------------------------------------
# zpool create storage raidz da0 da1 da2

# zfs create storage/home

# zfs set copies=2 storage/home
# zfs set compression=gzip storage/home

Чтобы организовать в этой файловой системе хранение домашних каталогов
пользователей, скопируйте сюда их содержимое и создайте соответствующие
символические ссылки:

# cp -rp /home/* /storage/home
# rm -rf /home /usr/home
# ln -s /storage/home /home
# ln -s /storage/home /usr/home

# zfs snapshot storage/home@08-30-08

# zfs rollback storage/home@08-30-08

# ls /storage/home/.zfs/snapshot

# zfs destroy storage/home@08-30-08

# zfs set mountpoint=/home storage/home


Чтобы во время ночных запусков periodic(8) получать информацию о статусе
созданных файловых систем, выполните следующую команду:
# echo 'daily_status_zfs_enable="YES"' >> /etc/periodic.conf

-----------------------------------------------------------------------------
19.2.2.3. Восстановление RAID-Z
-----------------------------------------------------------------------------
# zpool status -x

all pools are healthy

А если есть какие-то неполадки, например диск выведен из массива,
возвращенное состояние пула будет подобным следующему:
  pool: storage
 state: DEGRADED

# zpool offline storage da1

Теперь после останова системы возможно заменить da1. Когда система загрузится
снова, выполните следующую команду чтобы заменить диск в массиве:

# zpool replace storage da1

С этого момента статус может быть проверен опять и на этот раз без флага -x:

# zpool status storage
 pool: storage
 state: ONLINE
-----------------------------------------------------------------------------
19.2.2.4. Проверка данных
-----------------------------------------------------------------------------
# zfs set checksum=off storage/home

Отключение подсчета контрольных сумм - не очень хорошая идея. Пока подсчет
включен, возможно выполнять проверки целостности данных ZFS, используя
контрольные суммы. Этот процесс известен как <<очистка (scrubbing)>>. Чтобы
проверить целостность данных пула storage, выполните следующую команду:

# zpool scrub storage

 scrub: scrub completed with 0 errors on Sat Aug 30 19:57:37 2008

За более подробной информацией обратитесь к страницам справочника zfs(8) и zpool(8).

-----------------------------------------------------------------------------
ext4
-----------------------------------------------------------------------------
при создании файловой системы с нуля используется mkfs.ext3 с ключом -E test_fs 
# mkfs.ext3 -E test_fs file.img 

для подготовки существующей файловой системы ext3 к монтированию использовать debugfs 
# debugfs -w file.img 

при монтировании использовать тип файловой системы ext4dev 
# mount -t ext4dev -o loop file.img /mnt
-----------------------------------------------------------------------------

# uname -a
Linux dhcp 2.6.25-2-xen-686 #1 SMP Tue May 27 17:30:39 UTC 2008 i686 GNU/Linux

# modinfo ext4dev
filename:       /lib/modules/2.6.25-2-xen-686/kernel/fs/ext4/ext4dev.ko

Создаём пустой файл размером 100MB, который чуть позже будет форматироваться под ext4.
# dd if=/dev/zero of=file.img count=100 bs=1024k

Создаём обычную файловую систему ext3:
# mkfs.ext3 file.img 

# modprobe loop

# apt-get install udev

Добавить пометку, извещающую систему о том, что файловую систему можно смело
монтировать как ext4 можно так:
# debugfs -w file.img 

Вообще, можно было попросить ставить пометку ещё при создании файловой системы.
Для этого нужно было использовать ключ -E test_fs:
# mkfs.ext3 -E test_fs file.img 


# mount -t ext4dev -o loop file.img /mnt

# mount
/root/file.img on /mnt type ext4dev (rw,loop=/dev/loop0)

# umount /mnt

-----------------------------------------------------------------------------
mount
-----------------------------------------------------------------------------
посмотреть какие файловые системы уже смонтированы в системе

mount
df -a
cat /etc/mtab
-----------------------------------------------------------------------------
sync	говорит ядру, что необходимо немедленно записать всю информацию
	находящуюся в буферной памяти на соответствующие физические устройства
-----------------------------------------------------------------------------
mount /dev/sdb1 /hdd1000
-----------------------------------------------------------------------------
nano /etc/fstab		чтобы данный раздел HDD монтировался автоматически
			при загрузке ОС, то откройте файл

/dev/sdb1 /hdd1000 auto defaults 0 0	и добавьте туда строку
-----------------------------------------------------------------------------
mount [options] <-t type> [-o mount options] <device> <mounting point>
$ mount -t ext2 /dev/hdb1 /mnt
-----------------------------------------------------------------------------
mount ключи -t тип_файловой_системы -o опции_файловой_системы устройство каталог_назначения 


    ключи - глобальные опции для команды,
    -t - задаёт тип файловой системы,
    -o - опции для заданной файловой системы,
    устройство - путь к физическому устройству или каталогу,
    каталог_назначения - каталог назначения или "куда" будет монтироваться
			устройство (каталог).

Если указаны устройство и каталог_назначения, то команда не читает опции в /etc/fstab . 
-----------------------------------------------------------------------------
umount <mount point|device>
$ umount /mnt
$ umount /dev/hdb1
   -f force
-----------------------------------------------------------------------------
umount ключи -t тип_файловой_системы -o опции_файловой_системы 
-----------------------------------------------------------------------------
# mount -o rw /dev/sdа1 /mnt	Включим возможность чтения и записи в 
				файловую систему
# mount -o ro /dev/sdа1 /mnt	Аналогично можно отключить запись и сделать
				принудительно "только чтение"
# mount -n -o remount,rw /	Перемонтировать файловую систему ro в rw
-----------------------------------------------------------------------------
# mount -t iso9660 -o ro /dev/sr0 /mnt	Монтирование обычного CD\DVD диска
					в /mnt

# mount -t udf -o ro /dev/sr0 /mnt	Если на диске имеются файлы с размером
					больше 2048 мегабайт, то диск
					записывается в файловой системе udf

-----------------------------------------------------------------------------
 Монтирование "виндовс-шары"
-----------------------------------------------------------------------------
# mount -t cifs -o rw,username=user,password=pass //ftp.server.ru/share /mnt

Где:

    cifs - файловая система SMB,
    user= и password= - идентификационные параметры подключения к "шаре",
    //ftp.server.ru/share - полный DNS или WINS путь к каталогу шары. Обратите
			внимание, что в Windows слэши располагаются наоборот.

Если "шара" предоставляет доступ всем (без запроса логина\пароля) в качестве
параметров опций user и password могут быть произвольные имена или guest,
иначе нужно указать именно те, с которыми производится доступ. Пример монтирования
с гостевыми параметрами:

# mount -t cifs -o rw,guest //ftp.server.ru/share /mnt

# mount -t cifs -o rw,username=user,password=pass,iocharset=utf8 //ftp.server.ru/share /mnt
запись и чтение с ресурса может делать только root.

# mount -t cifs -o rw,username=user,password=pass,iocharset=utf8,uid=localuser,gid=localgroupuser //ftp.server.ru/share /mnt
Теперь этот локальный пользователь сможет читать/модифицировать файлы и
каталоги (если на сервере есть соответствующие разрешения). 
-----------------------------------------------------------------------------
Опции выбора кодировки символов
-----------------------------------------------------------------------------
# mount -t vfat -o rw,iocharset=utf8 /dev/sdс1 /mnt	Монтирование "флешки",
							записанной в Windows
				koi8-r
	 			cp866
-----------------------------------------------------------------------------
Опции владельцев и прав доступа
-----------------------------------------------------------------------------
 По умолчанию, для каждой файловой системы, при монтировании, приняты
предопределённые права. Так, например, при монтировании NTFS-раздела, без
дополнительных опций, все файлы и каталоги "видятся" в linux с правами доступа
root:root 777 и при копировании файлов возникает две проблемы:

    проблема снятия разрешения "на выполнение" для обычных файлов;
    проблема выставления разрешения "на запись" в каталоги примонтированной
		системы для обычного пользователя.

Многих очень часто вводит в заблуждение, что установка -o rw вроде как даёт
право на чтение\запись, а собственно записать ничего нельзя. Дело в том,
что -o rw всего-лишь даёт "возможность", но у пользователя, внутри
примонтированной системы, также должны быть права "на запись".

-----------------------------------------------------------------------------
 # mount -t ntfs -o rw,uid=1000,gid=1000,fmask=0111 /dev/sdd1 /mnt

Здесь:

    uid=1000 - все файлы примонтированной системы будут принадлежать
		пользователю с uid=1000 (смотрим /etc/passwd),
    gid=1000 - все файлы примонтированной системы будут принадлежать группе
		с gid=1000 (смотрим /etc/group),
    fmask=0111 - маска убирает от прав 777 по 111 (математически это выглядит
		так: 777-111=666).

Кстати, есть ещё опция dmask, с помощью которой можно присваивать конкретные
права только каталогам. Если fmask и dmask действуют по отдельности, то umask
объединяет их и действует для каталогов и для файлов одинаково. 
-----------------------------------------------------------------------------
Монтирование каталогов в каталоги
-----------------------------------------------------------------------------
# mount --bind /share1 /home/user/Docs
-----------------------------------------------------------------------------
Монтирование iso и других файлов образов в каталог
-----------------------------------------------------------------------------
# mount -t iso9660 -o loop,ro /home/user/debian-508-i386-DVD-2.iso /mnt
# mount -t vfat -o loop,ro /home/user/flash.img /mnt
# mount -t ext3 -o loop,ro /home/user/hd_backup.bin /mnt
Для постоянного монтирования
 /etc/fstab -> /путь/к_папке_в_ФС    /другой_путь    none    bind    0    0

-----------------------------------------------------------------------------
fstab
-----------------------------------------------------------------------------
/etc/fstab
/etc/mtab
ls -l /dev/disk/
ls -l /dev/disk/by-uuid/
-----------------------------------------------------------------------------
#/etc/fstab: static file system information.
#
# proc /proc proc defaults 0 0
# / was on /dev/sda1 during installation
UUID=8d6bccd3-0bdf-487c-8b92-70e5b65aa756 / ext3 relatime,errors=remount-ro 0 1
# swap was on /dev/sda8 during installation
UUID=49d78fcc-9bbc-43a6-a750-b0d85921a04c none swap sw 0 0
# /media/disk on /dev/sda2
UUID=d822a992-8a4f-48f0-8b7d-a529af066106 /media/disk ext3 nodev,rw,user 0 0
/dev/scd0 /media/cdrom0 udf,iso9660 user,noauto,exec,utf8 0 0
/dev/fd0 /media/floppy0 auto rw,user,noauto,exec,utf8 0 0
-----------------------------------------------------------------------------

UUID=8d6bccd3-0bdf-487c-8b92-70e5b65aa756 / ext3 relatime,errors=remount-ro 0 1
-----------------------------------------------------------------------------
1. Первое поле содержит указание раздела, файловая система которого будет
монтироваться в системе. Раздел блочного устройства можно указать непосредственно
- /dev/sda1 или через параметр UUID. Можно также указать метку раздела.
В первом случае наша строка выглядела бы так:

/dev/sda1 / ext3 relatime,errors=remount-ro 0 1
-----------------------------------------------------------------------------
2. Второе поле в файле /etc/fstab содержит точку монтирования. В нашем примере
раздел с UUID=8d6bccd3-0bdf-487c-8b92-70e5b65aa756 (или /dev/sda1) монтируется
к корню файловой системы - /.
-----------------------------------------------------------------------------
3. В третьем поле указывается тип монтируемой файловой системы. Посмотреть
перечень поддерживаемых файловых систем можно в справке 
-----------------------------------------------------------------------------
man fstab или man mount.
-----------------------------------------------------------------------------
ext2, ext3, ext4
vfat
ntfs
iso9660 и udf
proc
swap
auto - в этом случае будет сделана попытка автоматически определить тип файловой системы.
-----------------------------------------------------------------------------
cat /proc/filesystems
-----------------------------------------------------------------------------
4. В четвертом поле файла /etc/fstab указываются дополнительные опции монтирования.
man fstab
 FILESYSTEM INDEPENDENT MOUNT OPTIONS
 FILESYSTEM SPECIFIC MOUNT OPTIONS
Опции задаются через запятую.
-----------------------------------------------------------------------------
sync - операции ввода/вывода выполняются синхронно. То есть информация
	немедленно записывается на устройство без ожидания в буферной памяти.
async - операции ввода/вывода выполняются асинхронно.
atime - обновлять время доступа к файлу при каждом обращении к файлу.
noatime - не обновлять время доступа к файлу.
auto - при выполнении команды mount -а будут автоматически смонтированы все
	системы с ключом auto. Команда mount -a выполняется в загрузочных
	скриптах системы, поэтому можно говорить о том, что задание опции auto
	позволит автоматически монтировать файловые системы при загрузке системы.
noauto - файловые системы с такой опцией будут монтироваться только вручную по команде mount.
exec - опция разрешает запускать исполняемые файлы, которые расположены на
	данном файловом разделе.
noexec - опция запрещает запускать исполняемые файлы.
dev - опция указывает, что файлы-устройства следует интерпретировать как
	файлы-устройства.
nodev - файлы-устройства будут интерпретироваться как обычные файлы.
	Применяется если необходимо смонтировать раздел, с другой Linux-системой.
users - опция указывает, что монтировать и размонтировать разделы могут
	обычные пользователи.
user - монтировать раздел может любой пользователь, но размонтировать может только
	тот кто смонтировал или root. Т.е. если пользователь test смонтирует
	раздел, то только test и root сможет размонтировать его.
nouser - монтировать раздел может только пользователь root.
suid - опция разрешает применять биты setuid и setgid.
nosuid - опция запрещает применять биты setuid и setgid. Если такие биты
	установлены они не будут приниматься во внимание.
rw - монтировать файловую систему в режиме чтения/записи.
ro - монтировать файловую систему только в режиме чтения.
defaults - опция устанавливает опции по умолчанию: rw, suid, dev, exec, auto, nouser, async.
-----------------------------------------------------------------------------
Для файловой системы vfat.

uid= - установить владельца для объектов файловой системы.
gid= - установить группу владельца для объектов файловой системы.
umask - установить параметр umask.
dmask - установить параметр umask только для каталогов.
fmask - установить параметр umask только для файлов.
codepage= - указывает в какой кодовой странице сохраняются имена объектов.
		Для операционный систем Windows, например, этот параметр
		устанавливают в cp1251.
iocharset - указывает с какой кодовой страницей работает наша система.
		Как правило это utf8. То есть эти два параметра показывают
		как нужно перекодировать мена файлов.
-----------------------------------------------------------------------------
mount -o remount,rw /dev/sda1 /
-----------------------------------------------------------------------------
===============
L5.COMMANDS
===============
-----------------------------------------------------------------------------
curl
-----------------------------------------------------------------------------
whois
-----------------------------------------------------------------------------
dig
-----------------------------------------------------------------------------
nslookup
-----------------------------------------------------------------------------
traceroute
-----------------------------------------------------------------------------
find,grep/sed,tail/less/more/cat/tac/head,locate,whereis,which
-----------------------------------------------------------------------------
tar,zip
-----------------------------------------------------------------------------
lsof /media/cdrom0 покажет какие файлы открыты из каталога /media/cdrom0 и кем
-----------------------------------------------------------------------------
cat /proc/filesystems
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------

-----------------------------------------------------------------------------

===============
L6.LAEMP
===============
-----------------------------------------------------------------------------
MySQL/phpMyAdmin
-----------------------------------------------------------------------------
###########
#phpMyAdmin
###########
---------------------------------------------------------------
/etc/phpMyAdmin.conf
/etc/httpd/conf.d/phpMyAdmin.conf
/etc/nginx/conf.d/phpmyadmin.inc
/home/admin/conf/web/httpd.conf,shttpd.conf,nginx.conf,snginx.conf
php_admin_value open_basedir /usr/share:/usr/share/phpMyAdmin:/usr/share/pear:/usr/share/php:/var/lib/phpMyAdmin:
./htaccess
php.ini:memory_limit = 12M
php -m
chown -R
chmod -R 
---------------------------------------------------------------
tail -f /var/log/httpd/domains/default.domain.error.log
---------------------------------------------------------------
-----------------------------------------------------------------------------
	MySQL
-----------------------------------------------------------------------------
Installation
	Update + L8.Update > mysql
-----------------------------------------------------------------------------
Configuration
	Schema/Схема
		INFORMATION_SCHEMA
		PERFORMANCE_SCHEMA
	Engine/Движок
	Charset/Collation/Кодировки
		Перекодировка Charset
	innodb bitrix
-----------------------------------------------------------------------------
Optimization
	HDD
	mysqloptimize
	MysqlTuner
	Swap
	Кеширование запросов
	Увеличение количества одновременных подключений
-----------------------------------------------------------------------------
Monitoring
-----------------------------------------------------------------------------
Commands
	Смена пароля
	Восстановление root доступа
	калькуляция и отображение размера баз данных
	Myisamchk и mysqlcheck
	Mysqlbinlog
	Warning/Socket
-----------------------------------------------------------------------------
Backup/Restore
	InnoDB
		Cold backup
		Logical backup 
	Script
	SypexDumper программа
	Консольный дампер
-----------------------------------------------------------------------------
Replication
	Manual
	Setting Up Replication with Existing Data
	Choosing a Method for Data Snapshots
	Creating a Data Snapshot Using mysqldump
	Creating a Data Snapshot Using Raw Data Files
	Switching Masters During Failover
		dynamic DNS
	Алгоритм репликации
	Создание репликации(lvm backup)
	Пример конфигурации Мастера
-----------------------------------------------------------------------------
=============================================================================
####################
#Задел для изучения
####################
-----------------------------------------------------------------------------
Установка/Старт/Стоп/Автозапуск/Комады/
	mysql
	mysqldump
	mysqlbinlog
	mysqladmin
-----------------------------------------------------------------------------
Конфиги
Логи
БД
-----------------------------------------------------------------------------
	Моделирование и нормализация простой БД (включая физическое проектирование)
	Использование базы данных INFORMATION_SCHEMA для получения информации о метаданных
	leverage PERFORMANCE_SCHEMA tables to identify and diagnose performance problems
	наполнение БД из внешних файлов
	Таблица
	Движок
	Кодировка
	Типы данных
	Нормализация базы данных, ключи, ключевые атрибуты
	Зависимости и отношения между таблицами БД
-----------------------------------------------------------------------------
Запросы
-----------------------------------------------------------------------------
	Выражения SQL, операторы определения структуры данных
	Индексов и ограничений. Добавление и удаление индексов из таблицы
	Выражения (операторы) манипулирования данными
    		Оператор SELECT и выборка данных
		Предикаты (клаузулы) WHERE, ORDER
		Агрегирующие функции (агрегаты)
		Ограничение выборки
		Группировка данных
		Предикат HAVING
		Объединение таблиц
	Объединение запросов и манипулирование данными	
		Объединение запросов (UNION)
		Использование подзапросов и множеств значений
        	Временные таблицы и просмотры
		Обновление и удаление данных
	Хранимые процедуры и триггеры 
		Обеспечение ссылочной целостности
	Транзакции и типы хранилищ MySQL 
		Блокировки и их типы
		Понятие транзакции, свойства ACID
		Выбор оптимального хранилища
	Оптимизировать запросы и конфигурацию	
		Разделение прав пользователей
		Оптимизация запросов
		Оптимизация баз данных
		Оптимизация конфигурации сервера
-----------------------------------------------------------------------------
Сервисные программы/Workbench 5.2.x 
Резервное копирование/Возстановление данных
	Проверки и восстановление таблиц
-----------------------------------------------------------------------------
Репликация
=============================================================================
-----------------------------------------------------------------------------
	Installation
-----------------------------------------------------------------------------
http://dev.mysql.com/downloads/repo/yum/. 
sudo rpm -Uvh platform-and-version-specific-package-name.rpm
sudo rpm -Uvh mysql57-community-release-el6-n.noarch.rpm
yum repolist all | grep mysql
-----------------------------------------------------------------------------
shell> sudo yum-config-manager --disable mysql57-community
shell> sudo yum-config-manager --enable mysql56-community
-----------------------------------------------------------------------------
 Besides using yum-config-manager or the dnf config-manager command, you can
also select a series by editing manually the /etc/yum.repos.d/mysql-community.repo
file. This is a typical entry for a release series' subrepository in the file:

[mysql57-community]
name=MySQL 5.7 Community Server
baseurl=http://repo.mysql.com/yum/mysql-5.7-community/el/6/$basearch/
enabled=1
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql
-----------------------------------------------------------------------------
yum repolist enabled | grep mysql
sudo yum install mysql-community-server
sudo systemctl start mysqld.service
sudo systemctl enable mysqld.service
sudo systemctl status mysqld.service
-----------------------------------------------------------------------------
MySQL Server Initialization (for MySQL 5.7 only): At the initial start up of
the server, the following happens, given that the data directory of the server
is empty:
-----------------------------------------------------------------------------
    The server is initialized.

    An SSL certificate and key files are generated in the data directory.

    The validate_password plugin is installed and enabled.
The validate_password plugin serves to test passwords and improve security.
The plugin exposes a set of system variables that enable you to define
password policy. 
-----------------------------------------------------------------------------
    A superuser account 'root'@'localhost' is created. A password for the
superuser is set and stored in the error log file. To reveal it, use the
following command:
-----------------------------------------------------------------------------
    shell> sudo grep 'temporary password' /var/log/mysqld.log
    shell> mysql -uroot -p
    mysql> ALTER USER 'root'@'localhost' IDENTIFIED BY 'MyNewPass4!';
    shell> mysql_secure_installation
    sudo systemctl restart mysqld.service
-----------------------------------------------------------------------------
shell> yum --disablerepo=\* --enablerepo='mysql*-community*' list available
shell> sudo yum install package-name
-----------------------------------------------------------------------------
UPDATE
-----------------------------------------------------------------------------
For important information about upgrading from MySQL 5.7 to 8.0, see Upgrading
from MySQL 5.7 to 8.0. 
https://dev.mysql.com/doc/refman/8.0/en/upgrading-from-previous-series.html
-----------------------------------------------------------------------------
shell> sudo yum update mysql-server
-----------------------------------------------------------------------------
 Once the server restarts, run mysql_upgrade to check and possibly resolve
any incompatibilities between the old data and the upgraded software.
mysql_upgrade also performs other functions; see mysql_upgrade —
Check and Upgrade MySQL Tables for details. 
https://dev.mysql.com/doc/refman/5.7/en/mysql-upgrade.html
-----------------------------------------------------------------------------
 mysql_upgrade examines all tables in all databases for incompatibilities with
the current version of MySQL Server. mysql_upgrade also upgrades the system
tables so that you can take advantage of new privileges or capabilities that
might have been added.

If mysql_upgrade finds that a table has a possible incompatibility, it performs
a table check and, if problems are found, attempts a table repair. If the table
cannot be repaired, see Section 2.11.3, “Rebuilding or Repairing Tables or
Indexes” for manual table repair strategies.

You should execute mysql_upgrade each time you upgrade MySQL.
mysql_upgrade needed server and client.
-----------------------------------------------------------------------------
shell> sudo yum list installed | grep "^mysql"
shell> sudo yum update package-name
-----------------------------------------------------------------------------
yum install mysql-server php5-mysql
sudo /usr/bin/mysql_secure_installation
-----------------------------------------------------------------------------
	Configuration
-----------------------------------------------------------------------------
/etc/my.cnf
/var/lib/mysql/*
/var/log/mysql.log
/var/log/mysql-slow.log
-----------------------------------------------------------------------------
DB
-----------------------------------------------------------------------------
Scheme	-	Схема
MySql	-	Административная
	Table
	user - Пользователи	DB Назначенные БД	Host - local/IP/% 
-----------------------------------------------------------------------------
	Schema/Схема
-----------------------------------------------------------------------------
Как спроектировать схему базы данных
-----------------------------------------------------------------------------
http://eax.me/database-design/
-----------------------------------------------------------------------------
		INFORMATION_SCHEMA
-----------------------------------------------------------------------------
Это виртуальная база, формируется во время запуска сервера), содержащая
метаданные баз данных, т.е. информацию о структуре баз данных. Доступна
только для чтения.
-----------------------------------------------------------------------------
		PERFORMANCE_SCHEMA
-----------------------------------------------------------------------------
является статической, используется разработчиками, для повышения производительности.
Есть свой Engine.
-----------------------------------------------------------------------------
	Engine/Движок
-----------------------------------------------------------------------------
MyISAM: Движок по умолчанию. Не поддерживает транзакций, средняя надежность
хранения данных. Превосходная производительность чтения данных для интенсивных
приложений. Большинство веб сервисов и хранилищ данных активно используют MyISAM. 
-----------------------------------------------------------------------------
HEAP: Все в памяти. Очень быстрый поиск данных, однако все они хранятся только
в памяти и будут потеряны при остановке сервера. Великолепно подходит для
временных таблиц. 
-----------------------------------------------------------------------------
Archive: Используется для хранения больших объемов данных без индексов,
занимая меньший размер.
-----------------------------------------------------------------------------
Merge: Коллекция MyISAM таблиц логически объединенных вместе для единого
представления. 
-----------------------------------------------------------------------------
InnoDB: Транзакционный тип движка, применяемый при интенсивных операциях
записи, спасибо возможности блокировки уровня строк таблицы. Великолепная
восстанавливаемость и высокая надежность хранения данных. Движок InnoDB
был приобретен Oracle в 2005 году. 
-----------------------------------------------------------------------------
NDB: Кластерный движок — данные автоматически разделяются и реплицируются по
различным машинам, именуемым — дата узлы. Применяется для приложений, которые
требуют высокой производительности с наивысшей степенью доступности. NDB
хорошо работает на системах требующих высокой отдачи на операциях чтения. Для
«тяжелых» приложений требующих активной записи в конкурирующей среде
рассмотрите вариант с InnoDB. 
-----------------------------------------------------------------------------
 Важные замечания по MyISAM таблицам:

    Таблицы могут быть повреждены. Ежедневно архивируйте Ваши данные или
установите еще один MySQL сервер для выполнения репликаций.
    Включите авто-восстановление (auto-repair) в настройках Вашего сервера (my.cnf):
    myisam-recover=backup,force
    или рассмотрите возможность выполнения ежедневной автоматической
проверки таблиц баз данных.
    Очень быстрое чтение данных (через SELECT)
    Конкурирующие записи полностью блокируют таблицы. Переключите все, что
возможно, на оффлайн обработку записей сериями, что-бы не загружать движок
сервера баз данных. (Оффлайн обработка — золотое правило, применимое для всех типов таблиц)


.frm — структура таблицы, этот файл содержит информацию об именах и типах столбцов и индексов;
.MYD — в этом файле содержатся данные таблицы;
.MYI — в этом файле содержатся индексы таблицы.

Таблицы MyISAM обладают рядом особенностей:
1. Данные хранятся в кроссплатформенном формате, что позволяет переносить базы
с сервера непосредственным копированием файлов, минуя промежуточные формы.
2. Максимальное количество индексов — 64 (с версии 4.1.2). Каждый индекс может
быть максимум из 16 столбцов.
3. С версии MySQL 4.1, для каждого текстового столбца может быть задана своя кодировка.
4. Допускается индексирование текстовых столбцов, в том числе и переменной длины.
5. Поддерживается полнотекстовый поиск.
6. Таблицы имеют специальный флаг, указывающий на правильность закрытия таблицы.
Если сервер был остановлен аварийно, то при загрузке незакрытые флаги будут
сигнализировать о возможных поврежденных таблицах и сервер попытается автоматически
их проверить и восстановить.

Создание MyISAM таблицы с явным указанием типа:

create table teble1 (i INT) ENGINE = MyISAM;
//Или
create table teble1 (i INT) TYPE = MyISAM;

https://kbss.ru/blog/bd_mysql/82.html
-----------------------------------------------------------------------------
 Важные замечания по InnoDB таблицам:

    Поддержка ACID транзакций. Встроенная отказоустойчивость данных, равная
надежности 99.999%. Блокировка уровня строк (сравните с полной блокировкой всей
таблицы в MyISAM) означает обеспечение быстрой записи конкурирующих операций.
    Выполнение «SELECT Count(*) FROM table» без индексов выполняется в InnoDB
очень медленно и требует сканирования всей таблицы. (Для MyISAM эта операция
ничего не стоит, потому что он хранит внешние записи счетчиков для каждой таблицы).
    Если Вам часто необходима операция «SELECT COUNT(*)» на таблицах InnoDB,
создайте MySQL триггер на вставку/удаление, который будет увеличивать/уменьшать
счетчик, когда данные добавляются или удаляются из таблицы.
    Резервирование (бакапирование)
    Простое архивирование всех файлов таблиц для InnoDB невозможно.
    MySQLDump резервирует InnoDB очень медленно. (Если Вы настаиваете на таком
резервировании, включите флаг: —opt —compress)
    Быстрое жизнеспособное резервирование, которое так-же может быть использовано
как новая «ведомая» (slave) машина, это InnoDB Hot Backup.
    Восстановление
    В InnoDB встроена поддержка восстановления, которая работает в 99% случаев
автоматически. Никогда не трогайте .frm или .ibd файлы в надежде «помочь»
восстановлению базы данных. Если встроенное восстановление не сработало,
переключайтесь на «ведомый» сервер и восстанавливайте основной из архивов.
    LOAD DATA INFILE в InnoDB работает очень медленно. Для операций LOAD DATA
присмотритесь к использованию MyISAM таблиц.
    InnoDB меньше, чем MyISAM, прощает выполнение запросов построенных не на
индексах. InnoDB отправит Вас в «школу», что-бы быть уверенным, что каждый запрос
или обновление будет запущено на индексах. Выполните непроиндексированный запрос
и Вы поплатитесь за это временем исполнения.
    Никогда не изменяйте my.cnf InnoDB лог файл, когда запущен сервер баз данных.
Вы разрушите последовательный лог-номер (log sequence number) оставшись без

возможность восстановления.
    Для увеличения производительности InnoDB, присмотритесь к использованию
следующих настроек (my.cnf):

    innodb_open_files = 500
    innodb_file_per_table
    innodb_buffer_pool_size = 250M
    innodb_flush_log_at_trx_commit = 2
    innodb_thread_concurrency =8
    innodb_lock_wait_timeout = 500
    interactive_timeout = 20
    back_log = 75
    table_cache = 300
    thread_cache = 32
    thread_concurrency = 8
    wait_timeout = 30
    connect_timeout = 10


InnoDB

    Тип таблиц InnoDB разработан компанией Innobase Oy. Таблицы такого типа
предоставляют высокую производительность и устойчивое хранение данных в
таблицах объёмом до 1 Тбайт и нагрузкой на сервер до 800 вставок/обновлений
в секунду.

Особенности типа InnoDB:
1. Все таблицы хранятся в едином табличном пространстве, поэтому имена таблиц
должны быть уникальны.
2. Хранение данных в едином табличном пространстве позволяет снять ограничение
на объём таблиц. Файл с таблицами может быть разбит на несколько частей и
распределён по нескольким дискам или даже хостам.
3. Таблицы поддерживают автоматическое восстановление после сбоя.
4. Поддерживаются транзакции.
5. Этот тип таблиц в MySQL единственный, который поддерживает каскадное
удаление и внешние ключи.
6. Выполняется блокировка на уровне отдельных записей.
7. Имеется расширенная поддержка кодировок.

Пример создания таблицы InnoDB:

create table tab1 (field1 INT, field2 CHAR(10), INDEX (field1)) ENGINE=InnoDB;

-----------------------------------------------------------------------------
InnoDB data files
----------------------------------------------------------------------------- 
	ibdata files 
	.ibd files
InnoDB log files
	ib_logfile files
	gbichot2-bin.000001
-----------------------------------------------------------------------------
	Charset/Collation/Кодировки
-----------------------------------------------------------------------------
Each character set has a default collation.
-----------------------------------------------------------------------------
http://sqlinfo.ru/articles/info/2.html
-----------------------------------------------------------------------------
mysql> SHOW CHARACTER SET;
mysql> SHOW CHARACTER SET LIKE 'latin%';
mysql> SHOW COLLATION WHERE Charset = 'latin1';

/etc/my.cnf
 [client]:
default-character-set=cp1251

[mysqld]:
character-set-server = cp1251
collation-server = cp1251_general_ci
init-connect="SET NAMES cp1251"
skip-character-set-client-handshake
skip-name-resolve
log=/var/log/mysql.log


# touch /var/log/mysql.log
# chown mysql:mysql /var/log/mysql.log

/etc/newsyslog.conf необходимо добавить следующую строку:
/var/log/mysql.log      mysql:mysql     600  2     *    $W6D0   JB     /var/db/mysql/hostname.pid

GRANT ALL PRIVILEGES ON *.* TO 'username'@'localhost' IDENTIFIED BY 'user_pass' WITH GRANT OPTION;
-----------------------------------------------------------------------------
	Sypex Viewer
-----------------------------------------------------------------------------
	Исправление и преобразование кодировок таблиц MySQL
-----------------------------------------------------------------------------
https://sypex.net/ru/encoding/
-----------------------------------------------------------------------------
 Character Set - транслируется как "кодировка", а Collation - сравнение.
Сравнение - это правила сравнения букв кодировки. Сравнения работают только в
рамках кодировки, и нельзя сравнивать данные в латинице по правилам кирилицы.
Поясню на примере: мы, как увидим позже, внесли данные в таблицу на латинице,
а сортировать нужно на кирилице, для чего можно использовать ключевое слово collate:
-----------------------------------------------------------------------------
mysql> select * from `test` order by `field` collate cp1251_general_ci DESC;
ERROR 1253 (42000): COLLATION 'cp1251_general_ci' is not valid for CHARACTER SET 'latin1'
mysql>
-----------------------------------------------------------------------------
mysql> show collation like 'latin1%';
-----------------------------------------------------------------------------
+-------------------+---------+----+---------+----------+---------+
| Collation         | Charset | Id | Default | Compiled | Sortlen |
+-------------------+---------+----+---------+----------+---------+
| latin1_german1_ci | latin1  |  5 |         | Yes      |       1 |
| latin1_swedish_ci | latin1  |  8 | Yes     | Yes      |       1 |
| latin1_danish_ci  | latin1  | 15 |         | Yes      |       1 |
| latin1_german2_ci | latin1  | 31 |         | Yes      |       2 |
| latin1_bin        | latin1  | 47 |         | Yes      |       1 |
| latin1_general_ci | latin1  | 48 |         | Yes      |       1 |
| latin1_general_cs | latin1  | 49 |         | Yes      |       1 |
| latin1_spanish_ci | latin1  | 94 |         | Yes      |       1 |
+-------------------+---------+----+---------+----------+---------+
8 rows in set (0.00 sec)


-----------------------------------------------------------------------------
mysql> show create table `test`;
+-------+-------------------------------------------------+
| Table | Create Table                                    |
+-------+-------------------------------------------------+
| test  | CREATE TABLE `test` (
  `field` varchar(60) DEFAULT NULL
) ENGINE=MyISAM DEFAULT CHARSET=latin1                    |
+-------+-------------------------------------------------+
1 row in set (0.00 sec)
-----------------------------------------------------------------------------
mysql> alter table `test` charset "cp1251";
Query OK, 3 rows affected (0.02 sec)
Records: 3  Duplicates: 0  Warnings: 0

Ок! Проверяем, что получилось...

mysql> select * from `test` order by `field` collate cp1251_general_ci DESC;
ERROR 1253 (42000): COLLATION 'cp1251_general_ci' is not valid for CHARACTER SET 'latin1'
-----------------------------------------------------------------------------
Хм.. опять та же ошибка, но откуда ей взяться?!.. 
-----------------------------------------------------------------------------
mysql> show create table `test`;
+-------+-------------------------------------------------+
| Table | Create Table                                    |
+-------+-------------------------------------------------+
| test  | CREATE TABLE `test` (
  `field` varchar(60) CHARACTER SET latin1 DEFAULT NULL
) ENGINE=MyISAM DEFAULT CHARSET=cp1251                    |
+-------+--------------------------
-----------------------------------------------------------------------------
Ого, структура таблицы резко изменилась, теперь у неё задана одна кодировка,
а у поля совсем другая.. :(( Порыв ещё мануал, можно изменить и кодировку столбца
-----------------------------------------------------------------------------
mysql> alter table `test` modify `field` varchar(60) charset "cp1251";
Query OK, 3 rows affected, 3 warnings (0.02 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql> show create table `test`;
+-------+------------------------------------------+
| Table | Create Table                             |
+-------+------------------------------------------+
| test  | CREATE TABLE `test` (
  `field` varchar(60) DEFAULT NULL
) ENGINE=MyISAM DEFAULT CHARSET=cp1251             |
+-------+------------------------------------------+
1 row in set (0.01 sec)
-----------------------------------------------------------------------------
Ну вот!!! Злой кодировки latin1 нет и в помине, можно проверять наша таблица)))

mysql> select * from `test` order by `field` collate cp1251_general_ci DESC;
+----------+
| field    |
+----------+
| ???????? |
| ?????    |
| ????     |
+----------+
3 rows in set (0.00 sec)
-----------------------------------------------------------------------------
И вот тот страшный удар граблями, который так долго оттягивался! Внимательный
читатель мог заметить, что когда была сделана попытка принудительно сменить
кодировку столбца, содержащего данные в latin1, то на каждую запись,
содержащую русские буквы, у MySQL был варнинг! Это был крик о том, что сервер
не знает, каким образом можно перевести данные из latin1 в cp1251, ну и лучшего
способа, чем заменить символы не latin1 вопросиками, он не нашёл :))).
Теперь вместо кирилицы в базе содержатся вопросики.
-----------------------------------------------------------------------------
На самом деле, ситуация, когда изначально выставлена неправильная кодировка,
встречается сплошь и рядом. Симптомы можно выявить следующим образом:

mysql> show variables like "char%";
+--------------------------+----------------------------------+
| Variable_name            | Value                            |
+--------------------------+----------------------------------+
| character_set_client     | latin1                           |
| character_set_connection | latin1                           |
| character_set_database   | latin1                           |
| character_set_filesystem | binary                           |
| character_set_results    | latin1                           |
| character_set_server     | latin1                           |
| character_set_system     | utf8                             |
| character_sets_dir       | /usr/local/share/mysql/charsets/ |
+--------------------------+----------------------------------+
8 rows in set (0.02 sec)
-----------------------------------------------------------------------------

    character_set_client - кодировка, в которой данные будут поступать от клиента
    character_set_connection - кодировка по умолчанию для всего, что в рамках соединения не имеет кодировки
    character_set_database - кодировка по умолчанию для баз
    character_set_filesystem - кодировка для работы с файловой системой (LOAD DATA INFILE, SELECT ... INTO OUTFILE, и т.д.)
    character_set_results - кодировка, в которой будет выбран результат
    character_set_server - кодировка, в которой работает сервер
    character_set_system - кодировка, в которой задаются идентификаторы MySQL, всегда UTF8
    character_sets_dir - папка с кодировками

-----------------------------------------------------------------------------
ВАЖНО: Если character_sets_dir установлена неверно, то работа с кодировками
будет под угрозой. Не пытайтесь менять её значение, если вы неуверены в своих
силах. Если вы системный администратор, то перед установкой лучше ознакомиться
с мануалом. 
-----------------------------------------------------------------------------
Наиболее значимые для простых пользователей следующие переменные:
character_set_client
character_set_results
character_set_connection
Поскольку именно они отвечают за внесение, извлечение информации и создание
таблиц/баз соответственно. Какими они могут быть?
-----------------------------------------------------------------------------
mysql> SHOW CHARACTER SET;
+----------+-----------------------------+---------------------+--------+
| Charset  | Description                 | Default collation   | Maxlen |
+----------+-----------------------------+---------------------+--------+
| koi8r    | KOI8-R Relcom Russian       | koi8r_general_ci    |      1 |
| latin1   | cp1252 West European        | latin1_swedish_ci   |      1 |
| latin2   | ISO 8859-2 Central European | latin2_general_ci   |      1 |
| ascii    | US ASCII                    | ascii_general_ci    |      1 |
| koi8u    | KOI8-U Ukrainian            | koi8u_general_ci    |      1 |
| cp1250   | Windows Central European    | cp1250_general_ci   |      1 |
-----------------------------------------------------------------------------
Настройка кодировок
-----------------------------------------------------------------------------
Мануал предлагает нам три варианта задания кодировок:

    1.	Через names
    2.	Через непосредственно переменные character_set_*
    3.	Через настройки самого сервера

ВНИМАНИЕ!!! Первые два варианта работают только в рамках текущего соединения.
Это значит, что при следующем подключении все настройки вернутся в начальное
состояние! Чтобы не выставлять кодировку каждый раз, нужно воспользоваться
третьим вариантом.
-----------------------------------------------------------------------------
Вариант 1 - Через names

mysql> set names 'cp1251';
-----------------------------------------------------------------------------
Вариант 2 - Через непосредственно переменные character_set_*

mysql> set @@character_set_client='cp1251';
-----------------------------------------------------------------------------
Вариант 3 - Через настройки самого сервера

Тут можно пойти двумя путями - либо через конфиг файл:

---- Файл my.cnf
[client]
# Для местного клиента
default-character-set=cp1251
....

[mysqld]
# Для всего сервера
default-character-set=cp1251
-----------------------------------------------------------------------------

либо

shell> mysqld --character-set-server=cp1251

Ещё можно при конфигурировании задать кодировку по умолчанию
Но лучше, когда кодировка настраивается прямо в соединении.
-----------------------------------------------------------------------------
	Что делать, если данные внесены в неправильной кодировке
-----------------------------------------------------------------------------
Если база/таблица/данные были созданы/внесены в кодировке отличной от нужной,
то необходимо сделать следующее:

   1. Создать бэкап базы данных
   2. Создать текстовый дамп базы в SQL-запросах (mysqldump или PhpMyAdmin)
   3. С помощью текстового редактора исправить вхождения неверной кодировки на
нужную (а лучше попросту удалить всю информацию о кодировках и сравнениях)
   4. Удалить базу/таблицу
   5. Выставить нужную кодирвку на клиента/соединение
   6. Импортировать данные исправленного SQL-дампа

Этот вариант подходит почти для всех случаев, за исключением некоторых особых
ситуаций, например, когда сравнение, выставленное по-умолчанию, не уместно для
некоторых полей. Пример - поле для хранения пароля, необходимо сравнивать его
с учётом регистра, тогда как по-умолчанию выставляется сравнение без учёта регистра.
-----------------------------------------------------------------------------
	Правильный вариант работы с MySQL
-----------------------------------------------------------------------------
mysql> show variables like 'char%';
+--------------------------+----------------------------------+
| Variable_name            | Value                            |
+--------------------------+----------------------------------+
| character_set_client     | latin1                           |
| character_set_connection | latin1                           |
| character_set_database   | latin1                           |
| character_set_filesystem | binary                           |
| character_set_results    | latin1                           |
| character_set_server     | latin1                           |
| character_set_system     | utf8                             |
| character_sets_dir       | /usr/local/share/mysql/charsets/ |
+--------------------------+----------------------------------+
8 rows in set (0.02 sec)

## Кодировки выставлены неверно, нужно их настроить
mysql> set names 'koi8r';
Query OK, 0 rows affected (0.00 sec)

mysql> show variables like 'char%';
+--------------------------+----------------------------------+
| Variable_name            | Value                            |
+--------------------------+----------------------------------+
| character_set_client     | koi8r                            |
| character_set_connection | koi8r                            |
| character_set_database   | latin1                           |
| character_set_filesystem | binary                           |
| character_set_results    | koi8r                            |
| character_set_server     | latin1                           |
| character_set_system     | utf8                             |
| character_sets_dir       | /usr/local/share/mysql/charsets/ |
+--------------------------+----------------------------------+
8 rows in set (0.02 sec)

## Я работаю через koi8r, поэтому и выставляю её, 
## но данные в таблице буду хранить в cp1251
mysql> create table `test2` (`field` varchar(60)) charset cp1251;
Query OK, 0 rows affected (0.01 sec)

## Проверяем, всё ли в порядке
mysql> show create table `test2`;
+-------+--------------------------------------------+
| Table | Create Table                               |
+-------+--------------------------------------------+
| test2 | CREATE TABLE `test2` (
  `field` varchar(60) DEFAULT NULL
) ENGINE=MyISAM DEFAULT CHARSET=cp1251
+-------+--------------------------------------------+
1 row in set (0.01 sec)

## Вносим данные 
mysql> insert into `test2` values ('и раз'), ('Два'),('три'), ('И ять'), ('шесть');
Query OK, 5 rows affected (0.01 sec)
Records: 5  Duplicates: 0  Warnings: 0

## Проверяем сортировки
## В обычном сравнении "И" и "и" одинаковы, поэтому 
## сравнение идёт до первого отличного символа
mysql> select * from `test2` order by `field` collate cp1251_general_ci ASC;
+-------+
| field |
+-------+
| Два   |
| и раз |
| И ять |
| три   |
| шесть |
+-------+
5 rows in set (0.01 sec)

## В бинарном сравнении "И" меньше чем "и", поскольку у неё код меньше
mysql> select * from `test2` order by `field` collate cp1251_bin ASC;
+-------+
| field |
+-------+
| Два   |
| И ять |
| и раз |
| три   |
| шесть |
+-------+
5 rows in set (0.00 sec)

Таким образом, клиент работает в KOI8-R, но данные хранятся в cp1251,
MySQL знает об этом и делает перекодировку на лету.
-----------------------------------------------------------------------------
Ну и на посошок:

mysql> set character_set_results='cp1251';
Query OK, 0 rows affected (0.00 sec)

mysql> select * from `test2`;
+-------+
| field |
+-------+
| Х ПЮГ |
| дБЮ   |
| РПХ   |
| х ЪРЭ |
| ЬЕЯРЭ |
+-------+
5 rows in set (0.00 sec)

Выбирать данные можно в любой кодировке, так же, как и вносить,
главное - правильно сообщить об этом MySQL.
-----------------------------------------------------------------------------
===========================
Перекодировка Charset:
===========================
Поиск текста в файле и замена
Дамп для конвертирования
1. mysqldump
Конвертирование
2. sed -i 's/CHARSET=cp1251/CHARSET=utf8/g' /home/admin/admin_backups/utf8/medtehnika_dev.sql 
   sed -i 's/CHARSET=cp1251/CHARSET=utf8/g' /home/admin/admin_backups/utf8/medtehnika_b.sql 
   sed -i 's/CHARSET=latin1/CHARSET=utf8/g' /home/admin/admin_backups/utf8/medtehnika_b.sql 
Тестовое восстановление
3. mysql -u da_admin -p aaa < /home/admin/admin_backups/utf8/medtehnika_dev.sql 
   mysql -u da_admin -p aaa < /home/admin/admin_backups/utf8/medtehnika_b.sql 
Восстановление, можно через phpMyAdmin
4. mysql -u da_admin -p7S7L9tA7Du medtehnika_b < /home/admin/admin_backups/utf8/medtehnika_b.sql 
   mysql -u da_admin -p7S7L9tA7Du medtehnika_dev < /home/admin/admin_backups/utf8/medtehnika_dev.sql 

-----------------------------------------------------------------------------
===============================================================
innodb bitrix
---------------------------------------------------------------
my.cnf
---------------------------------------------------------------
[mysqld]

skip-name-resolve	= 1
query_cache_size        = 64M
query_cache_type        = 2
join_buffer_size	= 8M
innodb_log_file_size	= 1G
#

max_connections         = 2048
query_cache_limit       = 8M
max_allowed_packet      = 128M

innodb_buffer_pool_size         = 8G
innodb_buffer_pool_instances    = 8
innodb_log_buffer_size          = 128M
innodb_file_per_table           = 1
innodb_flush_log_at_trx_commit  = 2
innodb_additional_mem_pool_size = 64M
innodb_flush_method             = O_DIRECT

transaction-isolation           =  READ-COMMITTED
max-heap-table-size             = 300M
tmp-table-size                  = 300M

key_buffer_size                 = 128M
sort_buffer_size                = 1M
read_buffer_size                = 1M
read_rnd_buffer_size            = 1M

thread_stack                    = 1M
thread_cache_size		= 32
table_open_cache		= 4096

[safe_mysqld]
err-log=/var/log/mysqld.log
open_files_limit=8192

[mysqldump]
quick
max_allowed_packet=16M

[client]
default-character-set=utf8
---------------------------------------------------------------
show variables like 'innodb_log_file_size';
mysql> SET GLOBAL innodb_fast_shutdown = 1;
# mv /var/lib/mysql/ib_logfile0 /var/lib/mysql/ib_logfile0.bak
# mv /var/lib/mysql/ib_logfile1 /var/lib/mysql/ib_logfile1.bak
---------------------------------------------------------------
===============================================================
-----------------------------------------------------------------------------
	Optimization
-----------------------------------------------------------------------------
Первое, что рекомендуют при оптимизации любой БД в Unix системах, это включение
опции noatime для раздела с данными БД. При этом отключается запись информации
о последнем обращении к файлам. Эту опцию нужно прописать в файл /etc/fstab в
качестве параметра монтирования ФС. Для применения данного параметра без
перезагрузки системы достаточно выполнить команду:
-----------------------------------------------------------------------------	
mount -o remount <точка монтирования раздела>
-----------------------------------------------------------------------------
Далее выполним оптимизацию таблиц mysql, это делается следующей командой:
-----------------------------------------------------------------------------
mysqloptimize --analyze --all-databases -u root -p
-----------------------------------------------------------------------------
Информацию по приведённым параметрам можно (точнее нужно) посмотреть в справке
по программе (man mysqloptimize).
Следующим шагом будет использование утилиты MySQLTuner. Она входит в основной
репозиторий Debian, поэтому её установка весьма тривиальна:
-----------------------------------------------------------------------------
apt-get install mysqltuner
-----------------------------------------------------------------------------
Официальная документация рекомендует работу сервера хотя бы сутки, под типичной
для него нагрузкой, перед использованием утилиты. А т.к. для достижения
максимального эффекта нам придётся многократно запускать эту утилиту, то
вместо суточного ожидания мы будем использовать короткое стресс-тестирование
(подробное описание нагрузочного тестирования дано ниже).

При запуске утилиты будут запрошены логин и пароль администратора mysql,
после чего будет выдан краткий анализ работы MySQL и набор параметров,
которые рекомендуют добавить в конфигурацию сервера (/etc/mysql/my.cnf).
После изменения параметров необходим перезапуск mysql:
-----------------------------------------------------------------------------	
service mysql restart
-----------------------------------------------------------------------------
Наш алгоритм использования этой утилиты выглядит следующим образом:

    Запускаем нагрузочное тестирования web-сервера (запоминаем результаты)
    Запускаем mysqltuner.
    Изменяем параметры mysql в соответствии с рекомендациями утилиты.
    Перезапускаем mysql.
    Возвращаемся к 1-му пункту. Цикл нужно повторять до тех пор пока не
закончатся рекомендации mysqltuner (чуть подробее описано ниже).
-----------------------------------------------------------------------------
Очень часто mysqltuner при каждой итерации рекомендует увеличение одного и
того же параметра (каждый раз на большее значение), причём даже после
нескольких изменений подряд улучшения работы сервера нет (смотрите результаты
стресс-тестирования). При этом нам известны два варианта: первый - параметр
ещё не достиг значения при котором почувствуется эффект от его изменения
(тут нужно просто набраться терпения и пройти ещё несколько итераций) и
второй - эффект от данного параметра может и будет, но у нас просто не хватит
на это ресурсов (т.е. если при очередной итерации Вам советуют выделить под
какой-то параметр память сравнимую с общим объёмом в системе, а результата
после этого всё равно нет, то нужно просто откатится на разумное значение
этого параметра).
По нашему опыту: подбор верных параметров может увеличить общую
производительность web-сервера в несколько раз!
Хотя данный набор советов весьма эффективен (как минимум для нас), но он не
отменяет изучения официальной (и околоофициальной) документации по работе и
оптимизации mysql сервера.
-----------------------------------------------------------------------------
Swap
-----------------------------------------------------------------------------
Хостер пожертвовал нам 128Mb виртуальной памяти, но нам этого явно не
достаточно (сервер просто переставал отвечать при тестировании под нагрузкой),
поэтому добавим ещё 512Mb:
	
dd if=/dev/zero of=/swapfile bs=1M count=512
mkswap /swapfile
swapon /swapfile
echo '/swapfile swap swap defaults 0 0' >> /etc/fstab

Если предыдущие советы рекомендуются к использованию на всех системах, то
данный раздел больше применим при жёстком дефиците ресурсов.
-----------------------------------------------------------------------------
	Кеширование запросов
-----------------------------------------------------------------------------
После установки MySQL уже поддерживает механизм кеширования запросов, однако
по умолчанию он выключен. Параметры по умолчанию следующие:
-----------------------------------------------------------------------------
mysql> show variables like 'query%';
-----------------------------------------------------------------------------
+------------------------------+---------+
| Variable_name                |  Value  |
+------------------------------+---------+
| query_alloc_block_size       | 8192    |
| query_cache_limit            | 1048576 |
| query_cache_min_res_unit     | 4096    |
| query_cache_size             | 0       |
| query_cache_type             | ON      |
| query_cache_wlock_invalidate | OFF     |
| query_prealloc_size          | 8192    |
+------------------------------+---------+
7 rows in set (0.00 sec)
-----------------------------------------------------------------------------
Размер кеша равен нулю. Для того, чтобы задать кеш размером 32 МБ, необходимо
 добавить следующую строку в my.conf (в секцию [mysqld]):
-----------------------------------------------------------------------------
query_cache_size = 32M
-----------------------------------------------------------------------------
Чтобы не перезапускать MySQL-сервер, изменим также и текущую конфигурацию,
выполнив следующий запрос с правами суперпользователя:
mysql> set @@global.query_cache_size=32*1024*1024;
Query OK, 0 rows affected (0.00 sec)
-----------------------------------------------------------------------------
Еще один параметр, на который следует обратить внимание - это query_cache_limit
- он задает максимальный объем результата выполнения запроса, который может
быть помещен в кэш.
-----------------------------------------------------------------------------
Проверить состояние кеша можно следующим запросом:

mysql> show global status like 'Qcache%';
+-------------------------+----------+
| Variable_name           | Value    |
+-------------------------+----------+
| Qcache_free_blocks      | 21       |
| Qcache_free_memory      | 30943456 |
| Qcache_hits             | 3659     |
| Qcache_inserts          | 2409     |
| Qcache_lowmem_prunes    | 0        |
| Qcache_not_cached       | 75       |
| Qcache_queries_in_cache | 841      |
| Qcache_total_blocks     | 1863     |
+-------------------------+----------+
8 rows in set (0.00 sec)
-----------------------------------------------------------------------------
Значение параметров:

    Qcache_free_memory - объем свободной памяти, отведенной под кэш.
    Qcache_hits - количество запросов, отработанных из кэша.
    Qcache_inserts - количество вставок запросов в кэш.
    Qcache_lowmem_prunes - количество высвобождений памяти из-за наполненности кэша.
    Qcache_not_cached - количество запросов, не подлежащих кэшированию.
    Qcache_queries_in_cache - количество запросов, находящихся в кэше в настоящее время.
-----------------------------------------------------------------------------
Рассчитать эфективность кеширования можно по следующей формуле:
Qcache_hits / (Qcache_inserts + Qcache_not_cached).
-----------------------------------------------------------------------------
Собственно пора задаться вопросом, как именно работает кеш. Все очень просто.
При каждом запросе типа SELECT вычисляется хэш-сумма строки запроса и ищется
в кэше. Если находится - возвращается рузельтат из кэша, если нет - выполняется
запрос, а результат заносится в кэш (при условии, что результат не больше
значения query_cache_limit).
При каждом запросе типа UPDATE, REPLACE, INSERT, DELETE, TRUNCATE или ALTER,
удаляются из кэша все запросы, использующие таблицу, подвергшуюся обновлению.

Стоит также отметить некоторые особенности кеширования, а именно:
-----------------------------------------------------------------------------
Различие запросов определяется буквально, сравнение чувствительно к реестру.
Поэтому SELECT * FROM news и select * FROM news будут для кэша двумя разными запросами.
-----------------------------------------------------------------------------
В кэш всегда попадает результат выполнения запроса целиком, результаты
выполнения подзапросов не кэшируются.
-----------------------------------------------------------------------------
Кэш работает одинаково для запросов к таблицам с различными механизмами хранения.
-----------------------------------------------------------------------------
Ряд запросов не подлежит кэшированию:
-----------------------------------------------------------------------------
Запросы, содержащие одну из недетерминированных функций:
	NOW(), SLEEP(), RAND(), CURTIME(), LAST_INSERT_ID() и.др.
Запросы, использующие функции или хранимые процедуры, определенные пользователем.
Запросы, использующие значения локальных переменных.
Запросы, обращающиеся к базам данных mysql или INFORMATION_SCHEMA.
Запросы типа SELECT ... FOR UPDATE, SELECT ... IN SHARE MODE, SELECT ... 
INTO OUTFILE, SELECT ... INTO DUMPFILE, SELECT * FROM ... WHERE autoincrement_col IS NULL.
Запросы, использующие временные таблицы.
Запросы, не обращающиеся к таблицам.
Запросы, которые генерируют предупреждения (warnings).
В случае, если пользователь имеет права не на всю таблицу, а только на
определенные колонки таблицы. Это исключение — следствие того, что кэш
запросов один для всех пользователей, а права доступа средствами кэша
проверяются лишь на уровне таблиц.
-----------------------------------------------------------------------------
Если необходимо, чтобы запрос не попадал в кеш, используется директива
SQL_NO_CACHE, которая размещается сразу после оператора SELECT. 
Пример выполнения такого запроса:
mysql> SELECT SQL_NO_CACHE username FROM mail_users;
-----------------------------------------------------------------------------
	Увеличение количества одновременных подключений
-----------------------------------------------------------------------------
Однажды в логах обнаружил записи, что MySQL не может сделать выборку в базе.
Причина банальная - сработали ограничения по количеству одновременных подключений:

MYSQL connection failed: Too many connections
-----------------------------------------------------------------------------
По умолчанию параметр max_connections равняется 100. На всякий случай перепроверим:

mysql> show variables like 'max_connections';

+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| max_connections | 100   |
+-----------------+-------+
1 row in set (0.00 sec)
-----------------------------------------------------------------------------
Увеличим количество подключений до 400. Для этого добавим такую строку в 
my.conf (в секцию [mysqld]):

max_connections = 400

Чтобы не перезапускать MySQL-сервер, внесем изменения в текущую конфигурацию
(поскольку переменная MySQL глобальная, необходимо иметь достаточно привилегий):

mysql> set global max_connections = 400;
Query OK, 0 rows affected (0.00 sec)

Также стоит иметь ввиду, что увеличение количества подключений допускает
увеличение использование RAM, так что будьте осторожны с этим параметром.

-----------------------------------------------------------------------------
	Monitoring
-----------------------------------------------------------------------------
show processlist;
show status;
mysql> SHOW GLOBAL STATUS;
mysql> SHOW GLOBAL VARIABLES;
mysql> show databases;
mysql> show tables;
mytop в режиме реального времени.
Innotop
mysqladmin -variables;
mysql> SHOW BINARY LOGS;
mysql> SHOW FULL PROCESSLIST;
mysql> show columns from имя_таблицы;
-----------------------------------------------------------------------------
Mtop - мониторинг нагрузки на MySQL-сервер
----------------------------------------------------------------------------- 
mysql> grant process on *.* to 'mtop'@'localhost' identified by 'mtop_passwd_here';
# mtop -dbu mtop -p mtop_passwd_here
----------------------------------------------------------------------------- 
threads
running
cached
Queries/slow
Cache Hit
----------------------------------------------------------------------------- 
q - quit
? - help; show this text
f - flush status
F - fold/unfold column names in select statement display
k - kill processes; send a kill to a list of ids
s - change the number of seconds to delay between updates
m - toggle manual refresh mode on/off
d - filter display with regular expression (user/host/db/command/state/info)
h - display process for only one host
u - display process for only one user
i - toggle all/non-Sleeping process display
o - reverse the sort order
e - explain a process; show query optimizer info
t - show mysqld stats (show status/mysqladmin ext)
T - show mysqld important stats
v - show mysqld variables (show variables/mysqladmin vars)
z - zoom in on a process, show sql statement detail
r - show replication status for master/slaves
----------------------------------------------------------------------------- 
	Commands
-----------------------------------------------------------------------------
/usr/bin/mysqladmin -u root password 'new-password'
/usr/bin/mysqld или /usr/bin/mysqld_safe&
mysql>\s – статус или status
mysql> show databases;
mysql> DROP DATABASE test;
mysql> CREATE DATABASE company;
mysql> USE company;
mysql> CREATE TABLE users ( id INT(5) AUTO_INCREMENT PRIMARY KEY, name VARCHAR(64), surname VARCHAR(64), age TINYINT(3), email VARCHAR(64), status VARCHAR(128)) DEFAULT CHARACTER SET UTF8;
mysql> show tables;
-----------------------------------------------------------------------------
mysql> DESCRIBE users;
Выводит информацию по указанной таблице, имена колонок, типы данных и т.д.
Это
укороченный вариант команды SHOW COLUMNS FROM. Можно укоротить вообще до DESC.
-----------------------------------------------------------------------------
mysql> INSERT INTO users VALUES('', 'Ivan', 'Petrov', '25', 'petrov@company.ru', 'work');
или из файла mysql> SOURCE /root/sourcefi le.sql;
mysql> UPDATE users SET status='work' WHERE surname='Malevin';
mysql> DELETE from users WHERE surname='Karpin';
SELECT COUNT (*) FROM users;
SHOW PROSESSLIST; - текущие процессы в базе

-----------------------------------------------------------------------------
===========================
Смена пароля
===========================
Себе
mysql>SET PASSWORD = PASSWORD('пароль')
Пользователю
mysql>  SET PASSWORD FOR логин@localhost = PASSWORD('пароль');
mysql>  SET PASSWORD FOR логин@"%" = PASSWORD('пароль');
или
mysql>  UPDATE mysql.user SET Password=PASSWORD('пароль') WHERE User='логин' AND Host='localhost';
mysql>  FLUSH PRIVILEGES;
mysql>  SHOW GRANTS FOR 'admin_db'@'localhost';
mysql>  SHOW GRANTS FOR 'admin_db'@'%';

===========================
Восстановление root доступа
===========================
service mysqld stop
systemctl stop mariadb

mysqld_safe --skip-grant-tables &
mysql
mysql> UPDATE mysql.user SET Password=PASSWORD('secret') WHERE User='root';
mysql> FLUSH PRIVILEGES;
mysql> \q

systemctl start mariadb
service mysqld restart
-----------------------------------------------------------------------------

#############
#MYSQL
#############
---------------------------------------------------------------
MySql_5.5
---------------------------------------------------------------
mysql -uroot -ppassword
---------------------------------------------------------------
mysql> CREATE USER 'jeffrey'@'localhost' IDENTIFIED BY 'mypass';
mysql> SET PASSWORD FOR 'jeffrey'@'localhost' = PASSWORD('mypass');
mysql> SET PASSWORD = PASSWORD('mypass');
mysql> GRANT USAGE ON *.* TO 'jeffrey'@'localhost' IDENTIFIED BY 'mypass';
shell> mysqladmin -u user_name -h host_name password "new_password"
---------------------------------------------------------------
mysql> CREATE USER 'finley'@'localhost' IDENTIFIED BY 'some_pass';
mysql> GRANT ALL PRIVILEGES ON *.* TO 'finley'@'localhost' WITH GRANT OPTION;
mysql> CREATE USER 'finley'@'%' IDENTIFIED BY 'some_pass';
mysql> GRANT ALL PRIVILEGES ON *.* TO 'finley'@'%' WITH GRANT OPTION;
mysql> CREATE USER 'admin'@'localhost' IDENTIFIED BY 'admin_pass';
mysql> GRANT RELOAD,PROCESS ON *.* TO 'admin'@'localhost';
mysql> CREATE USER 'dummy'@'localhost';
---------------------------------------------------------------
mysql> SHOW GRANTS FOR 'admin'@'localhost';
---------------------------------------------------------------
mysql> CREATE USER 'custom'@'localhost' IDENTIFIED BY 'obscure';
mysql> GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP ON bankaccount.* TO 'custom'@'localhost';
mysql> CREATE USER 'custom'@'host47.example.com' IDENTIFIED BY 'obscure';
mysql> GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP ON expenses.* TO 'custom'@'host47.example.com';
mysql> CREATE USER 'custom'@'%.example.com' IDENTIFIED BY 'obscure';
mysql> GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP ON customer.* TO 'custom'@'%.example.com';
---------------------------------------------------------------
mysql> REVOKE ALL ON dbname.* FROM 'user'@'localhost';
---------------------------------------------------------------
mysql> DROP USER 'jeffrey'@'localhost';
---------------------------------------------------------------
mysql> SELECT USER(), CURRENT_USER();
---------------------------------------------------------------
mysql> RENAME USER ''@'localhost' TO 'user1'@'localhost';
mysql> RENAME USER 'user2'@'%.example.com' TO 'user2'@'remote.example.com';
---------------------------------------------------------------
mysql> FLUSH PRIVILEGES;
---------------------------------------------------------------
mysql> SHOW DATABASES;
---------------------------------------------------------------
mysql> SHOW TABLES;
---------------------------------------------------------------
mysql> SHOW GLOBAL STATUS;
---------------------------------------------------------------
mysql> SHOW VARIABLES LIKE 'colla%'\g
mysql> SHOW GLOBAL VARIABLES LIKE 'colla%tabase'\g
---------------------------------------------------------------
mysql> SET max_join_size=111111111111111111\g
mysql> SET GLOBAL max_join_size=111111111111111111\g
mysql> SET max_join_size=DEFAULT\g
---------------------------------------------------------------
CHECK TABLE имя_таблицы [ FOR UPGRADE | QUICK | FAST | MEDIUM | EXTENDED | CHANGED ]
Проверка таблицы на предмет ошибок в различных режимах.
---------------------------------------------------------------
OPTIMIZE TABLE имя_таблицы
Оптимизация таблиц.
---------------------------------------------------------------
REPAIR TABLE имя_таблицы
Попробовать отремонтировать таблицу.
Этот оператор тоже имеет
несколько опций, но в обычном случае достаточно простого
REPAIR TABLE. Если для ремонта таблиц, вдруг надумаете
использовать дополнительные опции, советую сначала ознакомиться
с документацией по их применению и возможным последствиям.)
---------------------------------------------------------------
# myisamchk /var/lib/mysql/company/users.MYI
Ключи -r или -o используются для восстановления таблиц.
Рекомендуется использовать ключ -r и если он не помог,
использовать -o, который на порядок медленнее работает.
---------------------------------------------------------------
ALTER TABLE имя_таблицы ENGINE=InnoDB
У оператора ALTER масса различных ключей, но в процессе
администрирования сервера ( то есть не администрирования
какого-то конкретного веб приложения ), я его применяю для смены
движка MyISAM на InnoDB для некоторых таблиц.
---------------------------------------------------------------
DROP TABLE имя_таблицы
Удалить таблицу.
---------------------------------------------------------------
FLUSH PRIVILEGES
Перезагрузить системную таблицу привилегий.
Mysql сервер кэширует
в память результат выполнения таких операторов как: CREATE USER,
GRANT, CREATE SERVER, INSTALL PLUGIN, и не освобождает память
при выполнении обратных вариантов команд: DROP USER, REVOKE,
DROP SERVER, UNINSTALL PLUGIN.
---------------------------------------------------------------
FLUSH HOSTS
Очищает кэш хостов, например если у хоста сменился IP адрес или
если вдруг появилось сообщение: Host 'имя_хоста' is blocked.
----------------------------------------------------------------------------- 
MySQL - калькуляция и отображение размера баз данных
----------------------------------------------------------------------------- 
SELECT table_schema "database_name", sum( data_length + index_length )/1024/1024 "Data Base Size in MB" FROM information_schema.TABLES GROUP BY table_schema;
----------------------------------------------------------------------------- 
---тип движка таблицы---
select engine from information_schema.tables where table_name='имя_таблицы';
-----------------------------------------------------------------------------
---последний столбец---
select * from имя_таблицы ORDER BY имя_столбца DESC LIMIT 1\G;
-----------------------------------------------------------------------------
---структура таблицы---
show columns from имя_таблицы;
----------------------------------------------------------------------------- 
---создание реплики---
stop slave;
FLUSH TABLES WITH READ LOCK;
SET GLOBAL read_only = ON;
GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO имя_пользователя@адрес_сервера IDENTIFIED BY "оченьсложныйпароль"; - на мастере
CHANGE MASTER TO MASTER_HOST = 'адрес_сервера_мастера', MASTER_USER = 'имя_пользователя', MASTER_PASSWORD = "оченьсложныйпароль", MASTER_CONNECT_RETRY = 5000, MASTER_LOG_FILE = "название_файло_бин-лога", MASTER_LOG_POS = позиция_в_бин-логе; - на реплике
MASTER_LOG_FILE=relay_master_log_file и MASTER_LOG_POS=exec_master_log_pos - если с другой реплики но на одного мастера
SET GLOBAL read_only = OFF;
start slave;
----------------------------------------------------------------------------- 
---назначение всех прав/одновременное создание пользователя---
GRANT ALL PRIVILEGES ON имя_базы.имя_таблицы TO имя_пользователя@адрес_сервера
IDENTIFIED BY "оченьсложныйпароль";
----------------------------------------------------------------------------- 
---дамп базы---
mysqldump 
 -u имя_пользователя -pоченьсложныйпароль --add-drop-table --add-locks 
-q -Q --disable-keys --extended-insert --default-character-set=cp1251 имя_базы
имя_таблицы(если нужно) -r имя_файла.sql
----------------------------------------------------------------------------- 
---список юзеров---
SELECT USER from mysql.user;
----------------------------------------------------------------------------- 
---просмотр прав---
SHOW GRANTS FOR 'имя_пользователя'@'адрес_сервера';
----------------------------------------------------------------------------- 
---проверка баз типа myisam---
myisamchk
 --force --fast --update-state --key_buffer_size=18G 
--sort_buffer_size=2000M --read_buffer_size=4M --write_buffer_size=4M /var/lib/mysql/*/*.MYI
----------------------------------------------------------------------------- 
---смена движка таблицы InnoDB --> MYISAM---
sudo find /var/lib/mysql/имя_базы -iname '*.ibd' -printf '%f\n'
mysql> use имя_базы;
mysql> ALTER TABLE имя_таблицы ENGINE = MYISAM;
----------------------------------------------------------------------------- 
---вывод таблиц списоком---
mysql -e 'SHOW TABLE STATUS FROM имя_базы'  -s  --skip-column-names | awk '{print $1 " " $7}'
----------------------------------------------------------------------------- 
---список процессов---
SHOW FULL PROCESSLIST;
----------------------------------------------------------------------------- 
---пропустить ошибку при репликации---
SET GLOBAL SQL_SLAVE_SKIP_COUNTER = 1;
----------------------------------------------------------------------------- 
---удалить столбец в таблице---
ALTER TABLE имя_таблицы DROP имя_столбца;
----------------------------------------------------------------------------- 
---сортировать по столбцу---
SELECT `имя_столбца` FROM `имя_таблицы` GROUP BY `имя_столбца`;
----------------------------------------------------------------------------- 
	Перенос БД в другой каталог
----------------------------------------------------------------------------- 
mysql> show variables like 'datadir';
+---------------+----------------+
| Variable_name | Value          |
+---------------+----------------+
| datadir       | /var/db/mysql/ |
+---------------+----------------+
1 row in set (0.00 sec)
----------------------------------------------------------------------------- 
mysql> systemctl restart mysqld.service
----------------------------------------------------------------------------- 
#vim /etc/my.cnf
mysql_dbdir="/usr/mysql"
mysql> show variables like 'datadir';
# rm -R /var/db/mysql
----------------------------------------------------------------------------- 
	Myisamchk и mysqlcheck - проверка и ремонт таблиц
----------------------------------------------------------------------------- 
Иногда после некорректной перезагрузки сервера некоторые базы MySQL
повреждаются и нуждаются в исправлении ошибок. Проверить на наличие ошибок
и исправлять их можно следующими командами:

myisamchk

Параметры уровня проверки:
--medium-check - средний
--extend-check - расширенный

Пример использования:
# myisamchk --fast --silent /var/db/mysql/*/*.MYI
----------------------------------------------------------------------------- 
ВНИМАНИЕ!
Myisamchk нужно запускать при остановленном mysqld, иначе нужно использовать
утилиту mysqlcheck!
----------------------------------------------------------------------------- 
Пример использования утилиты mysqlcheck :
# mysqlcheck --repair  --all-databases --auto-repair -u username -p
----------------------------------------------------------------------------- 
Иногда можно наблюдать такую ошибку:

Error    : Incorrect file format

В таком случае необходимо при использовании mysqlcheck  добавить опцию --use-frm.
----------------------------------------------------------------------------- 
	Mysqlbinlog
----------------------------------------------------------------------------- 
работаем с бинарными логами MySQL
mysql>  SHOW BINARY LOGS;
----------------------------------------------------------------------------- 
Начиная с версии 4.1.3 MySQL записывает все запросы, которые приводят к
изменению данных, в бинарный журнал обновлений (binary log). Но эта опция может
оказаться и отключенной по умолчанию. Включается поддержка бинарных логов
строкой log-bin=mysql-bin в конфигурационном файле (my.cnf). Ведутся логи
и в том случае, если MySQL запущен с ключом --log-bin[=file_name].

Журнал обновлений обычно хранится в файлах вида mysql-bin. циферки. Пример:
mysql-bin.000171. Если в настройках не задан полный путь, эти файлы будут
размещены в директории, в которой MySQL хранит базы данных. По умолчанию размер
каждого файла - 1 ГБ.

Для работы с бинарными логами понадобится утилита mysqlbinlog. Она идёт в
комплекте с MySQL сервером. Утилита обрабатывает файлы журнала и выводит
пригодный к использованию SQL код прямо в консоль. Вывод можно перенаправить
в файл (mysqlbinlog [параметры] [лог_файлы] > файл .sql), непосредственно в
MySQL (mysqlbinlog [параметры] / mysql [параметры] ) или указать файл для
вывода в параметрах утилиты. Например:
----------------------------------------------------------------------------- 
# mysqlbinlog -s -d db_name -r out.sql mysql-bin.000038
----------------------------------------------------------------------------- 
В данном случае будет обработан файл mysql-bin.000038 (из текущей директории),
вывод оправится в out.sql, будут выведены только команды, относящиеся к
изменению базы с именем db_name. Параметром -s мы запретили вывод дополнительной
служебной информации.

Более полезный пример:
----------------------------------------------------------------------------- 
# mysqlbinlog -s -d db_name -u user_name --start-datetime="2009-01-23 21:10:00" -t mysql-bin.000001 > out.sql
----------------------------------------------------------------------------- 
Здесь мы, кроме прочего, ограничиваемся выводом запросов, которые выполнялись
пользователем user_name начиная с указанной даты. Параметр -t сообщает утилите,
 что нужно обрабатывать и логи, которые идут после файла mysql-bin.000001.
Обратите внимание, что если вы будете перенаправлять вывод сразу в MySQL, то
в журнал обновлений добавятся свежие записи и произойдёт зацикливание. Для
предотвращения следует добавить ещё и параметр -D, который запрещает ведение
лога. Запрет будет доступен только если выполнять команду из под рута. Но
перенаправление вывода прямо в мускул не рекомендуется.

Остальные параметры подсматриваем так же, как и для любой консольной программы:
----------------------------------------------------------------------------- 
# mysqlbinlog --help
----------------------------------------------------------------------------- 
Но если все хорошо, восстанавливать из дампов ничего не нужно... А бинарные
логи имеют привычку занимать много места не сервере (недавно посмотрел на
одном из серверов и ужаснулся - больше 50 гигабайт!). Поэтому советую время
от времени создавать дамп всей базы данных MySQL с последующим удалением
бинарных логов. Для этого необходимо воспользоваться следующей командой:
----------------------------------------------------------------------------- 
# mysqldump --flush-logs --delete-master-logs --all-databases -u user_name  -p > out.sql
----------------------------------------------------------------------------- 
Чтобы автоматизировать этот процесс, добавим в my.cnf (в секцию [mysqld] ) такую строку:
expire_logs_days = 7
----------------------------------------------------------------------------- 
Этой переменной мы указываем, что необходимо хранить записи только за последние
7 дней. После внесения изменений необходимо перезапустить MySQL:
----------------------------------------------------------------------------- 
# sh /usr/local/etc/rc.d/mysql-server restart
----------------------------------------------------------------------------- 
Также необходимо дать команду MySQL очистить логи:
mysql> flush logs;
Query OK, 0 rows affected (0.00 sec)
----------------------------------------------------------------------------- 
	mysqldump + mysqlbinlog for Backup and Restore
----------------------------------------------------------------------------- 

The following example describes a simple scenario that shows how to use
mysqldump and mysqlbinlog together to back up a server's data and binary log,
and how to use the backup to restore the server if data loss occurs. The
example assumes that the server is running on host host_name and its first
binary log file is named binlog.000999. Enter each command on a single line.

Use mysqlbinlog to make a continuous backup of the binary log:
----------------------------------------------------------------------------- 
mysqlbinlog --read-from-remote-server --host=host_name --raw
  --stop-never binlog.000999
----------------------------------------------------------------------------- 
Use mysqldump to create a dump file as a snapshot of the server's data.
Use --all-databases, --events, and --routines to back up all data, and
--master-data=2 to include the current binary log coordinates in the dump file.
----------------------------------------------------------------------------- 
mysqldump --host=host_name --all-databases --events --routines --master-data=2> dump_file
----------------------------------------------------------------------------- 
Execute the mysqldump command periodically to create newer snapshots as desired.

If data loss occurs (for example, if the server crashes), use the most recent
dump file to restore the data:
----------------------------------------------------------------------------- 
mysql --host=host_name -u root -p < dump_file
----------------------------------------------------------------------------- 
Then use the binary log backup to re-execute events that were written after
the coordinates listed in the dump file. Suppose that the coordinates in the
file look like this:
----------------------------------------------------------------------------- 
-- CHANGE MASTER TO MASTER_LOG_FILE='binlog.001002', MASTER_LOG_POS=27284;
----------------------------------------------------------------------------- 
If the most recent backed-up log file is named binlog.001004, re-execute the
log events like this:
----------------------------------------------------------------------------- 
mysqlbinlog --start-position=27284 binlog.001002 binlog.001003 binlog.001004
  | mysql --host=host_name -u root -p
----------------------------------------------------------------------------- 

You might find it easier to copy the backup files (dump file and binary log
files) to the server host to make it easier to perform the restore operation,
or if MySQL does not allow remote root access. 
----------------------------------------------------------------------------- 

-----------------------------------------------------------------------------
	Warning/Socket
-----------------------------------------------------------------------------
===============================================================
###########
#[Warning] 'user' entry 'root@localhost' has both a password
and an authentication plugin specified. The password will be
ignored.
###########
===============================================================
It is normal, if by saying "accessing the DB via mysql -u root -p
works fine" you mean that you are running it while being a system
root (or under sudo). You should not be able to do it as an ordinary user.
Packages generated by Ubuntu by default have unix_socket
authentication for the local root. To check, run 
---------------------------------------------------------------
SELECT user, host, plugin FROM mysql.user;
---------------------------------------------------------------
You should see unix_socket in the plugin column for root@localhost.
If you want to use the password authentication instead, run
---------------------------------------------------------------
UPDATE mysql.user SET plugin = '' WHERE plugin = 'unix_socket';
FLUSH PRIVILEGES;
-----------------------------------------------------------------------------
===========================
Backup/Restore
===========================

mysqldump -u root -p dbname > dump.sql
---------------------------------------------------------------
--add-drop-table - добавляет команду DROP TABLE перед каждой
командой CREATE TABLE
--add-locks - добавляет команду LOCK TABLES перед выполнением
и UNLOCK TABLE после выполнения каждого дампа таблицы
--no-create-db, -n - не добавлять команду CREATE DATABASE,
которая добавляется при использовании параметров --databases и --all-databases
--no-data, -d - дампить только структуру таблиц
--no-create-info, -t - не создавать команду CREATE TABLE
--skip-comments - не выводить комментарии.
--compact - использовать компактный формат
--create-options - добавляет дополнительную информацию о таблице
в команду CREATE TABLE: тип, значение AUTO_INCREMENT и т.д. Не
нужные опции можно вырезать с помощью sed.
--extended-insert, -e - применение команды INSERT с многострочным
синтаксисом (повышает компактность и быстродействие операторов ввода)
--tables - дампить только таблицы из списка, следующего за этим
параметром, разделитель - пробел
---------------------------------------------------------------
mysql -uroot -p dbname1 < dump.sql
---------------------------------------------------------------
	InnoDB 
---------------------------------------------------------------
Cold Backups
---------------------------------------------------------------
If you can shut down the MySQL server, you can make a physical
backup that consists of all files used by InnoDB to manage its
tables. Use the following procedure:

    Perform a slow shutdown of the MySQL server and make sure
that it stops without errors.

    Copy all InnoDB data files (ibdata files and .ibd files)
into a safe place.

    Copy all the .frm files for InnoDB tables to a safe place.

    Copy all InnoDB log files (ib_logfile files) to a safe place.

    Copy your my.cnf configuration file or files to a safe place.
---------------------------------------------------------------
slow shutdown
---------------------------------------------------------------
    A type of shutdown that does additional InnoDB flushing
operations before completing. Also known as a clean shutdown.
Specified by the configuration parameter innodb_fast_shutdown=0
or the command SET GLOBAL innodb_fast_shutdown=0;. Although the
shutdown itself can take longer, that time will be saved on the
subsequent startup.  
---------------------------------------------------------------
	Logical Backups Using mysqldump
---------------------------------------------------------------	
In addition to physical backups, it is recommended that you
regularly create logical backups by dumping your tables using
mysqldump. A binary file might be corrupted without you noticing
it. Dumped tables are stored into text files that are
human-readable, so spotting table corruption becomes easier.
Also, because the format is simpler, the chance for serious
data corruption is smaller. mysqldump also has a
--single-transaction option for making a consistent snapshot
without locking out other clients.
See Section 7.3.1, “Establishing a Backup Policy”.
https://dev.mysql.com/doc/refman/5.7/en/backup-policy.html
---------------------------------------------------------------	
Full backup
---------------------------------------------------------------	
shell> mysqldump --all-databases --master-data --single-transaction > backup_sunday_1_PM.sql
---------------------------------------------------------------	
Replication works with InnoDB tables, so you can use MySQL
replication capabilities to keep a copy of your database at
database sites requiring high availability.
See Section 14.19, “InnoDB and MySQL Replication”. 
---------------------------------------------------------------
Incremental  backup
---------------------------------------------------------------	
To make incremental backups, we need to save the incremental
changes. In MySQL, these changes are represented in the binary
log, so the MySQL server should always be started with the
--log-bin option to enable that log. With binary logging
enabled, the server writes each data change into a file while
it updates data. 
---------------------------------------------------------------	
Each time it restarts, the MySQL server creates a new binary log
file using the next number in the sequence. While the server is
running, you can also tell it to close the current binary log
file and begin a new one manually by issuing a FLUSH LOGS SQL
statement or with a mysqladmin flush-logs command.
---------------------------------------------------------------	
 mysqldump also has an option to flush the logs. The .index file
in the data directory contains the list of all MySQL binary logs
in the directory. 
---------------------------------------------------------------	
shell> mysqldump --single-transaction --flush-logs --master-data=2 \
         --all-databases > backup_sunday_1_PM.sql
---------------------------------------------------------------	
 After executing this command, the data directory contains a
new binary log file, gbichot2-bin.000007, because the --flush-logs
option causes the server to flush its logs. The --master-data
option causes mysqldump to write binary log information to its
output, so the resulting .sql dump file includes these lines:

-- Position to start replication or point-in-time recovery from
-- CHANGE MASTER TO MASTER_LOG_FILE='gbichot2-bin.000007',MASTER_LOG_POS=4;
---------------------------------------------------------------	
 Because the mysqldump command made a full backup, those lines
mean two things:

    The dump file contains all changes made before any changes
written to the gbichot2-bin.000007 binary log file or higher.

    All data changes logged after the backup are not present in
the dump file, but are present in the gbichot2-bin.000007 binary
log file or higher. 
---------------------------------------------------------------	
 On Monday at 1 p.m., we can create an incremental backup by
flushing the logs to begin a new binary log file. For example,
executing a mysqladmin flush-logs command creates
gbichot2-bin.000008. All changes between the Sunday 1 p.m. full
backup and Monday 1 p.m. will be in the gbichot2-bin.000007 file.
This incremental backup is important, so it is a good idea to
copy it to a safe place. (For example, back it up on tape or
DVD, or copy it to another machine.) On Tuesday at 1 p.m.,
execute another mysqladmin flush-logs command. All changes
between Monday 1 p.m. and Tuesday 1 p.m. will be in the
gbichot2-bin.000008 file (which also should be copied somewhere
safe).

The MySQL binary logs take up disk space. To free up space,
purge them from time to time. One way to do this is by deleting
the binary logs that are no longer needed, such as when we make
a full backup: 
---------------------------------------------------------------	
shell> mysqldump --single-transaction --flush-logs --master-data=2 \
         --all-databases --delete-master-logs > backup_sunday_1_PM.sql
---------------------------------------------------------------	
Note 
Deleting the MySQL binary logs with mysqldump --delete-master-logs
can be dangerous if your server is a replication master server,
because slave servers might not yet fully have processed the
contents of the binary log. The description for the PURGE BINARY
LOGS statement explains what should be verified before deleting
the MySQL binary logs.
See Section 13.4.1.1, “PURGE BINARY LOGS Syntax”. 
---------------------------------------------------------------	
Here's a scrip i wrote to backup my db, using a user that's not "mysql".

There's an entry in the sudoers file to allow the user to read the log files

The backup (mysql) user has "super,reload,all" privileges + its password in .my.cnf

The backup path is on a NAS filesystem.

What's missing is a function to remove old full backups if needed.

------------------------------------------------------
Script
------------------------------------------------------
#!/bin/bash

MODE=$1
MYSQLUSER=backup
BINLOGPATH=/var/log/mysql
BINLOGNAME=mysql-bin
ARCHIVEPATH=/usr/app/security/var/data/backups/mysql/

setRead() {
# change properties on binlog path
sudo chmod o+rx $BINLOGPATH
sudo chmod o+r $BINLOGPATH/*
}

resetRead() {
# restore properties on binlog path
sudo chmod o-r $BINLOGPATH/*
sudo chmod o-rx $BINLOGPATH
}

copyBinlogs() {
# copy binlogs to archive dir
echo "Copying binlogs"
setRead;
for FILE in `cat $BINLOGPATH/$BINLOGNAME.index`
do
SFILE=(${FILE/*\//})
if [ ! -f $ARCHIVEPATH/$SFILE.gz ]
then
echo "- binlog $SFILE"
cp $FILE $ARCHIVEPATH
gzip $ARCHIVEPATH/$SFILE
fi
done
resetRead;
}

saveBinlogs() {
# move latest binlogs to savedir
echo "Saving binlogs"
SAVEDIR=`date +%Y%m%d`
echo $SAVEDIR
mkdir -p $ARCHIVEPATH/$SAVEDIR
mv $ARCHIVEPATH/*.gz $ARCHIVEPATH/$SAVEDIR
}

# --- Main ---
case "$MODE" in

'full')
# Weekly backup
# - copy all bin logs to backup directory
# - clean path of backup directory
echo "Weekly backup"
DATE=`date +%Y%m%d`
mysqldump -u $MYSQLUSER --single-transaction --flush-logs --master-data=2 \
--all-databases --delete-master-logs | gzip > $ARCHIVEPATH/$SAVEDIR/full-$DATE.sql.gz
copyBinlogs;
saveBinlogs;
;;

'incremental')
# Daily backup
# - flush logs
# - copy all bin logs to backup directory if not already done
echo "Mysql daily backup"
mysqladmin -u $MYSQLUSER flush-logs
copyBinlogs;
;;

*)
echo "Usage: mysql_backup [full|incremental]"
;;

esac
-----------------------------------------------------------------------------
	SypexDumper
-----------------------------------------------------------------------------
https://sypex.net/ru/products/dumper/docs/
https://sypex.net/files/SypexDumper_2011.zip
-----------------------------------------------------------------------------	
Консольный дампер
-----------------------------------------------------------------------------
Дампер, написанный на sh, который позволяет экспортировать данные из latin1 в исходную кодировку (обычно cp1251).
-----------------------------------------------------------------------------
#!/bin/sh
##
## @Author: Anton Pribora, //anton-pribora.ru, 2009
##

help() {
  cat <<EOF
This is alternative mysql dumper. It's have following options:
  $0 [-h host] [-u user] [-p password] [-f charset] [-t charset] (db_name | -l | --help)
  
Optional options:
    -h host       MySQL host
    -u user       MySQL user name
    -p password   MySQL user password
    -f charset    Replace FROM charset
    -t charset    Replcae TO charset
    
Main options:
    db_name       Dump db_name database
    -l            Show all databases
    --help        Show this help
    
Author - Anton Pribora, //anton-pribora.ru, 2009
EOF
  exit
}

[ $# -eq 0 ] && help

mysql_run() {
  ${MYSQL_COMMAND} $@
  if [ $? -ne 0 ]; then 
    echo "$0: MySQL ERROR occur. Try to use --help option." 1>&2;
    exit 1;
  fi
}

show_version() {
  echo 'select version()' | mysql_run
}

show_databases() {
  echo "show databases" | mysql_run
}

show_tables() {
  echo "show tables from \`$1\`" | mysql_run
}

dump_create_table() {
  echo "show create table \`$1\`.\`$2\`" | mysql_run | awk 'BEGIN{FS="\t"}{gsub("\\\\n", "\n", $2); print $2";"}'
}

dump_table() {
  echo "select * from \`$1\`.\`$2\`" | mysql_run | awk -v table="$2" 'BEGIN{FS="\t"}{gsub("\"", "\\\""); gsub("\t", "\", \""); print "INSERT INTO `"table"` VALUES (\""$0"\");"}'
}

charset_filter() {
  sed -E -e "s/CHARSET=${REPLACE_FROM}/CHARSET=${REPLACE_TO}/g"
}

MYSQL_CLIENT=`which mysql`
MYSQL_OPTIONS="--skip-column-names"
MYSQL_DB=

REPLACE_FROM=latin1
REPLACE_TO=utf8

SHOW_DATABASES=

while [ $# -gt 0 ];
do
  case "$1" in
    -h) MYSQL_OPTIONS="${MYSQL_OPTIONS} --host='$2'"; shift 2;;
    -u) MYSQL_OPTIONS="${MYSQL_OPTIONS} --user='$2'"; shift 2;;
    -p) MYSQL_OPTIONS="${MYSQL_OPTIONS} -p$2"; shift 2;;
    -f) REPLACE_FROM=$2; shift 2;;
    -t) REPLACE_TO=$2; shift 2;;
    -l|-1) SHOW_DATABASES="1"; shift;;
    --help) help; shift;;
     *) MYSQL_DB=$1; shift;;
  esac
done

MYSQL_COMMAND="${MYSQL_CLIENT} ${MYSQL_OPTIONS}"

if [ -n "${SHOW_DATABASES}" ]; then show_databases; exit; fi

echo -e "--\n-- MySQL version: `show_version`\n-- Database: ${MYSQL_DB}\n-- Date: `date`\n-- \n"

for TABLE in `show_tables ${MYSQL_DB}`
do
  echo -e "-- \n-- Table \`${TABLE}\` structure\n-- "
  dump_create_table ${MYSQL_DB} ${TABLE} | charset_filter
  echo 
  
  echo -e "-- \n-- Table \`${TABLE}\` dump\n-- "
  dump_table ${MYSQL_DB} ${TABLE}
  echo 
done

-----------------------------------------------------------------------------
	Replication
-----------------------------------------------------------------------------
	Manual
-----------------------------------------------------------------------------
	Master
-----------------------------------------------------------------------------
/etc/my.cnf
[mysqld]
log-bin=mysql-bin
server-id=1
-----------------------------------------------------------------------------
Note
-----------------------------------------------------------------------------
The following options have an impact on this procedure:

    if you omit server-id (or set it explicitly to its default value of 0),
the master refuses any connections from slaves.

    For the greatest possible durability and consistency in a replication setup
using InnoDB with transactions, you should use innodb_flush_log_at_trx_commit=1
and sync_binlog=1 in the master my.cnf file.

    Ensure that the skip-networking option is not enabled on your replication
master. If networking has been disabled, the slave cannot communicate with the
master and replication fails. 
-----------------------------------------------------------------------------
	Slave
-----------------------------------------------------------------------------
/etc/my.cnf
[mysqld]
server-id=2
-----------------------------------------------------------------------------
 If you are setting up multiple slaves, each one must have a unique server-id
value that differs from that of the master and from any of the other slaves.
Note

If you omit server-id (or set it explicitly to its default value of 0), the
slave refuses to connect to a master.

You do not have to enable binary logging on the slave for replication to be
set up. However, if you enable binary logging on the slave, you can use the
slave's binary log for data backups and crash recovery, and also use the
slave as part of a more complex replication topology. For example, where this
slave then acts as a master to other slaves. 
-----------------------------------------------------------------------------
mysql> CHANGE MASTER TO
    ->     MASTER_HOST='master_host_name',
    ->     MASTER_USER='replication_user_name',
    ->     MASTER_PASSWORD='replication_password',
    ->     MASTER_LOG_FILE='recorded_log_file_name',
    ->     MASTER_LOG_POS=recorded_log_position;
-----------------------------------------------------------------------------
Note
-----------------------------------------------------------------------------
Replication cannot use Unix socket files. You must be able to connect to the
master MySQL server using TCP/IP.
-----------------------------------------------------------------------------
	Setting Up Replication with Existing Data
-----------------------------------------------------------------------------
	Start the slave, using the --skip-slave-start option so that
replication does not start.

Import the dump file:
shell> mysql < fulldb.dump
-----------------------------------------------------------------------------
Configure the slave with the replication coordinates from the master. This
tells the slave the binary log file and position within the file where
replication needs to start. Also, configure the slave with the login
credentials and host name of the master
-----------------------------------------------------------------------------
mysql> START SLAVE;
-----------------------------------------------------------------------------
After you have performed this procedure, the slave connects to the master and
replicates any updates that have occurred on the master since the snapshot was
taken. 
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
mysql> CREATE USER 'repl'@'%.mydomain.com' IDENTIFIED BY 'slavepass';
mysql> GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%.mydomain.com';
mysql> FLUSH TABLES WITH READ LOCK;
mysql > SHOW MASTER STATUS;
-----------------------------------------------------------------------------
Warning
-----------------------------------------------------------------------------
Leave the client from which you issued the FLUSH TABLES statement running so
that the read lock remains in effect. If you exit the client, the lock is released.
-----------------------------------------------------------------------------
	Choosing a Method for Data Snapshots
-----------------------------------------------------------------------------
	Creating a Data Snapshot Using mysqldump
-----------------------------------------------------------------------------
    Use the mysqldump tool to create a dump of all the databases you want to
replicate. This is the recommended method, especially when using InnoDB.

    If your database is stored in binary portable files, you can copy the raw
data files to a slave. This can be more efficient than using mysqldump and
importing the file on each slave, because it skips the overhead of updating
indexes as the INSERT statements are replayed. With storage engines such as
InnoDB this is not recommended.
-----------------------------------------------------------------------------
shell> mysqldump --all-databases --master-data > dbdump.db
-----------------------------------------------------------------------------
Note
-----------------------------------------------------------------------------
If you do not use --master-data, then it is necessary to lock all tables in a
separate session manually. See Section 16.1.2.3, “Obtaining the Replication
Master Binary Log Coordinates”.

    Exclude all the tables in the database using --ignore-table option.

    Name only those databases which you want dumped using the --databases option.
-----------------------------------------------------------------------------
	Creating a Data Snapshot Using Raw Data Files
-----------------------------------------------------------------------------
 If you use InnoDB tables, you can use the mysqlbackup command from the MySQL
Enterprise Backup component to produce a consistent snapshot. This command
records the log name and offset corresponding to the snapshot to be used on
the slave. MySQL Enterprise Backup is a commercial product that is included
as part of a MySQL Enterprise subscription. See Section 29.2, “MySQL Enterprise
Backup Overview” for detailed information.

This method also does not work reliably if the master and slave have different
values for ft_stopword_file, ft_min_word_len, or ft_max_word_len and you are
copying tables having full-text indexes.

Assuming the above exceptions do not apply to your database, use the cold
backup technique to obtain a reliable binary snapshot of InnoDB tables: do
a slow shutdown of the MySQL Server, then copy the data files manually.

To create a raw data snapshot of MyISAM tables when your MySQL data files
exist on a single file system, you can use standard file copy tools such as
cp or copy, a remote copy tool such as scp or rsync, an archiving tool such
as zip or tar, or a file system snapshot tool such as dump. If you are
replicating only certain databases, copy only those files that relate to
those tables. For InnoDB, all tables in all databases are stored in the
system tablespace files, unless you have the innodb_file_per_table option enabled.
-----------------------------------------------------------------------------
	The following files are not required for replication:
-----------------------------------------------------------------------------
    Files relating to the mysql database.

    The master info repository file, if used (see Section 16.2.4, “Replication Relay and Status Logs”).

    The master's binary log files.

    Any relay log files. 
-----------------------------------------------------------------------------
Depending on whether you are using InnoDB tables or not, choose one of the following:
-----------------------------------------------------------------------------
If you are using InnoDB tables, and also to get the most consistent results
with a raw data snapshot, shut down the master server during the process, as
follows:
-----------------------------------------------------------------------------
    Acquire a read lock and get the master's status. See Section 16.1.2.3,
 “Obtaining the Replication Master Binary Log Coordinates”.

    In a separate session, shut down the master server:

    shell> mysqladmin shutdown

    Make a copy of the MySQL data files. The following examples show common
ways to do this. You need to choose only one of them:

    shell> tar cf /tmp/db.tar ./data
    shell> zip -r /tmp/db.zip ./data
    shell> rsync --recursive ./data /tmp/dbdata
-----------------------------------------------------------------------------
    Restart the master server. 
-----------------------------------------------------------------------------
If you are not using InnoDB tables, you can get a snapshot of the system from
a master without shutting down the server as described in the following steps:
-----------------------------------------------------------------------------
    Acquire a read lock and get the master's status. See Section 16.1.2.3,
“Obtaining the Replication Master Binary Log Coordinates”.

    Make a copy of the MySQL data files. The following examples show common
ways to do this. You need to choose only one of them:

    shell> tar cf /tmp/db.tar ./data
    shell> zip -r /tmp/db.zip ./data
    shell> rsync --recursive ./data /tmp/dbdata

    In the client where you acquired the read lock, release the lock:

    mysql> UNLOCK TABLES;
-----------------------------------------------------------------------------
Once you have created the archive or copy of the database, copy the files to
each slave before starting the slave replication process. 
-----------------------------------------------------------------------------
	Switching Masters During Failover
-----------------------------------------------------------------------------
Web Client -> Master <- Slave{1,2,3}
-----------------------------------------------------------------------------
Web Client -> Master==Slave1 <- Slave{2,3},NotMaster
-----------------------------------------------------------------------------
	Slave1
-----------------------------------------------------------------------------
Slaves should be run with the --log-bin option, and if not using GTIDs then
they should also be run without --log-slave-updates. In this way, the slave
is ready to become a master without restarting the slave mysqld.
-----------------------------------------------------------------------------
Web Client switch to new Master==Slave1

Slave1

/etc/my.cnf

[mysqld]
server-id=2
log-bin=mysql-bin

mysql> STOP SLAVE; and 
mysql> RESET MASTER;


Slave2,3
mysql> STOP SLAVE; and 
mysql> CHANGE MASTER TO MASTER_HOST='Slave1' (user, password, port)
----------------------------------------------------------------------------
Make sure that all slaves have processed any statements in their relay log.
On each slave, issue STOP SLAVE IO_THREAD, then check the output of
SHOW PROCESSLIST until you see Has read all relay log. When this is true for
all slaves, they can be reconfigured to the new setup. On the slave Slave 1
being promoted to become the master, issue STOP SLAVE and RESET MASTER. 
-----------------------------------------------------------------------------
 On the other slaves Slave 2 and Slave 3, use STOP SLAVE and CHANGE MASTER TO
MASTER_HOST='Slave1' (where 'Slave1' represents the real host name of Slave 1).
To use CHANGE MASTER TO, add all information about how to connect to Slave 1
from Slave 2 or Slave 3 (user, password, port). When issuing the CHANGE MASTER
TO statement in this, there is no need to specify the name of the Slave 1 binary
log file or log position to read from, since the first binary log file and
position 4, are the defaults. Finally, execute START SLAVE on Slave 2 and Slave 3.

Once the new replication setup is in place, you need to tell each Web Client
to direct its statements to Slave 1. From that point on, all updates statements
sent by Web Client to Slave 1 are written to the binary log of Slave 1, which
then contains every update statement sent to Slave 1 since Master turnoff. 
-----------------------------------------------------------------------------
When Master becomes available again, you should make it a slave of Slave 1.
To do this, issue on Master the same CHANGE MASTER TO statement as that issued
on Slave 2 and Slave 3 previously. Master then becomes a slave of S1ave 1 and
picks up the Web Client writes that it missed while it was offline.

To make Master a master again, use the preceding procedure as if Slave 1 was
unavailable and Master was to be the new master. During this procedure, do
not forget to run RESET MASTER on Master before making Slave 1, Slave 2, and
Slave 3 slaves of Master. If you fail to do this, the slaves may pick up stale
 writes from the Web Client applications dating from before the point at which
Master became unavailable.

You should be aware that there is no synchronization between slaves, even when
they share the same master, and thus some slaves might be considerably ahead
of others. This means that in some cases the procedure outlined in the previous
example might not work as expected. In practice, however, relay logs on all
slaves should be relatively close together.
----------------------------------------------------------------------------
dynamic DNS
----------------------------------------------------------------------------
One way to keep applications informed about the location of the master is to
have a dynamic DNS entry for the master. With bind you can use nsupdate to
update the DNS dynamically. 
----------------------------------------------------------------------------
Алгоритм репликации
----------------------------------------------------------------------------
1. Узнать master_log_file = "mysql-bin.000001", master_log_pos = 11716;
затем отановить мускул на запись на Мастере,
 
2. Зделать снапшот раздела с DB

3. Запустить DB на запись

4. Перенести нужные бызы и базы в которых есть иннодб на подчиненный сервер

5. Отредактировать конфиг и права на папки и файлов на подчиненном сервере 

6. Запустить MySql на подчиненном сервере

7. Запустить команду настройки репликации и какой логин и пароль для этого использовать

8. Затем запустить mysql>start slave;
-----------------------------------------------------------------------------
mysql> SHOW MASTER STATUS\G
mysql> show slave status\G
mysql>change master to master_host = "192.168.1.48", master_user = "root", master_password="Pwd1980", master_log_file = "mysql-bin.000004", master_log_pos = 106;
mysql>start slave;
    SHOW BINARY LOGS
    SHOW BINLOG EVENTS
    SHOW MASTER STATUS
    SHOW SLAVE HOSTS 
 RESET MASTER
-----------------------------------------------------------------------------
lvdisplay
pvdisplay
vgdisplay

fdisk -l
df -h

проверка CRON
-----------------------------------------------------------------------------
NFS
-----------------------------------------------------------------------------
mount device dir - монтирование/подключение файлового устройства device в
каталог dir (запуск без параметров выводит список уже смонтированных устройств)

    -a - монтирование всех файловых систем, указанных в /etc/fstab (включая те,
которые имеют параметр noauto)
    -t fstype - указание типа файловой системы (ntfs, nfs, ext3 и т.п.)
    -h - помощь
    -r - монтирование в режиме только чтения
    -o parametr=znachen- устанавливает параметры монтирования:
        conv=auto - автоконвертирование текста их формата MSDOS в UNIX (замена
символа конца строки CR-LF на LF)
        ro - монтирование в режиме только для чтения

umount dir/mount_point - размонтирует файловые системы

    -a - размонтирование всех файловых систем, указанных в /etc/fstab, кроме корневой

FILES ~ # mount -t nfs archiv:/archiv-small /archivs/archiv-small
FILES ~ # mount -t nfs -o ro archiv:/archiv-big /archivs/archiv-big
FILES ~ # mount
.......
archiv:/archiv-small on /archivs/archiv-small type nfs (rw,addr=10.0.0.6)
archiv:/archiv-big on /archivs/archiv-big type nfs (ro,addr=10.0.0.6)

FILES ~ # cat /etc/fstab | grep nfs
archiv:/archiv-small     /archivs/archiv-small  nfs     rw,timeo=4,rsize=16384,wsize=16384   0       0
nfs-server:/archiv-big   /archivs/archiv-big    nfs     rw,timeo=50,hard,fg                  0       0

# mount.nfs 192.168.1.1:/home/nfs3 /mnt/nfs3
# mount.nfs4 192.168.1.1:/ /mnt/nfs4
# mount.nfs4 192.168.1.1:/part1 /mnt/nfs4/part1

-----------------------------------------------------------------------------
Создание репликации
-----------------------------------------------------------------------------
1. mysql@master> FLUSH TABLES WITH READ LOCK;
SET GLOBAL read_only=ON;

1.2 mysql> show master status;
File: mysql-bin.0*
Position: 98

2. lvcreate -L2G -s -n snap002 /dev/mapper/vg_snap-lv_test01

lvdisplay

3. UNLOCK TABLES;
SET GLOBAL read_only=OFF;

4. mysql> show master status;
 master_log_file = "mysql-bin.000001", master_log_pos = 11716;

6. mount /dev/vg_snap/snap002 /mnt/snap

7.NFS в /etc/exports
/mnt/snap 192.168.1.0/255.255.255.0(rw,no_root_squash)

exportfs -r

service rpcbind restart
service nfs restart

chkconfig rpcbind on
chkconfig nfs on

rpcinfo -p localhost | grep nfs

7. mount.nfs 192.168.1.48:/mnt/snap /mnt/snap/

8. Проверка my.cnf

9. Очищаем папку /var/lib/mysq – rm -R /var/lib/mysql/*

9. Копируем c NFS snapshot DB в /var/lib/mysql/

10. Выставляем владельца

chown -RP mysql:mysql /var/lib/mysql
restorecon -R -v /var/lib/mysql

11. Если редактировали my.cnf service mysqld stop, service mysqld start

12. mysql>change master to master_host = "192.168.1.48", master_user = "root", master_password="Pwd1980", master_log_file = "mysql-bin.000004", master_log_pos = 106;

mysql>start slave;
mysql>show slave status;

13. Отключиться от NFS сервера. На NFS сервере

14. sevice nfs stop.
15. umount /mnt/mysqlsnapshot/
16. lvremove -f /dev/vg_db-1/mysqlsnapshot
-----------------------------------------------------------------------------
Пример конфигурации Мастера
-----------------------------------------------------------------------------
[mysqld]

#
# * Basic Settings
#
explicit_defaults_for_timestamp
skip-external-locking
innodb_file_per_table
#relay_log_recovery

low_priority_updates = 1

relay-log-info-repository = TABLE
master-info-repository = TABLE

slave_parallel_workers = 4

sql_mode = NO_ENGINE_SUBSTITUTION

#
# * Fine Tuning
#
key_buffer_size         = 8G
join_buffer_size        = 4M
max_allowed_packet      = 16M
thread_stack            = 192K
thread_cache_size       = 64
open_files_limit        = 12000

# This replaces the startup script and checks MyISAM tables if needed
# the first time they are touched
myisam-recover-options  = BACKUP
myisam_sort_buffer_size = 8G
read_rnd_buffer_size    = 1M
max_connections         = 400
table_open_cache        = 2048
table_definition_cache  = 2048

max_heap_table_size     = 20G
tmp_table_size          = 1G

#
# * Query Cache Configuration
#
query_cache_type        = 1
query_cache_limit       = 1M
query_cache_size        = 2048M

innodb_buffer_pool_size = 32G
innodb_log_file_size    = 512M
innodb_log_buffer_size  = 16M
innodb_flush_log_at_trx_commit = 2
innodb_thread_concurrency = 8
innodb_flush_method     = O_DIRECT
innodb_lock_wait_timeout = 120

innodb_sort_buffer_size = 512M
innodb_online_alter_log_max_size = 2G

#
# * Logging and Replication
#
#==================MASTER==================
server-id                = 1
log_bin                  = mysqld-bin
expire_logs_days         = 3
max_binlog_size          = 1G
binlog-format            = MIXED
#==================SLAVE===================
relay_log                = mysqld-relay-bin
replicate-wild-do-table  = billing.%
replicate-wild-do-table  = billing_archive.%
replicate-wild-do-table  = billing_ua.%
replicate-wild-do-table  = common.%
replicate-wild-do-table  = context_motor.%
replicate-wild-do-table  = daily_logs.%
replicate-wild-do-table  = gearman.%
replicate-wild-do-table  = geo.%
replicate-wild-do-table  = irr.%
replicate-wild-do-table  = links_buying_common.%
replicate-wild-do-table  = links_buying_ru.%
replicate-wild-do-table  = links_buying_ua.%
replicate-wild-do-table  = market.%
replicate-wild-do-table  = mysql.%
replicate-wild-do-table  = sso.%
#replicate-wild-do-table  = tmp_table.%
replicate-wild-do-table  = top_analyser.%
#==========================================

log_error = /var/log/mysql/error.log

slow_query_log_file = /var/log/mysql/mysql-slow.log
slow_query_log = 1
long_query_time = 5
#log-queries-not-using-indexes

[mysqladmin]
user = log
password = 2wsxcvnm1QAZ3EDC4rfv
-----------------------------------------------------------------------------
Master
-----------------------------------------------------------------------------
my.cnf
-----------------------------------------------------------------------------
binlog-format=ROW

Бывает трех видов — STATEMENT, MIXED и ROW
В двух словах — statement пишет в бинлог по сути sql запросы. Преимущества —
старый формат, оттестированный, лог небольшой, можно посмотреть запросы.
Недостатки — проблемы с функциями и триггерами, запросы вида update user set
a=1 order by rand(), а так же еще некоторые могут некорректно отрабатываться.
ROW если совсем упрощенно — пишет в логи измененные бинарные данные.
Преимущества — отлично логируются все виды запросов. Недостатки — огромный лог.
Ну и mixed — промежуточный формат, который старается использовать statement,
когда возможно, а когда нет — row. Говорят, что глючит на каких то очень
сложных запросах. Именно его я и рискнул использовать
-----------------------------------------------------------------------------
binlog-checksum=crc32
Новая фича mysql5.6, вроде как ускоряет работу бинлога

gtid-mode=on
Собственно и включает ту самую GTID mode репликацию

enforce-gtid-consistency=true
Запрещает все, что может поломать транзакции.

log-slave-updates=true
В родной документации написано: указывает подчиненному серверу, чтобы тот вел
записи об обновлениях, происходящих на подчиненном сервере, в двоичном журнале.
По умолчанию эта опция выключена. Ее следует включить, если требуется
организовать подчиненные серверы в гирляндную цепь.

server-id = 1
Уникальный номер для каждого сервера

ну и не забываем указать что именно мы будем реплицировать —
replicate-do-db = mybase
replicate-do-table=mybase.mytable1
replicate-do-table=mybase.mytable2

После этого необходимо создать пользователя mysql с правами репликации.
Например так
GRANT replication slave ON *.* TO «replication»@'192.168.1.102' IDENTIFIED BY 'password';

На этом настройка мастера закончена. Вливаем дамп и в бой )
-----------------------------------------------------------------------------
Слейв
-----------------------------------------------------------------------------
В простейшем варианте на слейв можно скопировать тот же конфиг, что и на мастере,
единственное что — нужно сменить server_id, например на 2.

Перезапускаем слейв, и запускаем репликацию

change master to master_host='192.168.1.1", master_auto_position=1,
Master_User=’replication’, master_password=’password';
start slave;

и любуемся

show slave status \G
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
PHP5/7/alternatives
-----------------------------------------------------------------------------
alternatives
-----------------------------------------------------------------------------
alternatives ->	L8.UPDATE -> alternatives for php
-----------------------------------------------------------------------------

Существуют как минимум 2 репозитория, которые можно подключить к CentOS 7 и 
установить обновление php70. Это либо ius с пакетом php70u, либо webtactic с php70w.
-----------------------------------------------------------------------------
# curl 'https://setup.ius.io/' -o setup-ius.sh
# bash setup-ius.sh
-----------------------------------------------------------------------------
	php5
-----------------------------------------------------------------------------
yum install php php-common php-cli php-fpm php-pear php-cgi php-mysql
-----------------------------------------------------------------------------
	php7
-----------------------------------------------------------------------------
# service httpd stop
# service php-fpm stop
# yum -y remove php

# wget https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm
# wget http://rpms.remirepo.net/enterprise/remi-release-7.rpm
# rpm -Uvh remi-release-7.rpm epel-release-latest-7.noarch.rpm

# yum --enablerepo=remi update remi-release
# yum -y --enablerepo=remi-php70 install php70-php php70-php-pear php70-php-bcmath
php70-php-pecl-jsond-devel php70-php-mysqlnd php70-php-gd php70-php-common
php70-php-fpm php70-php-intl php70-php-cli php70-php php70-php-xml
php70-php-opcache php70-php-pecl-apcu php70-php-pecl-jsond php70-php-pdo
php70-php-gmp php70-php-process php70-php-pecl-imagick php70-php-devel
php70-php-mbstring

# rm -f /usr/bin/php
# ln -s /usr/bin/php70 /usr/bin/php
# service httpd restart
# service php70-php-fpm start

Инсталляция завершена, проверим версию и основные параметры PHP. Из командной
строки это можно сделать с помощью команды php -v:

php -v
PHP 7.0.2 (cli)
-----------------------------------------------------------------------------
	Откат
-----------------------------------------------------------------------------
Откат обновления php 7.0 до php 5.6
-----------------------------------------------------------------------------
yum remove php70u-bcmath php70u-devel php70u-fpm php70u-gd php70u-ldap
php70u-mbstring php70u-mcrypt php70u-odbc php70u-pdo php70u-pear
php70u-pecl-memcache php70u-process php70u-snmp php70u-soap php70u-tidy
php70u-xml php70u-xmlrpc php70u-cli php70u-mysqlnd php70u-fpm-nginx
php70u-pecl-apcu php70u-common
-----------------------------------------------------------------------------
# wget http://rpms.remirepo.net/enterprise/remi-release-7.rpm
# rpm -Uvh remi-release-7*.rpm
-----------------------------------------------------------------------------
yum --enablerepo=remi,remi-php56 install php php-common php-bcmath php-devel
php-fpm php-gd php-ldap php-mbstring php-mcrypt php-mysql php-odbc php-pdo
php-pear php-pecl-memcache php-php-gettext php-process php-snmp php-soap
php-tcpdf php-tcpdf-dejavu-sans-fonts php-tidy php-xml php-xmlrpc php-pecl-apcu
phpMyAdmin
-----------------------------------------------------------------------------
Перезапускаем php-fpm. Он может ругнуться на строку:

listen.acl_users = nginx

Если так, то удалите ее. 
-----------------------------------------------------------------------------
Отмена обновления php 5.6 и возврат на php 5.4
-----------------------------------------------------------------------------
yum remove php php-common php-bcmath php-devel php-fpm php-gd php-ldap
php-mbstring php-mcrypt php-mysql php-odbc php-pdo php-pear php-pecl-memcache
php-php-gettext php-process php-snmp php-soap php-tcpdf
php-tcpdf-dejavu-sans-fonts php-tidy php-xml php-xmlrpc php-pecl-apcu
-----------------------------------------------------------------------------
yum install php php-common php-bcmath php-devel php-fpm php-gd php-ldap
php-mbstring php-mcrypt php-mysql php-odbc php-pdo php-pear php-pecl-memcache
php-php-gettext php-process php-snmp php-soap php-tcpdf
php-tcpdf-dejavu-sans-fonts php-tidy php-xml php-xmlrpc phpMyAdmin
-----------------------------------------------------------------------------
Файл конфигурации
-----------------------------------------------------------------------------
Файл конфигурации (php.ini) считывается при запуске PHP. Для версий серверных
модулей PHP это происходит только один раз при запуске веб сервера. Для CGI и
CLI версиий это происходит при каждом вызове.
-----------------------------------------------------------------------------
//etc/php5/php.ini
/etc/php5/fpm.conf
/etc/php5/www.conf
/etc/php5/conf.d/*.so
/etc/php5/conf.d/*.ini

Настройки пулов в
CentOS хранятся в директории 
/etc/php-fpm.d/www.conf
Debian/Ubuntu – 
/etc/php5/fpm/pool.d/www.conf
и там уже есть файл настроек по-умолчанию – www.conf.
-----------------------------------------------------------------------------
Проставим правильные права каталогам:

    chown -R www-data /var/www/example.ru && chmod -R 750 /var/www/example.ru
-----------------------------------------------------------------------------
	/etc/php5/fpm/php.ini
-----------------------------------------------------------------------------
Исправляем уязвимость связанную с
location ~ .php$ {
, для этого прописываем в /etc/php5/fpm/php.ini
   	cgi.fix_pathinfo=0
-----------------------------------------------------------------------------
Если планируется загрузка больших файлов 
	post_max_size = 200M
 и ниже
	upload_max_filesize = 200M
-----------------------------------------------------------------------------
# sudo nano /etc/php5/fpm/pool.d/www.conf
-----------------------------------------------------------------------------
security.limit_extensions = .php .php3 .php4 .php5

Эта настройка ограничит выполнение файлов по расширению имени.
-----------------------------------------------------------------------------
listen = /var/run/php5-fpm.sock

Это определит файл для связи «Nginx» с «PHP-FPM» (сокет). 
-----------------------------------------------------------------------------
В целях безопасности запрещаем какой-попало программе писать в сокет
-----------------------------------------------------------------------------
listen.owner = www-data
listen.group = www-data
listen.mode = 0660
# sudo service php5-fpm restart
# ls -la /var/run/php5-fpm.sock
srw-rw---- 1 www-data www-data 0 May  2 16:36 /var/run/php5-fpm.sock
-----------------------------------------------------------------------------
Редактируем /etc/nginx/sites-enabled/default — добавляет в секцию
location / привязку расширения .php к php-fpm:
-----------------------------------------------------------------------------
location ~ \.php$ {
                      fastcgi_pass   unix:/var/run/php-fpm/default.socket;
                      include fastcgi_params;
                      fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
              }
-----------------------------------------------------------------------------
Включим использование chroot, для ограничения доступа PHP к системе.
Для этого редактируем файл /etc/php5/fpm/php5-fpm.conf, прописываем:

    chroot = /var/www
    chdir = /
-----------------------------------------------------------------------------
	Где могут быть установлены параметры конфигурации 
-----------------------------------------------------------------------------
Эти режимы определяют, когда и где директива PHP может или не может быть
установлена, и каждая директива в руководстве относится к одному из этих
режимов. К примеру, некоторые настройки могут быть установлены с помощью
PHP-скрипта, использующего ini_set(), тогда как другие могут требовать
php.ini или httpd.conf. 
-----------------------------------------------------------------------------
Определение режимов PHP_INI_*
-----------------------------------------------------------------------------
Режим		Смысл
-----------------------------------------------------------------------------
PHP_INI_USER 	Значение может быть установлено в пользовательских скриптах
		(с помощью ini_set()) или в реестре Windows. С версии PHP 5.3
		значение может быть установлено в .user.ini  
PHP_INI_PERDIR 	Значение может быть установлено в php.ini, .htaccess или
		httpd.conf (С версии PHP 5.3)  
PHP_INI_SYSTEM 	Значение может быть установлено в php.ini или httpd.conf 
PHP_INI_ALL 	Значение может быть установлено отовсюду
-----------------------------------------------------------------------------
	FPM
-----------------------------------------------------------------------------
FPM использует синтаксис php.ini для своего файла конфигурации php-fpm.conf
и файлов конфигурации пулов.
-----------------------------------------------------------------------------
http://php.net/manual/ru/install.fpm.configuration.php
-----------------------------------------------------------------------------
	Список глобальных директив php-fpm.conf
-----------------------------------------------------------------------------
pid string
    Путь к PID файлу. По умолчанию: none.

error_log string
    Путь к файлу журнала ошибок. По умолчанию: 
#INSTALL_PREFIX#/log/php-fpm.log. Если задано как "syslog", логирование будет
производиться в syslogd, а не в локальный файл.

log_level string
    Уровень журналирования ошибок. Возможные значения: alert, error, warning,
notice, debug. По умолчанию: notice.

syslog.facility string
    Используется для указания, какой тип программ будет логировать сообщения.
По умолчанию: daemon.

syslog.ident string
    Предшествует любому сообщению. Если у вас запущено несколько инстансов
FPM, вы можете изменить значение по умолчанию на то, которое вам необходимо.
По умолчанию: php-fpm.

emergency_restart_threshold int
    При данном числе рабочих процессов, завершенных с SIGSEGV или SIGBUS за
промежуток времени, установленный emergency_restart_interval FPM будет
перезагружен. Значение 0 означает 'Off' (отключено). По умолчанию: 0 (Off).

emergency_restart_interval mixed
    Интервал времени, используемый emergency_restart_interval, чтобы определить,
когда FPM будет мягко перезагружен. Это полезно для избежания случайных
повреждений общей памяти ускорителя (accelerator). Доступные единицы
измерения: s(секунды), m(минуты), h(часы), или d(дни). Единица измерения по
умолчанию: секунды. Значение по умолчанию: 0 (Off).

process_control_timeout mixed
    Время, в течение которого дочерние процессы ждут ответа на сигналы
мастер-процессу. Доступные единицы измерения: s(секунды), m(минуты), h(часы)
или d(дни). Единица измерения по умолчанию: секунды. Значение по умолчанию: 0.

process.max int
    Максимальное количество процессов, которое может породить FPM. Это
сделано для того, чтобы контролировать глобальное количество процессов,
когда используется большой пул динамического PM. Используйте с осторожность.
По умолчанию: 0.

process.priority int
    Указывает приоритет (Unix nice(2)) мастер-процесса (только если
установлено). Принимает значения от -19(максимальный приоритет) до
20(минимальный.) По умолчанию: не установлено.

daemonize boolean
    Запустить FPM в фоновом режиме. Установите значение 'no', чтобы запустить
FPM в диспетчере для отладки. По умолчанию: yes.

rlimit_files int
    Устанавливает rlimit открытых файловых дескрипторов для мастер-процесса.
По умолчанию: Устанавливает rlimit для открытого дескриптора файла мастер-процесса(?).

rlimit_core int
    Устанавливает rlimit максимального размера ядра для мастер-процесса. По
умолчанию 0.

events.mechanism string
    Указывает, какой событийный механизм будет использован FPM. Возможны такие
варианты: select, pool, epoll, kqueue (*BSD), port (Solaris). По умолчанию: не
установлено (автоопределение).

systemd_interval int
    Если FPM собран с интекграцией с systemd, указывает интервал, в секундах,
между оповещениями systemd о своем состоянии. Для отключения задайте 0.
По умолчанию: 10.

-----------------------------------------------------------------------------
	Список директив для пулов.
-----------------------------------------------------------------------------
Вы можете запускать несколько FPM пулов процессов с различными настройками.
Эти параметры могут быть переданы пулу. 
-----------------------------------------------------------------------------
  listen string
    Адрес, который будет принимать FastCGI-запросы. Синтаксис:
'ip.add.re.ss:port', 'port', '/path/to/unix/socket'. Эта опция обязательна для
каждого пула.

listen.backlog int
    Устанавливает listen(2) backlog. Значение '-1' означает неограниченно.
Значение по умолчанию: -1.

listen.allowed_clients string
    Список IPv4 адресов FastCGI-клиентов, которые имеют право подключения.
Эквивалент переменной окружения среды FCGI_WEB_SERVER_ADDRS в оригинальном
PHP FastCGI (5.2.2+). Имеет смысл только с TCP-сокетом. Каждый адрес должен
быть отделен запятой. Если оставить значение пустым, то соединения будут
приниматься с любого IP. По умолчанию: any. Начиная с PHP 5.5.20 и 5.6.4,
можно использовать IPv6.

listen.owner string
    Задает права для unix socket, если они используются. В Linux, чтобы
разрешить соединения web серверу, должны быть установлены права на
чтение/запись. Во многих основанных на BSD системах возможность соединения
не зависит от прав доступа. Значение по умолчанию: используется пользователь
и группа, от имени которого запущен сервер, установлен режим 0660.

listen.group string
    См. listen.owner.

listen.mode string
    Смотри listen.owner.

listen.acl_users string
    Если поддерживается Список Контроля Доступа (ACL) POSIX, вы можете
настроить его с помощью этой опции. Если задано, то listen.owner и listen.group
будут проигнорированы. Значение задается списком имен, разделенных запятой.
Доступно с PHP 5.6.5.

listen.acl_groups string
    Смотри listen.acl_users. Значение задается списком имен групп, разделенных
запятой. Доступно с PHP 5.6.5.

user string
    Unix-пользователь FPM-процессов. Этот параметр является обязательным.

group string
    Unix-группа FPM-процессов. Если не установлен, группа по умолчанию
равняется имени пользователя.

pm string
    Выбор того, как менеджер процессов будет контролировать создание
дочерних процессов. Возможные значения: static, ondemand, dynamic. Этот
параметр является обязательным.

    static - фиксированное число дочерних процессов (pm.max_children).

    ondemand - число процессов, порождающихся по требованию (когда появляются
запросы, в отличии от опции dynamic, когда стартует определенное количество
процессов, равное pm.start_servers, вместе с запуском службы.

    dynamic - динамически изменяющееся число дочерних процессов, задается
на основании следующих директив: pm.max_children, pm.start_servers,
pm.min_spare_servers, pm.max_spare_servers.

pm.max_children int
    Число дочерних процессов, которые будут созданы, когда pm установлен в
static, или же максимальное число процессов, которые будут созданы, когда pm
установлен в dynamic. Этот параметр является обязательным.

    Этот параметр устанавливает ограничение на число одновременных запросов,
которые будут обслуживаться. Эквивалент директивы ApacheMaxClients с mpm_prefork
и переменной окружения среды PHP_FCGI_CHILDREN в в оригинальном PHP FastCGI.

pm.start_servers int
    Число дочерних процессов, создаваемых при запуске. Используется, только
когда pm установлен в dynamic. Значение по умолчанию: min_spare_servers +
(max_spare_servers - min_spare_servers) / 2.

pm.min_spare_servers int
    Желаемое минимальное число неактивных процессов сервера. Используется,
только когда pm установлено в dynamic. Кроме того, это обязательный параметр
в этом случае.

pm.max_spare_servers int
    Желаемое максимальное число неактивных процессов сервера. Используется,
только когда pm установлен в dynamic. Кроме того, это обязательный параметр
в этом случае.

pm.process_idle_timeout mixed
    Число секунд, по истечению которых простаивающий процесс будет завершен.
Используется только если pm установлено как ondemand. Допустимые единицы:
s(секунды)(по умолчанию), m(минуты), h(ours) или d(дни). По умолчанию: 10s.

pm.max_requests int
    Число запросов дочернего процесса, после которого процесс будет перезапущен.
Это полезно для избежания утечек памяти при использовании сторонних библиотек.
Для бесконечной обработки запросов укажите '0'. Эквивалент PHP_FCGI_MAX_REQUESTS.
Значение по умолчанию: 0.

pm.status_path string
    Ссылка, по которой можно посмотреть страницу состояния FPM. Если значение
не установлено, то страница статуса отображаться не будет. Значение по
умолчанию: none.

ping.path string
    Ссылка на ping-страницу мониторинга FPM. Если значение не установлено,
ping-страница отображаться не будет. Может быть использовано для тестирования
извне, чтобы убедиться, что FPM жив и реагирует. Обратите внимание, что
значение должно начинаться с косой черты (/).

ping.response string
    Эта директива может быть использована на настройки ответа на ping-запрос.
Ответ формируется как text/plain со кодом ответа 200. Значение по
умолчанию: pong.

process.priority int
    Задает приоритет nice(2) для работающего процесса (только если задан).
Значение от -19 (высший приоритет) до 20 (самый низкий). Значение по
умолчанию: не задано.

prefix string
    Задает префикс для вычисления пути

request_terminate_timeout mixed
    Таймаут для обслуживания одного запроса, после чего рабочий процесс
будет завершен. Этот вариант следует использовать, когда опция
'max_execution_time' в php.ini не останавливает выполнение скрипта по
каким-то причинам. Значение '0' означает 'выключено'. Доступные единицы
измерения: s(секунды), m(минуты), h(часы) или d(дни). Значение по
умолчанию: 0.

request_slowlog_timeout mixed
    Таймаут для обслуживания одного запроса, после чего PHP backtrace
будет сохранен в файл 'slowlog'. Значение '0' означает 'выключено'.
Доступные единицы измерения: s(секунды), m(минуты), h(часы) или d(дни).
Значение по умолчанию: 0.

slowlog string
    Лог-файл для медленных запросов. Значение по умолчанию:
#INSTALL_PREFIX#/log/php-fpm.log.slow.

rlimit_files int
    Устанавливает лимит дескрипторов открытых файлов rlimit для дочерних
процессов в этом пуле. Значение по умолчанию: определяется значением системы.

rlimit_core int
    Устанавливает максимальное количество используемых ядер rlimit для
дочерних процессов в этом пуле. Возможные значения: 'unlimited' или целое
число большее или равное 0. Значение по умолчанию: определяется значением
системы.

chroot string
    Директория chroot окружения при старте. Это значение должно быть
определено как абсолютный путь. Если значение не установлено, chroot
не используется.

chdir string
    Chdir изменяет текущую директорию при старте. Это значение должно
быть определено как абсолютный путь. Значение по умолчанию: текущая директория
или / при использовании chroot.

catch_workers_output boolean
    Перенаправление STDOUT и STDERR рабочего процесса в главный лог ошибок.
Если не установлен, STDOUT и STDERR будут перенаправлены в /dev/null в
соответствии со спецификацией FastCGI. Значение по умолчанию: no.

clear_env boolean
    Очищает окружение в "worker" процессах FPM. Prevents arbitrary
environment variables from reaching FPM worker processes by clearing the
environment in workers before env vars specified in this pool configuration
are added. Доступно с PHP 5.4.27, 5.5.11, и 5.6.0. По умолчанию: Yes.

security.limit_extensions string
    Ограничивает расширения, которые FPM будет разбирать. Это позволит
предотвратить ошибки на стороне веб-сервера. Вы должны ограничить FPM
только расширениями .php, чтобы предотвратить выполнение PHP-кода
нерадивыми пользователями из файлов с другими расширениями. По
умолчанию: .php .phar

access.log string
    Лог-файл доступа. Значение по умолчанию: не установлено

access.format string
    Формал лог-файла доступа. Значение по умолчанию: "%R - %u %t \"%m %r\" %s"

-----------------------------------------------------------------------------
  Можно передать дополнительные переменные окружения и обновить настройки PHP
для определенного пула. Для этого вам необходимо добавить следующие параметры
в файл настройки пула.
-----------------------------------------------------------------------------
 Пример #1 Передача переменных окружения и настроек PHP пулу
-----------------------------------------------------------------------------
 env[HOSTNAME] = $HOSTNAME
env[PATH] = /usr/local/bin:/usr/bin:/bin
env[TMP] = /tmp
env[TMPDIR] = /tmp
env[TEMP] = /tmp

php_admin_value[sendmail_path] = /usr/sbin/sendmail -t -i -f www@my.domain.com
php_flag[display_errors] = off
php_admin_value[error_log] = /var/log/fpm-php.www.log
php_admin_flag[log_errors] = on
php_admin_value[memory_limit] = 32M
-----------------------------------------------------------------------------
PHP настройки, переданные через php_value или php_flag перезапишут их
предыдущие значения. Пожалуйста, обратите внимание, что определения
disable_functions или disable_classes не будут будут перезаписывать ранее
определенные в php.ini значения, а добавят новые значения.
-----------------------------------------------------------------------------
Настройки, определенные через php_admin_value и php_admin_flag, не могут быть
перезаписаны через ini_set().
-----------------------------------------------------------------------------
Начиная с версии 5.3.3 настройки PHP можно устанавливать через веб-сервер.
-----------------------------------------------------------------------------
Пример #2 Установка настроек PHP в nginx.conf
-----------------------------------------------------------------------------
set $php_value "pcre.backtrack_limit=424242";
set $php_value "$php_value \n pcre.recursion_limit=99999";
fastcgi_param  PHP_VALUE $php_value;

fastcgi_param  PHP_ADMIN_VALUE "open_basedir=/var/www/htdocs";
-----------------------------------------------------------------------------
	Предостережение
-----------------------------------------------------------------------------
Так как эти настройки передаются в php-fpm как FastCGI-заголовки, php-fpm не
должен быть привязан к общедоступному адресу из мира. В противном случае
любой сможет изменить настройки PHP. Смотрите также listen.allowed_clients.
-----------------------------------------------------------------------------
	Создание пула PHP-FPM
-----------------------------------------------------------------------------
PHP-FPM позволяет изолировать различные приложения и веб-сайты, запуская их
при помощи индивидуальных пользователей, что является одним из основных
преимуществ данной реализации PHP. Такая функция называется пулом приложений (pool).
-----------------------------------------------------------------------------
	1: Создание пула PHP-FPM
-----------------------------------------------------------------------------		
Чтобы создать новый пул Nginx, нужно скопировать стандартный пул пользователя
www-data.
-----------------------------------------------------------------------------		
Важно! Не удаляйте стандартный пул. Как правило, его использует www-data,
а для других пользователей создаются отдельные пулы, чтобы сохранить
индивидуальные системные привилегии.
-----------------------------------------------------------------------------		
Просто скопируйте стандартный www.conf и переименуйте копию, указав имя
пользователя, которому будет принадлежать пул.
-----------------------------------------------------------------------------		
sudo cp /etc/php5/fpm/pool.d/www.conf /etc/php5/fpm/pool.d/username.conf

Примечание: Замените username именем своего пользователя.

Откройте файл в текстовом редакторе:

sudo nano /etc/php5/fpm/pool.d/username.conf

Отредактируйте его следующим образом:
-----------------------------------------------------------------------------		
; Start a new pool named 'www'.
; the variable $pool can we used in any directive and will be replaced by the
; pool name ('www' here)
[username]
; Note: The user is mandatory. If the group is not set, the default user's group
;       will be used.
user = username
listen = /var/run/php5-fpm.username.sock
или
listen = 127.0.0.1:9001
-----------------------------------------------------------------------------		
Примечание: В файле можно отредактировать и другие опции, однако в данном
руководстве для краткости исправлены только основные параметры.
-----------------------------------------------------------------------------		
Сохраните и закройте файл. Перезапустите PHP-FPM:

sudo service php5-fpm restart
-----------------------------------------------------------------------------		
	2: Редактирование виртуального хоста
-----------------------------------------------------------------------------		
После этого нужно отредактировать файлы виртуальных хостов, указав сокеты
для доступа к пулу.
-----------------------------------------------------------------------------		
Примечание: Инструкции по настройке блоков server в Ubuntu 12.04 LTS можно
найти в этом руководстве.
-----------------------------------------------------------------------------		
Откройте стандартный файл:

sudo nano /etc/nginx/sites-available/default

Или файл виртуального хоста:

sudo nano /etc/nginx/sites-available/example.com
-----------------------------------------------------------------------------		
Отредактируйте параметр:

fastcgi_pass unix:/var/run/php5-fpm.username.sock;
-----------------------------------------------------------------------------		
Примечание: Вместо username укажите имя своего пользователя.

Перезапустите Nginx:

sudo service nginx restart
-----------------------------------------------------------------------------		
Если перезапуск прошёл успешно, пул PHP-FPM успешно настроен. Чтобы создать
новый пул, повторите описанный выше процесс, заменив имя пользователя.
-----------------------------------------------------------------------------
	Список опций командной строки
-----------------------------------------------------------------------------
Usage: php [options] [-f] <file> [--] [args...]
   php [options] -r <code> [--] [args...]
   php [options] [-B <begin_code>] -R <code> [-E <end_code>] [--] [args...]
   php [options] [-B <begin_code>] -F <file> [-E <end_code>] [--] [args...]
   php [options] -- [args...]
   php [options] -a

  -a               Интерактивный запуск
  -c <path>|<file> Ищет файл php.ini в указанной директории
  -n               Не использовать файл php.ini
  -d foo[=bar]     Установить конфигурационную опцию foo значением 'bar'
  -e               Генерация дополнительной информации для отладчика и профайлера
  -f <file>        Парсит и исполняет <file>
  -h               Текущая справка
  -i               Выводит информацию о PHP
  -l               Проверка синтаксиса (lint)
  -m               Показать скомпилированные модули
  -r <code>        Запустить PHP-код без использования  <?..?>
  -B <begin_code>  Запустить PHP <begin_code> до обработки введенного кода
  -R <code>        Запустить PHP <code> для каждой введенной строки
  -F <file>        Парсить и выполнять <file> для каждой введенной строки
  -E <end_code>    Запустить PHP <end_code> после обработки всех введенных строк
  -H               Спрятать все переданные аргументы от внешних инструментов
  -S <addr>:<port> Запустить со встроенным веб-сервером.
  -t <docroot>     Указать корень документов <docroot> для встроенного веб-сервера.
  -s               Отображает исходный код с цветной подсветкой
  -v               Выводит информацию о версии PHP
  -w               Отображает исходный текст без комментариев и пробелов
  -z <file>        Загрузить Zend-расширение <file>.

  args...          Аргументы, передаваемые скрипту. Используйте -- args в случае, если
                   первый аргумент начинается с '-' или сам скрипт читается из потока STDIN.

  --ini            Показывать имена конфигурационных файлов

  --rf <name>      Показать информацию о функции <name>.
  --rc <name>      Показать информацию о классе <name>.
  --re <name>      Показать информацию о расширении <name>.
  --rz <name>      Показать информацию о Zend-расширении <name>.
  --ri <name>      Показать конфигурацию для расширения <name>.
-----------------------------------------------------------------------------
$ php --ini		Показывает имена конфигурационных файлов и сканируемые
			директории.
$ php -m  --modules 	Вывод встроенных (и загружаемых) PHP и Zend модулей
$ php -i --info 	Использование этой опции приводит к вызову функции
			phpinfo()
			и выводу результирующей информации.
$ php -f --file 	Парсит и исполняет файл, указанный в опции -f . Этот
			переключатель необязателен и может быть убран. Достаточно
			передавать только имя запускаемого файла
$ php -c --php-ini 	При помощи этой опции можно указать директорию для
			поиска конфигурационного файла php.ini либо непосредственно
			указать на сам INI-файл (название которого может отличаться
			от стандартного php.ini), например:
 
$ php -c /custom/directory/ my_script.php
$ php -c /custom/directory/custom-file.ini my_script.php

$ php -a --interactive PHP запускается интерактивно.
$ php -T --timing	Измерить время выполнения скрипта, повторенного count раз (только для CGI). 
$ php -r --run		Позволяет выполнять PHP-код, указанный непосредственно в командной строке. Открывающие и закрывающие PHP-теги (<?php и ?>) не нужны и, более того, приводят к синтаксической ошибке
$ php -s 		Показать исходный код с подсвеченным разными цветами синтаксисом. 
--syntax-highlight и 
--syntax-highlighting 

$ php -v --version 	Использование -v для получения типа SAPI и версии PHP и Zend
$ php -z 		Загружает Zend-расширение. Если передано только имя 
--zend-extension 	файла, PHP попытается загрузить это расширение из
 			вашего системного пути поиска библиотек по умолчанию
			(обычно он указывается в /etc/ld.so.conf в Linux системах).
			Передача файла с абсолютным путем не будет использовать
			данный системный путь поиска. 
$ php --rf 		Показывают информацию об указанной функции или методе класса
--rfunction		(например, количество и названия параметров). Доступна,
			начиная с версии PHP 5.1.2. 
			Эта опция доступна только в случае если PHP был
			скомпилирован с поддержкой Reflection. 
--rc --rclass 		Показывает информацию об указанном классе.
--re --rextension 	Показывает информацию об указанном расширении (список опций
			php.ini, определенных функций, констант и классов). 
 --rz 			Показывает информацию о конфигурации указанного Zend-расширения
--rzendextension 	
--ri --rextinfo 	Показывает информацию о конфигурации указанного расширения
$ php -S --server 		Запускает встроенный веб-сервер.
$ php -S localhost:8000
-----------------------------------------------------------------------------
	Проверка сессии
-----------------------------------------------------------------------------
#php70 -S 0.0.0.0:8000
PHP 7.0.21 Development Server started at Thu Jul 27 13:11:35 2017
Listening on http://0.0.0.0:8000
Document root is /home/nextcloud/www

Если не авторизуется нет доступа к записи сессии:
mcedit /etc/opt/remi/php70/php-fpm.d/www.conf
php_value[session.save_path]    = /tmp 
-----------------------------------------------------------------------------
По умолчанию, PHP собирается одновременно как CLI и CGI программа, которая
может быть использована для обработки CGI-запросов. PHP как модуль сервера
выигрывает в производительности, однако PHP CGI позволяет запускать PHP от
пользователя, отличного от того, под которым исполняется сервер. 
-----------------------------------------------------------------------------
	Менеджер процессов FastCGI (FPM) 
-----------------------------------------------------------------------------
	PECL
-----------------------------------------------------------------------------
PECL - это репозиторий расширений PHP, доступ к которым предоставляется
через систему » PEAR. Эта часть руководства предназначена для демонстрации
того, как вы можете получить и установить расширения PECL. 
-----------------------------------------------------------------------------
Для того, чтобы расширение можно было использовать, оно должно быть собрано,
установлено и загружено.
----------------------------------------------------------------------------
 Расширения могут быть загружены с помощью директивы extension в файле php.ini,
или путем использования функции dl(). 
-----------------------------------------------------------------------------
В процессе сборки модулей PHP важно иметь нужные версии необходимых утилит
(autoconf, automake, libtool и т.д.). 
-----------------------------------------------------------------------------
◦ Команда pecl install extname автоматически скачивает код расширений, поэтому
в этом случае нет нужды в отдельной скачке этих файлов.  
◦ » http://pecl.php.net/  Вебсайт PECL содержит информацию о различных
расширениях, предоставляемых командой разработчиков PHP. Информация, доступная
на этом вебсайте, включает в себя: лог изменений, новости релизов, требования
и другие подобные детали.  
◦ pecl download extname  Расширения PECL, имеющих опубликованные релизы на
сайте PECL, доступны для скачивания и установки с помощью » команды pecl.
Можно также указать отдельные ревизии для установки.  
◦ SVN  Большинство расширений PECL, также, находятся в SVN. Веб-интерфейс для
просмотра доступен по адресу » http://svn.php.net/viewvc/pecl/. Для загрузки
напрямую из SVN используется следующая последовательность команд:  
 $ svn checkout http://svn.php.net/repository/pecl/extname/trunk extname
◦ Загрузка для Windows  На данный момент проект PHP не компилирует бинарные
файлы Windows для расширений PECL. Для компиляции PHP под Windows прочитайте
соответствующий раздел. 
-----------------------------------------------------------------------------
When using "pecl install package", you might run into a memory limit problem.
Solution is to use "pear install pecl/$extensionname" since it uses php.ini's
memory limit.
-----------------------------------------------------------------------------
If you get "pear.php.net is using a unsupported protocal" [sic!] do:
 cd /usr/local/lib/php
 rm -r .channels
 pear update-channels 
-----------------------------------------------------------------------------
	Компиляция разделяемых расширений с помощью команды pecl 
-----------------------------------------------------------------------------
 $ sudo yum install php-devel zlib-devel curl-devel gcc
 $ pear
 $ pear config-get php_dir
 $ php --ini
 $ php -c /path/to/php.ini -r 'echo get_include_path()."\n";'
 $ pecl install extname
 $ pear info PEAR
 $ pear list-files log
 $ pear search w3c
-----------------------------------------------------------------------------
Эта команда загрузит исходный код для расширения extname, скомпилирует и
установит extname.so в вашу директорию extension_dir. Файл extname.so может
быть затем загружен в php.ini 
-----------------------------------------------------------------------------
По умолчанию, команда pecl не будет устанавливать пакеты, отмеченные состоянием
alpha или beta. Если нет доступных стабильных (stable) версий пакетов, вы
можете установить beta-версию пакета, используя следующую команду:
-----------------------------------------------------------------------------
 $ pecl install extname-beta
-----------------------------------------------------------------------------
Также, вы можете установить определенную версию используя такой вариант: 
-----------------------------------------------------------------------------
 $ pecl install extname-0.1
-----------------------------------------------------------------------------
	Using channels
-----------------------------------------------------------------------------
Channels are alternative package sources. See the channel section of the
manual for more information.
-----------------------------------------------------------------------------
What you need to know now: By using channels, you can install packages that
are not part of PEAR. Prominent PHP projects like Horde and PHPUnit distribute
their software through PEAR-compatible channels.
-----------------------------------------------------------------------------
Channel discovery
-----------------------------------------------------------------------------
Before you can use a channel, your pear installation needs to know about it.
This process is called "channel discovery".

Once you know the project's channel url, just type:
-----------------------------------------------------------------------------
$ pear channel-discover pear.phpunit.de
-----------------------------------------------------------------------------
Downloading a channel.xml file, you can add a channel just using that file
using channel-add:
-----------------------------------------------------------------------------
$ pear channel-add my-channel.xml
-----------------------------------------------------------------------------
Using list-channels, you can get an overview of known channels:
-----------------------------------------------------------------------------
$ pear list-channels
-----------------------------------------------------------------------------
More insight about a channel can be gotten with channel-info.
-----------------------------------------------------------------------------
$ pear channel-info pear.php.net
-----------------------------------------------------------------------------
Work with packages on a channel
-----------------------------------------------------------------------------
$ pear install gnope/Dev_Inspector
-----------------------------------------------------------------------------
General rule is that when you would specify a package name, use
$channel/$packagename now. All other functions with channel support have a -c
option to specify the channel name or alias.
-----------------------------------------------------------------------------
Password protected channels:
-----------------------------------------------------------------------------
If 401 Authorization Required
-----------------------------------------------------------------------------
In this case, download the channel.xml file manually, for example with your
browser or wget. A channel.xml is always in the root directory of the channel
server. After that, discover the channel with the saved file:
-----------------------------------------------------------------------------
$ pear channel-add /path/to/saved/channel.xml
-----------------------------------------------------------------------------
Now the PEAR manager needs to know about the channel's username and password.
We tell him by using set-config in connection with the channel option:
-----------------------------------------------------------------------------
$ pear config-set -c pear.company.com username johndoe
config-set succeeded
$ pear config-set -c pear.company.com password secret
config-set succeeded
-----------------------------------------------------------------------------
Now test if we did everything right by showing available packages on the channel:
-----------------------------------------------------------------------------
$ pear list-all -c pear.company.com
-----------------------------------------------------------------------------
Command list
-----------------------------------------------------------------------------
http://pear.php.net/manual/en/guide.users.commandline.commands.php
-----------------------------------------------------------------------------
	Компиляция разделяемых расширений с помощью phpize 
-----------------------------------------------------------------------------
Иногда использование инсталятора pecl не подходит. Это может быть связано с
тем, что вы находитесь за файерволом или из-за того, что расширение, которое
вы хотите установить, недоступно в PECL-совместимом пакете (к примеру,
расширения из SVN, у которых еще нет релизов). Если вам необходимо собрать
такое расширение, вы можете использовать низкоуровневые утилиты для выполнения
сборки вручную. 

Команда phpize используется для подготовки окружения PHP-расширения. В
следующем примере директория, где находятся исходные коды расширения,
называется extname: 
-----------------------------------------------------------------------------
$ cd extname
$ phpize
$ ./configure
$ make
# make install
-----------------------------------------------------------------------------
В случае успешной установки будет создан файл extname.so и помещен в PHP
директорию расширений. Вам будет необходимо добавить строку extension=extname.so
в php.ini перед использованием этого расширения. 
-----------------------------------------------------------------------------
Если в системе нет phpize, но существует возможность установки заранее
скомпилированных пакетов (типа RPM), убедитесь, что установлена соответствующая
версия пакета PHP для разработчиков, так как они часто содержат команду phpize
с подходящими файлами заголовков для сборки PHP и его расширений. 
-----------------------------------------------------------------------------
Для дополнительной информации используйте команду phpize --help.
-----------------------------------------------------------------------------
	php-config 
-----------------------------------------------------------------------------
php-config - это простой шелл-скрипт для получения информации о конфигурации
установленного PHP. 

При компиляции расширений, если у вас установлено сразу несколько версий PHP,
вы должны уточнить нужную версию с помощью опции --with-php-config во время
конфигурирования сборки, указав путь до соответствующего php-config скрипта. 

Список параметров командной строки доступных для php-config скрипта всегда
можно получить запустив php-config с параметром -h : 
-----------------------------------------------------------------------------
Usage: /usr/local/bin/php-config [OPTION]
Options:
  --prefix            [...]
  --includes          [...]
  --ldflags           [...]
  --libs              [...]
  --extension-dir     [...]
  --include-dir       [...]
  --php-binary        [...]
  --php-sapis         [...]
  --configure-options [...]
  --version           [...]
  --vernum            [...]
-----------------------------------------------------------------------------
Опция		Описание

--prefix 		Директория, в которой установлен PHP, например /usr/local 
--includes 		Список -I опций со всеми подключаемыми файлами 
--ldflags 		LD-флаги, с которыми был скомпилирован PHP 
--libs 			Внешние библиотеки, с которыми был скомпилирован PHP 
--extension-dir 	Директория, в которой по умолчанию ищутся расширения 
--include-dir 		Директория, куда по умолчанию устанавливаются заголовочные файлы 
--php-binary 		Полный путь до исполняемых файлов php CLI или CGI 
--php-sapis 		Показывает все доступные модули SAPI 
--configure-options 	Конфигурационные опции для воссоздания настроек текущей установки PHP. 
--version 		Версия PHP 
--vernum 		Версия PHP в виде целого числа 

-----------------------------------------------------------------------------
	Запуск PHP как модуля Apache 
-----------------------------------------------------------------------------
Когда PHP используется как модуль Apache вы также можете менять настройки
конфигурации, используя директивы в файлах конфигурации Apache (например,
httpd.conf) и файлах .htaccess. Для этого вам необходимы "AllowOverride
Options" или "AllowOverride All" привилегии. 

Есть несколько директив Apache, которые позволяют вам изменить конфигурацию
PHP посредством файлов конфигурации Apache. Директивы для PHP_INI_ALL,
PHP_INI_PERDIR, и PHP_INI_SYSTEM, вы можете увидеть в приложении Список
директив php.ini
-----------------------------------------------------------------------------
 php_value name value 
Устанавливает значение обозначенной директивы. Может использоваться только
с директивами типа PHP_INI_ALL и PHP_INI_PERDIR Для очистки предыдущих
установленных значений используйте значение none. 

Замечание: Не используйте php_value для установки логических значений.
Вместо этого необходимо использоватьphp_flag (см. ниже).  

 php_flag name on|off 
Используется для установки директивам логических значений. Может быть
использовано только с директивами типа PHP_INI_ALL и PHP_INI_PERDIR.
 
 php_admin_value name value 
Устанавливает значение обозначенной директивы. Не может быть использовано
в файлах .htaccess. Директивы любого типа, установленные с помощью 
php_admin_value не могут быть переопределены через .htaccess или ini_set().
Чтобы очистить предыдущее значение используйте значение none.
 
 php_admin_flag name on|off 
Используется для установки директивам логических значений. Не может быть
использовано в файлах .htaccess. Директивы любого типа, установленные с
помощью php_admin_flag не могут быть переопределены через .htaccess или
ini_set().
-----------------------------------------------------------------------------
Пример #1 Пример конфигурации Apache
-----------------------------------------------------------------------------
<IfModule mod_php5.c>
  php_value include_path ".:/usr/local/lib/php"
  php_admin_flag engine on
</IfModule>
<IfModule mod_php4.c>
  php_value include_path ".:/usr/local/lib/php"
  php_admin_flag engine on
</IfModule>
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
Apache
-----------------------------------------------------------------------------
Install
Commands
Configuration
VirtualHost
MPM – multi-processing module
.htpasswd/.htaccess/Access by IP
Modules/IFModule/LoadModule
Rewright
SSL
-----------------------------------------------------------------------------
	Install
-----------------------------------------------------------------------------
hostname -f
sudo yum clean all
yum -y update
sudo yum -y install httpd
sudo firewall-cmd --permanent --add-port=80/tcp
sudo firewall-cmd --permanent --add-port=443/tcp
sudo firewall-cmd --reload
или
sudo firewall-cmd --add-service=http --permanent && sudo firewall-cmd --add-service=https --permanent
sudo systemctl restart firewalld
sudo systemctl start httpd
sudo systemctl enable httpd
-----------------------------------------------------------------------------
cp /etc/httpd/conf/httpd.conf ~/httpd.conf.backup
/etc/httpd/conf/httpd.conf

      DocumentRoot "/var/www/html/example.com/public_html"

    ...

    <IfModule prefork.c>
        StartServers        5
        MinSpareServers     20
        MaxSpareServers     40
        MaxRequestWorkers   256
        MaxConnectionsPerChild 5500
    </IfModule>
sudo systemctl restart httpd
-----------------------------------------------------------------------------
	Commands
-----------------------------------------------------------------------------
	apachectl
-----------------------------------------------------------------------------
В первом режиме Apachectl выступает как интерфейс для получения HTTPD-команд.
Просмотреть доступные команды можно с помощью ключа -h, либо же выполнив
команду Apachectl без аргументов:
-----------------------------------------------------------------------------
# apachectl -h
Usage: /usr/local/sbin/httpd [-D name] [-d directory] [-f file]
                             [-C "directive"] [-c "directive"]
                             [-k start|restart|graceful|graceful-stop|stop]
                             [-v] [-V] [-h] [-l] [-L] [-t] [-S]
Options:
  -D name            : define a name for use in <IfDefine name> directives
  -d directory       : specify an alternate initial ServerRoot
  -f file            : specify an alternate ServerConfigFile
  -C "directive"     : process directive before reading config files
  -c "directive"     : process directive after reading config files
  -e level           : show startup errors of level (see LogLevel)
  -E file            : log startup errors to file
  -v                 : show version number
  -V                 : show compile settings
  -h                 : list available command line options (this page)
  -l                 : list compiled in modules
  -L                 : list available configuration directives
  -t -D DUMP_VHOSTS  : show parsed settings (currently only vhost settings)
  -S                 : a synonym for -t -D DUMP_VHOSTS
  -t -D DUMP_MODULES : show all loaded modules
  -M                 : a synonym for -t -D DUMP_MODULES
  -t                 : run syntax check for config files

Для примера, воспользуемся двумя самыми простыми коммандами:
# apachectl -v
Server version: Apache/2.2.17 (FreeBSD)
Server built:   Dec 18 2010 20:45:37
# apachectl -t
Syntax OK

Первая команда - узнали версию програмного обеспечения web-сервера. Вторая
- проверили конфигурационный файл на наличие ошибок.

Советую поэкспериментировать с остальными ключами.
-----------------------------------------------------------------------------
Во втором режиме Apachectl работает как сценарий инициализации, позволяя
запустить, остановить и перезапустить web-сервер. Доступные ключи:
-----------------------------------------------------------------------------
    start - запуск демона Apache HTTPD. Выдает ошибку, если он уже запущен.
Аналог apachectl -k start.
    stop - останов демона Apache HTTPD. Аналог apachectl -k stop.
    restart - перезапуск демона Apache HTTPD. Если демон не запущен,
он запускается. Эта команда автоматически проверяет файлы конфигурации
(запуск Apachectl с ключем configtest) перед началом перезапуска, чтобы
убедиться, что демон не будет остановлен вследствии ошибки конфигурации.
Аналог apachectl -k restart.
    fullstatus - отображает полный рапорт о состоянии с помощью модуля
mod_status. Необходимо, чтобы mod_status был включен в конфигурации демона
Apache. Также необходима поддержка текстового браузера (например lynx).
URL-адрес используется для отчета о статусе и может задаваться переменной
STATUSURL.
    status - отображение базового отчета о статусе демона Apache. Похоже
на fullstatus, только список запросов на данный момент не отображается.
    graceful -  "мягкий" перезапуск демона Apache HTTPD. Если демон не запущен,
он запускается. Отличие от restart в том, что уже открытые соединения не
разрываются. Побочным эффектом является то, что старые файлы журналов не
будут немедленно закрыты. Эта команда автоматически проверяет файлы
конфигурации (запуск Apachectl с ключем configtest) перед началом перезапуска,
чтобы убедиться, что демон не будет остановлен вследствии ошибки конфигурации.
Аналог apachectl -k graceful.
    configtest - проверка синтаксиса файла конфигурации. Анализирует файлы
конфигурации и в случае положительной проверки, выводит "Syntax OK". Если
же в файле конфигурации присутствует ошибка, то будет выведена подробная
информация о ошибке.

# apachectl configtest
# apachectl -k graceful
# apachectl -k graceful
# apachectl status
# apachectl fullstatus
restart 
-----------------------------------------------------------------------------
	htpasswd
-----------------------------------------------------------------------------
# sudo htpasswd -c /etc/httpd/.htpasswd user1

Only use -c the first time you create the file. Do not use -c when you add a
user in the future.
-----------------------------------------------------------------------------
# htpasswd

Usage:
	htpasswd [-cmdpsD] passwordfile username
	htpasswd -b[cmdpsD] passwordfile username password

	htpasswd -n[mdps] username
	htpasswd -nb[mdps] username password
-c Create a new file.
-n Don't update file; display results on stdout.
-m Force MD5 encryption of the password.
-d Force CRYPT encryption of the password (default).
-p Do not encrypt the password (plaintext).
-s Force SHA encryption of the password.
-b Use the password from the command line rather than prompting for it.
-D Delete the specified user.
On Windows, NetWare and TPF systems the '-m' flag is used by default.
On all other systems, the '-p' flag will probably not work.

-----------------------------------------------------------------------------
	htcacheclean
-----------------------------------------------------------------------------
# /etc/init.d/apache2 stop -- Debian or Ubuntu
# apachectl -k graceful-stop -- RHEL, CentOS or Fedora

# htcacheclean -r

# /etc/init.d/apache2 start -- Debian or Ubuntu
# apachectl start -- RHEL, CentOS or Fedora
-----------------------------------------------------------------------------
Periodically Cleaning the Cache
-----------------------------------------------------------------------------
# htcacheclean -d30 -n -t -p /var/cache/apache2/mod_disk_cache -l 100M -i

If need
# killall -9 htcacheclean
-----------------------------------------------------------------------------
How To Configure Apache Content Caching on CentOS 7 
https://www.digitalocean.com/community/tutorials/how-to-configure-apache-content-caching-on-centos-7
-----------------------------------------------------------------------------
How to Flush Apache's Cache
-----------------------------------------------------------------------------
https://www.techwalla.com/articles/how-to-flush-apaches-cache
-----------------------------------------------------------------------------
Пример 1	Модули mod_cache и mod_disk_cache
-----------------------------------------------------------------------------
Модули mod_cache и mod_disk_cache
Теперь включить:

    a2enmod cache
    a2enmod disk_cache
    /etc/init.d/apache2 restart
-----------------------------------------------------------------------------
Чтобы каталог для кеша /var/cache/apache2/mod_disk_cache не переполнится через
какое-то время, придется чистить его командой htcacheclean.

Эта команда часть пакета apache2-utils,
 После можно запустить htcacheclean как демон:
-----------------------------------------------------------------------------
htcacheclean -d30 -n -t -p /var/cache/apache2/mod_disk_cache -l 100M -i
-----------------------------------------------------------------------------
Это позволит чистить каталог с кешем каждые 30 минут и удостовериться, что он
не превысит 100MB.

-----------------------------------------------------------------------------
Пример 2	mod_mem_cache
-----------------------------------------------------------------------------

Конфигурация mod_mem_cache в mem_cache.conf
CacheEnable mem /

    MCacheSize 4096
    MCacheMaxObjectCount 100
    MCacheMinObjectSize 1
    MCacheMaxObjectSize 2048

Это конфигурация по умолчанию. Список директив для mod_mem_cache досотупен в ман.
Включим mod_cache и mod_mem_cache:

    a2enmod cache
    a2enmod mem_cache
    /etc/init.d/apache2 restart

-----------------------------------------------------------------------------
Пример 3	mod_disk_cache
-----------------------------------------------------------------------------
Configuring Apache mod_disk_cache
-----------------------------------------------------------------------------
 To configure Apache to cache static Confluence content:
-----------------------------------------------------------------------------
   1. Add a mod_disk_cache stanza to the virtual host configuration:
-----------------------------------------------------------------------------
    <IfModule mod_disk_cache.c>
      # "/s" is where Confluence serves "static" stuff. Instruct Apache to cache it:
      CacheEnable disk /s
      CacheIgnoreHeaders Set-Cookie
      CacheRoot "/var/cache/mod_proxy"
    </IfModule>
-----------------------------------------------------------------------------
   2. Configure Apache to load mod_disk_cache. For example, in our server
configuration this is done in /etc/httpd/conf/httpd.conf:
-----------------------------------------------------------------------------
    LoadModule disk_cache_module modules/mod_disk_cache.so

   3. Restart Apache after both modifications are complete.
-----------------------------------------------------------------------------
Notes

    Please refer to the Apache documentation for mod_disk_cache.
-----------------------------------------------------------------------------
    If you encounter problems where users are served stale content, you may need
to purge the Apache cache directory (/var/cache/mod_proxy in the above
configuration) after a Confluence or plugin upgrade. This is a simple 3 step process:
-----------------------------------------------------------------------------
        Shutdown Apache.
        Clear the cache directory. For example: sudo rm -r /var/cache/mod_proxy/*
        Restart Apache.
-----------------------------------------------------------------------------
    Ensure that you are running the htcacheclean daemon in order to prevent
excessive use of disk space. In our situation we ran it like this:
-----------------------------------------------------------------------------
    sudo htcacheclean -d30 -n -t -p /var/cache/mod_proxy -l 512M
-----------------------------------------------------------------------------
    This will purge content once the cache reaches 512M every 30 minutes.
 See the Apache documentation for htcacheclean for details of the options
-----------------------------------------------------------------------------
	Configuration
-----------------------------------------------------------------------------
/etc/httpd/conf/httpd.conf
/etc/httpd/conf.d/*.conf
/etc/httpd/conf.modules.d/10-php.conf ->
->
	<IfModule prefork.c>
  		LoadModule php5_module modules/libphp5.so
	</IfModule>
-----------------------------------------------------------------------------
/etc/httpd/conf.modules.d/00-base.conf ->
->
	LoadModule rewrite_module modules/mod_rewrite.so
	#LoadModule reflector_module modules/mod_reflector.so
-----------------------------------------------------------------------------
	#cat /etc/httpd/conf/httpd.conf
-----------------------------------------------------------------------------
ServerRoot "/etc/httpd"
Include conf.modules.d/*.conf
User apache
Group apache
ServerAdmin root@localhost

<Directory />
    AllowOverride none
</Directory>

DocumentRoot "/var/www/html"
<Directory "/var/www">
    AllowOverride None
    Require all granted
</Directory>

<Directory "/var/www/html">
    Options Indexes FollowSymLinks
    AllowOverride None
    Require all granted
</Directory>

DirectoryIndex index.php index.html

<Files ".ht*">
    Require all denied
</Files>

ErrorLog "logs/error_log"
LogLevel warn

LogFormat "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\"" combined
LogFormat "%h %l %u %t \"%r\" %>s %b" common
LogFormat "%b" bytes
CustomLog "logs/access_log" combined

TypesConfig /etc/mime.types
AddType application/x-compress .Z
AddType application/x-gzip .gz .tgz
AddType text/html .shtml
AddOutputFilter INCLUDES .shtml
#AddHandler cgi-script .cgi

AddDefaultCharset UTF-8

<IfModule mime_magic_module>
    MIMEMagicFile conf/magic
</IfModule>

EnableSendfile on

<IfModule remoteip_module>
    RemoteIPHeader X-Real-IP
    LogFormat "%a %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\"" combined
    LogFormat "%a %l %u %t \"%r\" %>s %b" common
</IfModule>

IncludeOptional conf.d/*.conf

-----------------------------------------------------------------------------
	VirtualHost
-----------------------------------------------------------------------------
Как настроить виртуальные хосты в Apache на Ubuntu 16.04 
-----------------------------------------------------------------------------
https://www.digitalocean.com/community/tutorials/apache-ubuntu-16-04-ru
-----------------------------------------------------------------------------
<VirtualHost *:80>
    ServerAdmin admin@example.com
    ServerName example.com
    ServerAlias www.example.com
    DocumentRoot /var/www/example.com/public_html
    ErrorLog ${APACHE_LOG_DIR}/error.log
    CustomLog ${APACHE_LOG_DIR}/access.log combined
</VirtualHost>
-----------------------------------------------------------------------------
#NameVirtualHost *:80

<VirtualHost *:80>
    <IfModule mod_php5.c>
        AddType application/x-httpd-php .php
        DirectoryIndex index.php index.html index.htm
    </IfModule>
    ServerAdmin some@admin
    DocumentRoot "/path/to/hostname/docroot"
    <Directory "/path/to/hostname/docroot">
         AllowOverride All
         Order Deny,Allow
         Allow from all
    </Directory>
    ServerName hostname
    ServerAlias www.hostname
    ErrorLog /path/to/hostname/error.log
#    CustomLog /path/to/hostname/access.log common
</VirtualHost>
-----------------------------------------------------------------------------
	MPM – multi-processing module
-----------------------------------------------------------------------------
	worker – это поточный MPM, каждый запрос обслуживается в отдельном
потоке.
-----------------------------------------------------------------------------
	prefork – в этом случае используется несколько процессов, каждый
процесс обслуживает одно подключение. РУКОМЕНДУЕТСЯ
-----------------------------------------------------------------------------
	evente
-----------------------------------------------------------------------------
сколько памяти в килобайтах потребляет каждый процесс Apache можно такой командой:

# ps -ylC httpd | awk {'print $8,$13'};
-----------------------------------------------------------------------------
	.htpasswd/.htaccess/Access by IP
-----------------------------------------------------------------------------
	.htpasswd
-----------------------------------------------------------------------------
# sudo nano /etc/httpd/conf/httpd.conf

Find the section that begins with <Directory "/var/www/html">.
Change the line from AllowOverride none to AllowOverride AuthConfig

AllowOverride AuthConfig
-----------------------------------------------------------------------------
Так же для некоторых директив(AuthUserFile и AuthGroupFile) нужна поддержка mod_auth 
-----------------------------------------------------------------------------
# sudo htpasswd -c /etc/httpd/.htpasswd user1

Only use -c the first time you create the file. Do not use -c when you add a
user in the future.
-----------------------------------------------------------------------------
# sudo chown apache:apache /etc/httpd/.htpasswd
# sudo chmod 0660 /etc/httpd/.htpasswd

allow the apache user to read the .htpasswd file.
-----------------------------------------------------------------------------
	.htaccess	Configure Apache password authentication
-----------------------------------------------------------------------------
# sudo nano /var/www/html/.htaccess

Add the following content:

AuthType Basic
AuthName "Restricted Content"
AuthUserFile /etc/httpd/.htpasswd
Require valid-user

Save and close the file, then restart Apache to make these changes take effect.

# sudo apachectl restart
-----------------------------------------------------------------------------
	Access by IP
-----------------------------------------------------------------------------
Внимание! Если вы хотите использовать эти директивы в файле .htaccess,
проверьте, что бы для вашего хоста директива AllowOverride корневого файла
конфигурации Apache включала опцию Limit
-----------------------------------------------------------------------------
Order
-----------------------------------------------------------------------------
Значения: Order (allow,deny | deny,allow)
-----------------------------------------------------------------------------
Директива Order указывает порядок, в котором будет производиться чтение из
директив Allow и Deny

    Allow,deny - сначала читаются директивы Allow. Если пользователя нет в этом
списке, то он блокируется. Если же он есть, то далее считываются директивы
Deny(процесс еще не закончен). Если же пользователь есть и там, то он
блокируется. Если его там нет, то он пропускается. Т.е пользователь пропускается
только при наличии только в списке Allow, но не в Deny
    Deny,allow - сначала обрабатываются директивы Deny и отсеиваются те
пользователи, которые есть в этом списке. Любые другие пропускаются. Т.е
пользователь пропускается всегда, но если его нет в списке Deny 
-----------------------------------------------------------------------------
Allow и Deny
-----------------------------------------------------------------------------
Формат директив: (Allow | Deny) from (IP | IPs | all) (IP | IPs | all) : (IP | IPs | all)
-----------------------------------------------------------------------------
Директивы Allow и Deny определяют клиентов, которым разрешить или запретить
доступ к серверу.
-----------------------------------------------------------------------------
Директивы допускают использование:

    Одиночного IP(IP) - обычный вид IP, например, 127.0.0.1
    Группы IP(IPs) - группа IP, например, для доступа, только из локальной
сети, 192.168.1.0/24
    Любого IP(all) - обозначает любой IP 
-----------------------------------------------------------------------------
После слова from может идти любое количество указанных директив, разделенных
пробелом
-----------------------------------------------------------------------------
Примеры
-----------------------------------------------------------------------------
Файл .htaccess

Order allow,deny
# Deny from all # если вы это напишите, то даже те адреса,
# которые указаны в директивах Allow не будет пропущены
Allow from 192.168.1.0/24 11.11.11.12
-----------------------------------------------------------------------------
В этом файле указывается доступ только для клиентов из локальной сети или с
IP 11.11.11.12
-----------------------------------------------------------------------------
Часть файла httpd.conf
-----------------------------------------------------------------------------
...
<Directory "/home/Site.ru">
Order deny,allow
Deny from 33.250.11.25
</Diectory>
...
-----------------------------------------------------------------------------
Так мы баним сайт для какого-нибудь одного IP 
-----------------------------------------------------------------------------
	Modules/IFModule/LoadModule
-----------------------------------------------------------------------------
IFModule Модули мультиобработки worker, prefork
Выполняется только если указанный модуль загружен.
-----------------------------------------------------------------------------
LoadModule - Загружают DSO модули
-----------------------------------------------------------------------------
/etc/httpd/conf/httpd.conf
      ServerRoot "/etc/httpd"
      Include /etc/conf.modules.d/*.conf
      DocumentRoot "/var/www/html/example.com/public_html"

    ...

    <IfModule prefork.c>
        StartServers        5
        MinSpareServers     20
        MaxSpareServers     40
        MaxRequestWorkers   256
        MaxConnectionsPerChild 5500
    </IfModule>
-----------------------------------------------------------------------------
<IfModule mod_disk_cache.c>
      # "/s" is where Confluence serves "static" stuff. Instruct Apache to cache it:
      CacheEnable disk /s
      CacheIgnoreHeaders Set-Cookie
      CacheRoot "/var/cache/mod_proxy"
    </IfModule>
-----------------------------------------------------------------------------
<IfModule mime_magic_module>
    MIMEMagicFile conf/magic
</IfModule>
-----------------------------------------------------------------------------
<IfModule remoteip_module>
    RemoteIPHeader X-Real-IP
    LogFormat "%a %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\"" combined
    LogFormat "%a %l %u %t \"%r\" %>s %b" common
</IfModule>
-----------------------------------------------------------------------------
/etc/httpd/conf.modules.d/10-php.conf ->
->
	<IfModule prefork.c>
  		LoadModule php5_module modules/libphp5.so
	</IfModule>
-----------------------------------------------------------------------------
/etc/httpd/conf.modules.d/00-base.conf ->
->
	LoadModule rewrite_module modules/mod_rewrite.so
	#LoadModule reflector_module modules/mod_reflector.so
-----------------------------------------------------------------------------
	Rewright
-----------------------------------------------------------------------------
Модуль mod_rewrite - URL преобразований сервера Apache/Директивы
-----------------------------------------------------------------------------
http://htaccess.net.ru/doc/mod_rewrite/mod_rewrite.php
-----------------------------------------------------------------------------
	SSL
-----------------------------------------------------------------------------
Apache -> SSL -> L6.LAEMP -> #SSL/TLS
-----------------------------------------------------------------------------
Nginx
-----------------------------------------------------------------------------
/etc/nginx/nginx.conf
/etc/nginx/conf.d/*.conf
/etc/nginx/sites-available/
/etc/nginx/sites-enabled/
-----------------------------------------------------------------------------
nginx -t
nginx -s reload
-----------------------------------------------------------------------------
	Basic HTTP Authentication With Nginx on CentOS 7
-----------------------------------------------------------------------------
# sudo yum install -y httpd-tools
# sudo apt-get install apache2-utils
-----------------------------------------------------------------------------
To create the password, run the following command.

# sudo htpasswd -c /etc/nginx/.htpasswd nginx
# htpasswd -c /path/to/directory/.htpasswd username

/path/to/directory – the full path to the directory that we want to set authentication for
username – the username that we will use for authentication
-----------------------------------------------------------------------------
You can check the contents of the newly-created file to see the username and
hashed password.

# cat /etc/nginx/.htpasswd
-----------------------------------------------------------------------------
Example /etc/nginx/.htpasswd

nginx:$apr1$ilgq7ZEO$OarDX15gjKAxuxzv0JTrO/

-----------------------------------------------------------------------------
# sudo nano /etc/nginx/nginx.conf
-----------------------------------------------------------------------------
server {
    listen       80 default_server;
    listen       [::]:80 default_server;
    server_name  _;
    root         /usr/share/nginx/html;

    auth_basic "Private Property";
    auth_basic_user_file /etc/nginx/.htpasswd;
. . .

# sudo systemctl reload nginx
-----------------------------------------------------------------------------
	Install CentOS
-----------------------------------------------------------------------------
/etc/yum.repos.d/nginx.repo и таким содержимым:

    [nginx]
    name=nginx repo
    baseurl=http://nginx.org/packages/OS/OSRELEASE/$basearch/
    gpgcheck=0
    enabled=1

Замените “OS” на “rhel” или “centos”, в зависимости от используемого
дистрибутива, а “OSRELEASE” на “6” или “7”, для, соответственно, 6.x или 7.x версий. 
-----------------------------------------------------------------------------
	Динамические модули
-----------------------------------------------------------------------------
Для того чтобы избежать увеличения числа зависимостей, основной пакет nginx
не включает модули, которым требуются дополнительные библиотеки. Начиная
с версии 1.9.11 nginx поддерживает динамические модули, и следующие модули
собираются как динамические и поставляются в виде отдельных пакетов:

    nginx-module-geoip
    nginx-module-image-filter
    nginx-module-njs
    nginx-module-perl
    nginx-module-xslt

-----------------------------------------------------------------------------
Синтаксис: 	load_module файл;
Умолчание: 	—
Контекст: 	main

Эта директива появилась в версии 1.9.11.

Загружает динамический модуль.

Пример:

    load_module modules/ngx_mail_module.so;

-----------------------------------------------------------------------------
	Configuration /etc/nginx/nginx.conf
-----------------------------------------------------------------------------
nginx состоит из модулей, которые настраиваются директивами, указанными в
конфигурационном файле.
Директивы делятся на простые и блочные, оканчивается точкой с запятой (;) и { и }.
Если у блочной директивы внутри фигурных скобок можно задавать другие директивы,
то она называется контекстом (примеры: events, http, server и location). 
-----------------------------------------------------------------------------
user nobody; # a directive in the 'main' context

events {
    # configuration of connection processing
}

http {

    # Configuration specific to HTTP and affecting all virtual servers

    server {
        # configuration of HTTP virtual server 1

        location /one {
            # configuration for processing URIs with '/one'
        }

        location /two {
            # configuration for processing URIs with '/two'
        }
    }

    server {
        # configuration of HTTP virtual server 2
    }
}

stream {
    # Configuration specific to TCP and affecting all virtual servers

    server {
        # configuration of TCP virtual server 1 
    }
}
include conf.d/http;
include conf.d/stream;
include conf.d/exchange-enhanced;
-----------------------------------------------------------------------------
Директивы, помещённые в конфигурационном файле вне любого контекста,
считаются находящимися в контексте main. Директивы events и http располагаются
в контексте main, server — в http, а location — в server. 
-----------------------------------------------------------------------------
Раздача статического содержимого
-----------------------------------------------------------------------------
server {
    location / {
        root /data/www;
    }

    location /images/ {
        root /data;
    }
-----------------------------------------------------------------------------
Настройка простого прокси-сервера
-----------------------------------------------------------------------------
server {
    listen 8080;
    root /data/up1;

    location / {
    }
}
server {
    location / {
        proxy_pass http://localhost:8080/;
    }

    location ~ \.(gif|jpg|png)$ {
        root /data/images;
    }
}
-----------------------------------------------------------------------------
Configuring Buffers
-----------------------------------------------------------------------------
By default NGINX buffers responses from proxied servers. A response is stored
in the internal buffers and is not sent to the client until the whole response
is received. Buffering helps to optimize performance with slow clients, which
can waste proxied server time if the response is passed from NGINX to the
client synchronously. However, when buffering is enabled NGINX allows the
proxied server to process responses quickly, while NGINX stores the responses
for as much time as the clients need to download them.
-----------------------------------------------------------------------------
In the following example, the default number of buffers is increased and the
size of the buffer for the first portion of the response is made smaller than
the default.
-----------------------------------------------------------------------------
location /some/path/ {
    proxy_buffers 16 4k;
    proxy_buffer_size 2k;
    proxy_pass http://localhost:8000;
}
-----------------------------------------------------------------------------
Настройка проксирования FastCGI
-----------------------------------------------------------------------------
server {
    location / {
        fastcgi_pass  localhost:9000;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param QUERY_STRING    $query_string;
    }

    location ~ \.(gif|jpg|png)$ {
        root /data/images;
    }
}
-----------------------------------------------------------------------------
Настройка HTTPS-серверов
-----------------------------------------------------------------------------
$ nginx -V
...
TLS SNI support enabled
...
-----------------------------------------------------------------------------
worker_processes auto;

http {
    ssl_session_cache   shared:SSL:10m;
    ssl_session_timeout 10m;

    server {
	listen              80;
        listen              443 ssl;
        server_name         www.example.com;
        keepalive_timeout   70;

        ssl_certificate     www.example.com.crt;
        ssl_certificate_key www.example.com.key;
        ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;
        ssl_ciphers         HIGH:!aNULL:!MD5;
        ...
    }
}
-----------------------------------------------------------------------------
Если сертификат сервера и связка сертификатов были соединены в неправильном
порядке, nginx откажется запускаться и выдаст сообщение об ошибке: 
-----------------------------------------------------------------------------
 Браузеры обычно сохраняют полученные промежуточные сертификаты, подписанные
доверенными центрами сертификации, поэтому активно используемые браузеры уже
могут иметь требуемые промежуточные сертификаты и не выдать предупреждение о
сертификате, присланном без связанной с ним цепочки сертификатов. Убедиться
в том, что сервер присылает полную цепочку сертификатов, можно при помощи
утилиты командной строки openssl, например:

    $ openssl s_client -connect www.godaddy.com:443
-----------------------------------------------------------------------------
Если связку сертификатов не добавили, будет показан только сертификат сервера №0. 
-----------------------------------------------------------------------------
Конфигурация простого сайта PHP
-----------------------------------------------------------------------------
Теперь посмотрим на то, как nginx выбирает location для обработки запроса на
примере обычного простого PHP-сайта: 
-----------------------------------------------------------------------------
server {
    listen      80;
    server_name example.org www.example.org;
    root        /data/www;

    location / {
        index   index.html index.php;
    }

    location ~* \.(gif|jpg|png)$ {
        expires 30d;
    }

    location ~ \.php$ {
        fastcgi_pass  localhost:9000;
        fastcgi_param SCRIPT_FILENAME
                      $document_root$fastcgi_script_name;
        include       fastcgi_params;
    }
}
-----------------------------------------------------------------------------
Regular expression
-----------------------------------------------------------------------------
A regular expression is preceded with the tilde (~) for case-sensitive matching,
or the tilde-asterisk (~*) for case-insensitive matching. The following example
matches URIs that include the string .html or .htm in any position.

location ~ \.html? {
    ...
}
-----------------------------------------------------------------------------
Returning Specific Status Codes
-----------------------------------------------------------------------------
Some website URIs require immediate return of a response with a specific error
or redirect code, for example when a page has been moved temporarily or permanently.
The easiest way to do this is to use the return directive. For example:

location /wrong/url {
    return 404;
}
-----------------------------------------------------------------------------
The first parameter of return is a response code. The optional second parameter
can be the URL of a redirect (for codes 301, 302, 303, and 307) or the text to
return in the response body. For example:

location /permanently/moved/url {
    return 301 http://www.example.com/moved/here;
}
-----------------------------------------------------------------------------
The return directive can be included in both the location and server contexts.
-----------------------------------------------------------------------------
nginx вначале ищет среди всех префиксных location’ов, заданных строками,
максимально совпадающий. В вышеприведённой конфигурации указан только один
префиксный location “/”, и поскольку он подходит под любой запрос, он и будет
использован, если других совпадений не будет найдено. Затем nginx проверяет
location’ы, заданные регулярными выражениями, в порядке их следования в
конфигурационном файле. При первом же совпадении поиск прекращается и nginx
использует совпавший location. Если запросу не соответствует ни одно из регулярных
выражений, nginx использует максимально совпавший префиксный location, найденный ранее. 
-----------------------------------------------------------------------------
	Имена сервера
-----------------------------------------------------------------------------
Имена сервера задаются с помощью директивы server_name и определяют, в каком
блоке server будет обрабатываться тот или иной запрос.
Имена могут быть заданы точно, с помощью маски или регулярного выражения: 
-----------------------------------------------------------------------------
server {
    listen       80;
    server_name  example.org  www.example.org;
    ...
}

server {
    listen       80;
    server_name  *.example.org;
    ...
}

server {
    listen       80;
    server_name  mail.*;
    ...
}

server {
    listen       80;
    server_name  ~^(?<user>.+)\.example\.net$;
    ...
}
-----------------------------------------------------------------------------
 При поиске виртуального сервера по имени, если имени соответствует несколько
из указанных вариантов, например, одновременно подходят и имя с маской, и
регулярное выражение, будет выбран первый подходящий вариант в следующем
порядке приоритета:

    точное имя
    самое длинное имя с маской в начале, например “*.example.org”
    самое длинное имя с маской в конце, например “mail.*”
    первое подходящее регулярное выражение (в порядке следования в конфигурационном файле)

-----------------------------------------------------------------------------
Имена с масками
-----------------------------------------------------------------------------
Имя с маской может содержать звёздочку (“*”) только в начале или в конце имени,
и только на границе, определяемой точкой. Имена “www.*.example.org” и
“w*.example.org” являются некорректными, но их можно задать с помощью регулярных
выражений, например, “~^www\..+\.example\.org$” и “~^w.*\.example\.org$”.
Звёздочка может соответствовать нескольким частям имени. Имени с маской
“*.example.org” соответствует не только www.example.org, но и www.sub.example.org.

Специальное имя с маской вида “.example.org” соответствует как точному имени
“example.org”, так и маске “*.example.org”. 
-----------------------------------------------------------------------------
Имена, заданные регулярными выражениями
-----------------------------------------------------------------------------
Регулярные выражения, используемые в nginx, совместимы с используемыми в языке
программирования Perl (PCRE). Имя сервера, заданное регулярным выражением,
должно начинаться с символа тильды:

    server_name  ~^www\d+\.example\.net$;

в противном случае оно будет рассматриваться как точное, или же, если выражение
содержит звёздочку (“*”), то как имя с маской (и, скорее всего, некорректное).
Не забывайте ставить специальные символы начала (“^”) и конца (“$”) строки.
По синтаксису они не требуются, но логически они могут быть нужны. Также
заметьте, что все точки в доменных именах должны быть экранированы символом
обратной косой черты. Регулярное выражение, содержащее символы “{” и “}”,
необходимо экранировать: 
-----------------------------------------------------------------------------
Прочие имена
-----------------------------------------------------------------------------
 Если необходимо обрабатывать запросы без поля “Host” в заголовке в блоке server,
который не является сервером по умолчанию, следует указать пустое имя:

    server {
        listen       80;
        server_name  example.org  www.example.org  "";
        ...
    }

Если директива server_name не задана в блоке server, то nginx будет использовать
пустое имя в качестве имени сервера. 
-----------------------------------------------------------------------------
 Если имя сервера задано как “$hostname” (0.9.4), то используется имя хоста
(hostname) машины.
-----------------------------------------------------------------------------
Если в запросе вместо имени сервера указан IP-адрес, то поле “Host” заголовка
запроса будет содержать IP-адрес, и запрос можно обработать, используя IP-адрес
как имя сервера:

    server {
        listen       80;
        server_name  example.org
                     www.example.org
                     ""
                     192.168.1.1
                     ;
        ...
    }

-----------------------------------------------------------------------------
 В примерах конфигурации серверов, обрабатывающих все запросы, встречается
странное имя “_”:

    server {
        listen       80  default_server;
        server_name  _;
        return       444;
    }

Оно не является каким-то особенным, это просто одно из множества некорректных
доменных имён, которые никогда не пересекутся ни с одним из реальных имён. С
тем же успехом можно использовать имена типа “--” и “!@#”. 
-----------------------------------------------------------------------------
специальное имя “*”
-----------------------------------------------------------------------------
Это имя действовало так же, как сейчас действует директива server_name_in_redirect.
Специальное имя “*” объявлено устаревшим, а вместо него следует использовать
директиву server_name_in_redirect. Заметьте, что с помощью директивы server_name
нельзя задать ни имя сервера для обработки всех запросов, ни сервер по умолчанию.
Это является свойством директивы listen, а не server_name.
-----------------------------------------------------------------------------
Сервер по умолчанию можно задать явно с помощью параметра default_server в
директиве listen:

    server {
        listen      80 default_server;
        server_name example.net www.example.net;
        ...
    }
-----------------------------------------------------------------------------
Следует иметь в виду, что сервер по умолчанию является свойством слушающего
порта, а не имени сервера.
-----------------------------------------------------------------------------
	Пример
-----------------------------------------------------------------------------
server {
    listen 80;
    server_name www.bambookites.com bambookites.com;
    access_log /srv/www/www.bambookites.com/logs/access.log;
    error_log /srv/www/www.bambookites.com/logs/error.log;
    root /srv/www/www.bambookites.com/public_html;

    location / {
        index  index.html index.htm index.php;
    }

    location ~ \.php$ {
        include /etc/nginx/fastcgi_params;
        fastcgi_pass  127.0.0.1:9000;
        fastcgi_index index.php;
        fastcgi_param  SCRIPT_FILENAME /srv/www/www.bambookites.com/public_html$fastcgi_script_name;
    }
}
-----------------------------------------------------------------------------
	Редактируем /etc/nginx/sites-enabled/default — добавляет в секцию
	location / привязку расширения .php к php-fpm:
-----------------------------------------------------------------------------
              location ~ \.php$ {
                      fastcgi_pass   unix:/var/run/php-fpm/default.socket;
                      include fastcgi_params;
                      fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
              }
-----------------------------------------------------------------------------
	Security
-----------------------------------------------------------------------------
https://nealpoole.com/blog/2011/04/setting-up-php-fastcgi-and-nginx-dont-trust-the-tutorials-check-your-configuration/
-----------------------------------------------------------------------------
In contrast, codex.wordpress.org provides an excellent configuration example
that warns people about and mitigates the vulnerability. I’ve reproduced the
relevant portion below:
-----------------------------------------------------------------------------
# Pass all .php files onto a php-fpm/php-fcgi server.
location ~ \.php$ {
   # Zero-day exploit defense.
   # http://forum.nginx.org/read.php?2,88845,page=3
   # Won't work properly (404 error) if the file is not stored on this server,
#which is entirely possible with php-fpm/php-fcgi.
   # Comment the 'try_files' line out if you set up php-fpm/php-fcgi on another
#machine.  And then cross your fingers that you won't get hacked.
   try_files $uri =404;

   fastcgi_split_path_info ^(.+\.php)(/.+)$;
   include fastcgi_params;
   fastcgi_index index.php;
   fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
#    fastcgi_intercept_errors on;
   fastcgi_pass php;
}
-----------------------------------------------------------------------------
	Rewriting URIs in Requests
-----------------------------------------------------------------------------
A request URI can be modified multiple times during request processing through
the use of the rewrite directive, which has one optional and two required
parameters. The first (required) parameter is the regular expression that the
request URI must match. The second parameter is the URI to substitute for the
matching URI. The optional third parameter is a flag that can halt processing
of further rewrite directives or send a redirect (code 301 or 302). For example:

location /users/ {
    rewrite ^/users/(.*)$ /show?user=$1 break;
}

As this example shows, the second parameter users captures though matching of
regular expressions.

You can include multiple rewrite directives in both the server and location
contexts. NGINX Plus executes the directives one-by-one in the order they
occur. The rewrite directives in a server context are executed once when
that context is selected.

After NGINX processes a set of rewriting instructions, it selects a location
context according to the new URI. If the selected location contains rewrite
directives, they are executed in turn. If the URI matches any of those, a
search for the new location starts after all defined rewrite directives are
processed.

The following example shows rewrite directives in combination with a return
directive.

server {
    ...
    rewrite ^(/download/.*)/media/(.*)\..*$ $1/mp3/$2.mp3 last;
    rewrite ^(/download/.*)/audio/(.*)\..*$ $1/mp3/$2.ra  last;
    return  403;
    ...
}

This example configuration distinguishes between two sets of URIs. URIs such
as /download/some/media/file are changed to /download/some/mp3/file.mp3. Because
of the last flag, the subsequent directives (the second rewrite and the return
directive) are skipped but NGINX Plus continues processing the request, which
now has a different URI. Similarly, URIs such as /download/some/audio/file are
replaced with /download/some/mp3/file.ra. If a URI doesn’t match either rewrite
directive, NGINX Plus returns the 403 error code to the client.

There are two parameters that interrupt processing of rewrite directives:

    last – Stops execution of the rewrite directives in the current server or
location context, but NGINX Plus searches for locations that match the rewritten
URI, and any rewrite directives in the new location are applied (meaning the URI
can be changed again).
    break – Like the break directive, stops processing of rewrite directives in
the current context and cancels the search for locations that match the new URI.
The rewrite directives in the new location are not executed.
-----------------------------------------------------------------------------
Rewriting HTTP Responses
-----------------------------------------------------------------------------
Sometimes you need to rewrite or change the content in an HTTP response,
substituting one string for another. You can use the sub_filter directive to
define the rewrite to apply. The directive supports variables and chains of
substitutions, making more complex changes possible.

For example, you can change absolute links that refer to a server other than
the proxy:

location / {
    sub_filter      /blog/ /blog-staging/;
    sub_filter_once off;
}

Another example changes the method from http:// to https:// and replaces the
localhost address to the host name from the request header field. The
sub_filter_once directive tells NGINX to apply sub_filter directives
consecutively within a location:

location / {
    sub_filter     'href="http://127.0.0.1:8080/'    'href="https://$host/';
    sub_filter     'img src="http://127.0.0.1:8080/' 'img src="https://$host/';
    sub_filter_once on;
}

Note that the part of the response already modified with the sub_filter will
not be replaced again if another sub_filter match occurs.
Handling Errors

With the error_page directive, you can configure NGINX Plus to return a custom
page along with an error code, substitute a different error code in the response,
or redirect the browser to a different URI. In the following example, the
error_page directive specifies the page (/404.html) to return with the 404 error code.

error_page 404 /404.html;

Note that this directive does not mean that the error is returned immediately
(the return directive does that), but simply specifies how to treat errors when
they occur. The error code can come from a proxied server or occur during
processing by NGINX Plus (for example, the 404 results when NGINX Plus can’t
find the file requested by the client).

In the following example, when NGINX Plus cannot find a page, it substitutes
code 301 for code 404, and redirects the client to http:/example.com/new/path.html.
This configuration is useful when clients are still trying to access a page at
its old URI. The 301 code informs the browser that the page has moved permanently,
and it needs to replace the old address with the new one automatically upon return.

location /old/path.html {
    error_page 404 =301 http:/example.com/new/path.html;
}

The following configuration is an example of passing a request to the back end
when a file is not found. Because there is no status code specified after the
equals sign in the error_page directive, the response to the client has the status
code returned by the proxied server (not necessarily 404).

server {
    ...
    location /images/ {
        # Set the root directory to search for the file
        root /data/www;

        # Disable logging of errors related to file existence
        open_file_cache_errors off;

        # Make an internal redirect if the file is not found
        error_page 404 = /fetch$uri;
    }

    location /fetch/ {
        proxy_pass http://backend/;
    }
}

The error_page directive instructs NGINX Plus to make an internal redirect when a
file is not found. The $uri variable in the final parameter to the error_page directive
holds the URI of the current request, which gets passed in the redirect.

For example, if /images/some/file is not found, it is replaced with /fetch/images/some/file
and a new search for a location starts. As a result, the request ends up in the second
location context and is proxied to http://backend/.

The open_file_cache_errors directive prevents writing an error message if a file is not
found. This is not necessary here since missing files are correctly handled.

-----------------------------------------------------------------------------
В нашем случае мы будем использовать 301 код, потому что некоторые веб-браузеры
или прокси-сервера будут кэшировать этот тип, делая старую страницу недоступной,
а это в данном случае именно то, что нам нужно.
-----------------------------------------------------------------------------
server {
	rewrite ^ http://host.ru$request_uri? permanent; #301 redirect
}
-----------------------------------------------------------------------------
if ($host = ‘www.domain.com’ ) {
 rewrite ^(.*)$ http://site.com$1 permanent;
 }
-----------------------------------------------------------------------------
return 301 $scheme://new-website.com$request_uri;
переменная $scheme запросит http:// или https:// в зависимости от того,
какой протокол использовал оригинальный веб-сайт
-----------------------------------------------------------------------------
 Пернаправит с http://example.com на http://site.com:

location http://example.com {
	rewrite ^(.*)$ http://site.com redirect;
}
-----------------------------------------------------------------------------
Будет перенаправлять все запросы с директории folder1 на директорию folder2:

location ^~ /folder1 {
	rewrite ^(.*)$ /folder2 redirect;
}
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
 /etc/nginx.conf
-----------------------------------------------------------------------------
Большинство настроек (не все) повторяют конфиг, поставляемый с nginx, а наиболее
интересные моменты снабжены комментариями.
-----------------------------------------------------------------------------
user www-data;
# Рекомендуется устанавливать по числу ядер
worker_processes 1;
pid /var/run/nginx.pid;
# Директива уменьшает разрешение времени в рабочих процессах, за счёт чего
# уменьшается число системных вызовов gettimeofday().

timer_resolution 100ms;
worker_rlimit_nofile 8192;
error_log  /var/log/nginx/error.log;
events {
    # Максимальное число подключений к серверу на один worker-процесс
        worker_connections 1024;
    # Эффективный метод обработки соединений, используемый в Linux 2.6+
    use epoll;
}
http {
        ##
        # Базовые настройки
        ##
        sendfile on;
        tcp_nopush on;
        tcp_nodelay on;
        keepalive_timeout 65;
        types_hash_max_size 2048;
        # При ошибках не говорим врагу версию nginx
        server_tokens off;
        include /etc/nginx/mime.types;
        default_type application/octet-stream;
    ##
    # Настройка логов
    ##
        access_log /var/log/nginx/access.log;
        error_log /var/log/nginx/error.log;
        ##
        # Настройки сжатия
        ##
    gzip on;
    gzip_disable "msie6";
        ##
        # Настройка виртуальных доменов
        ##
        include /etc/nginx/conf.d/*.conf;
        include /etc/nginx/sites-enabled/*;
}

-----------------------------------------------------------------------------
Настройка виртуального домена
-----------------------------------------------------------------------------
# Настрока редиректов c url вида http://foo.test.nixclub.ru/bar на url http://test.nixclub.ru/bar
server {
        listen 80;
        server_name *.test.nixclub.pro;
 
        rewrite ^(.*)$ http://test.nixclub.pro$1 permanent;
}
 
# Настройка виртуального домена:
 
server {
    ##
    # Уникальные настройки для домена
    ##
    server_name test.nixclub.pro;
    # Папка с контентом сайта (удобно, когда совпадает с именем домена)
    root /var/www/test.nixclub.pro;
    # Настройка логов, каждому виртуальному домену - свой лог
    access_log /var/log/nginx/test.nixclub.pro-access.log;
    error_log /var/log/nginx/test.nixclub.pro-error.log;
    ##
    # Типовые настройки общие для всех доменов (если не захочется экзотики)
    ##
    listen 80;
    index index.php;
    # Реализуем "красивые" ссылки для Drupal (и для ряда других CMS)
    location / {
    try_files $uri $uri/ /index.php?q=$uri&$args;
    }
    # Передаём обработку PHP-скриптов PHP-FPM
    location ~ \.php$ {
 
 
  # Соединение по TCP.
    fastcgi_pass   127.0.0.1:9000;
    # На виртуальных хостингах VPS(OpenVZ, etc) полезно соединяться через сокет
    # так как число TCP соединений может быть ограничено.
    # (пример натройки php-fpm через сокет есть в разделе 3.5)
    # fastcgi_pass   unix:/tmp/newpool.sock;
 
 
    fastcgi_index  index.php;
    fastcgi_intercept_errors on; # только на период тестирования
    # Включаем параметры из /etc/nginx/fastcgi_param
    include fastcgi_params;
    # Путь к скрипту, который будет передан в php-fpm
    fastcgi_param       SCRIPT_FILENAME  $document_root$fastcgi_script_name;
    fastcgi_ignore_client_abort     off;
    }
    # Закрываем доступ к файлами .htaccess и .htpassword
    location ~ /\.ht {
        deny  all;
    }
}
-----------------------------------------------------------------------------
Шаблоны сайтов в nginx
-----------------------------------------------------------------------------
server {
            listen 80;
            server_name *.test.nixclub.pro;
            rewrite ^(.*)$ http://test.nixclub.pro$1 permanent;
    }
    server {
        listen 80;
        server_name test.nixclub.pro;
        # Папка с контентом сайта (удобно, когда совпадает с именем домена)
        root /var/www/test.nixclub.pro;
        # Настройка логов, каждому виртуальному домену - свой лог
        access_log /var/log/nginx/test.nixclub.pro-access.log;
        error_log /var/log/nginx/test.nixclub.pro-error.log;
 
    # Подключаем шаблон
 
    include /etc/nginx/templates/drupal;
 
    }

А сам файл шаблона (/etc/nginx/templates/drupal) будет содержать следующие строки:
-----------------------------------------------------------------------------
index index.php;
# Реализуем "красивые" ссылки для Drupal (и для ряда других CMS)
location / {
try_files $uri $uri/ /index.php?q=$uri&$args;
}
# Передаём обработку PHP-скриптов PHP-FPM
location ~ \.php$ {
# Соединение по TCP.
fastcgi_pass   127.0.0.1:9000;
fastcgi_index  index.php;
fastcgi_intercept_errors on; # только на период тестирования
# Включаем параметры из /etc/nginx/fastcgi_param
include fastcgi_params;
# Путь к скрипту, который будет передан в php-fpm
fastcgi_param       SCRIPT_FILENAME  $document_root$fastcgi_script_name;
fastcgi_ignore_client_abort     off;
}
# Закрываем доступ к файлами .htaccess и .htpassword
location ~ /\.ht {
deny  all;
}
-----------------------------------------------------------------------------
 .htaccess !
-----------------------------------------------------------------------------
В Nginx нет никакого аналога апачевского .htaccess, поэтому если работа сайта
требует его наличия, то придётся переписывать его содержание в соответствии
с синтаксисом nginx в основную конфигурацию домена. В нашем конфиге .htaccess
был заменён следующим блоком:
	
location / {
    try_files $uri $uri/ /index.php?q=$uri&$args;
    }
-----------------------------------------------------------------------------
 Slowlog
-----------------------------------------------------------------------------
Очень полезно знать какие скрипты выполняются слишком долго и почему так
происходит. Для помощи в решении этой проблемы в php-fpm есть следующие
два параметра:

# Если скрипт будет выполняться больше указанного времени, то отладочная 
информация по нему будет записана в файл "медленных" запросов
    request_slowlog_timeout = 3s
 
    # Определяет путь к файлу "медленных" запросов (обязательный параметр, в
случае определения request_slowlog_timeout)
    slowlog = /var/log/php-slow.log
-----------------------------------------------------------------------------
Нагрузочное тестирование
-----------------------------------------------------------------------------
утилита для нагрузочного тестирования веб-серверов. Мы остановили наш выбор на sieg
-----------------------------------------------------------------------------
 Siege
-----------------------------------------------------------------------------
Для начала краткое описание опций программы, которые мы будем использовать:

-с <число> -- число одновременно запускаемых запросов;
-f <файл> -- файл содержащий набор ссылок, по которым будет обращаться программа
во время тестирования;
-i -- режим "internet", в этом режиме программ случайно выбирает адреса для запросов,
список адресов задаётся параметром -f;
-b -- режим "benchmark", все тесты при этом запускаются без пауз;
-t -- время тестирования.

Перевод документации на русский можно найти здесь: http://habrahabr.ru/blogs/webdev/65128/ .

В простейшем случае тестирование можно запустить так:
-----------------------------------------------------------------------------	
siege <url>
-----------------------------------------------------------------------------
 Подбор числа обработчиков php-fpm
-----------------------------------------------------------------------------
При подборе параметров мы воспользовались следующим методом (возможно это даже
наше know-how):

    Устанавливаем для php-fpm в качестве максимального числа обработчиков
(параметр pm.max_children) заведомо большое значение, мы использовали 20.
    Производим набор тестов следующего вида:

-----------------------------------------------------------------------------	
siege -i -b -t 1m -с <num> -f urls.txt
-----------------------------------------------------------------------------
При каждом новом тесте мы будем увеличивать <num> на 1 (т.е. при первом тесте
<num> = 1, при втором 2 и т.д.). По достижении определённого значения <num>
(у нас это было 8) число обработанных запросов в секунду начнёт уменьшаться,
значит нам нужно выбрать значении предыдущего тестирования (для нас это 7) в
качестве максимального числа обработчиков.
-----------------------------------------------------------------------------
SSL
-----------------------------------------------------------------------------
#########
#SSL/TLS
#########
[DV], [OV/EV] - Domain Validation  (DV), Organization Validation (OV) и Extended Validation (EV). 
DV - проверяется домен
OV/EV - проверяется организация
1.один домен(site.com)
2.wild card(*.site.com)
3.multy domain(site1.com,site2.com,site3.com)
1. Типы регистрируемых сертификатов
DV
	PositiveSSL
	GeoTrust QuickSSL Premium
	RapidSSL Wildcard
OV
	InstantSSL
	Multi-Domain SSL
	True BusinessID Wildcard
EV
	EV SSL
	SSL Web Server with EV
	EV Multi-Domain SSL

Генератор https://ru.rx-support.net/tools/csr-generator

2. Let's encrypt
----------------------------------------------------------------------------------
Test
https://www.ssllabs.com/ssltest/analyze.html?d=vinsanto.com.ua
----------------------------------------------------------------------------------
1.COMODORSADomainValidationSecureServerCA
2.COMODORSAAddTrustCA.crt
3.AddTrustExternalCARoot.crt
4.vinsanto_com_ua.crt
5.vinsanto.key
Для Vesta
http://бузони.рф/2015/04/27/%D1%83%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0-ssl-%D1%81%D0%B5%D1%80%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%B0-%D0%B2-vesta-cp/
COMODORSAAddTrustCA.crt
COMODORSADomainValidationSecureServerCA.crt
AddTrustExternalCARoot.crt.
-----------------------------------------------------------------------------
Установка на Apache/Nginx
-----------------------------------------------------------------------------
Apache
-----------------------------------------------------------------------------
SSLEngine on
    SSLVerifyClient none
    SSLCertificateFile /home/pikua/conf/web/ssl.pik.ua.crt
    SSLCertificateKeyFile /home/pikua/conf/web/ssl.pik.ua.key
    #SSLCertificateChainFile /home/pikua/conf/web/ssl.pik.ua.ca
-----------------------------------------------------------------------------
Nginx
-----------------------------------------------------------------------------
server {
    listen      195.189.227.41:443 ssl http2;
    server_name pik.ua www.pik.ua;
    resolver 8.8.8.8 8.8.4.4 valid=300s;
    resolver_timeout 3s;
    ssl         on;
    ssl_certificate      /home/pikua/conf/web/ssl.pik.ua.pem;
    ssl_certificate_key  /home/pikua/conf/web/ssl.pik.ua.key;
    ssl_session_timeout 24h;
    ssl_session_cache shared:SSLCACHE:1m;
    ssl_prefer_server_ciphers on; 
    ssl_ciphers ALL:!ADH:!EXP:!LOW:!RC2:!3DES:!SEED:!RC4:+HIGH:+MEDIUM;
#    ssl_session_tickets on; 
#    ssl_session_ticket_key /etc/nginx/ticket.key;
    ssl_buffer_size 4k;
#    error_log  /var/log/httpd/domains/pik.ua.error.log error;
    location / {
        proxy_pass      https://195.189.227.41:8443;
        location ~* ^.+\.(jpg|jpeg|gif|png|ico|svg|css|zip|tgz|gz|rar|bz2|exe|pdf|doc|xls|ppt|txt|odt|ods|odp|odf|tar|bmp|rtf|js|mp3|avi|mpeg|flv|html|htm)$ {
        root           /home/pikua/web/pik.ua/public_html;
        access_log     /var/log/httpd/domains/pik.ua.log combined;
        access_log     /var/log/httpd/domains/pik.ua.bytes bytes;
        expires        max;
        try_files      $uri @fallback;
    }
}
-----------------------------------------------------------------------------
.htaccess
-----------------------------------------------------------------------------
После вам пригодится файл .htaccess, добавьте в него парочку строчек:
    <IfModule mod_rewrite.c>
    RewriteEngine On
    RewriteCond %{HTTPS} off
    RewriteCond %{HTTP:X-Forwarded-Proto} !https
    RewriteRule ^(.*)$ https://%{HTTP_HOST}%{REQUEST_URI} [L,R=301]
    </IfModule>
Они для того чтобы сайт с протокола http редиректился на https. Ну вот и все, теперь
сайт будет сам направляться на правильный протокол, который будет работать.
----------------------------------------------------------------------------------
Альтернативные варианты
----------------------------------------------------------------------------------
В документах панели указано следующее:
RewriteEngine On
RewriteCond %{HTTPS} off
RewriteRule (.*) https://%{HTTP_HOST}%{REQUEST_URI} [R,L]

Но существуют и другие варианты:
Вариант 1 *
<IfModule mod_rewrite.c>
RewriteEngine On
RewriteCond %{SERVER_PORT} !^443$
RewriteRule .* https://%{SERVER_NAME}%{REQUEST_URI} [R=301,L]
</IfModule>

Вариант 2
<IfModule mod_rewrite.c>
RewriteEngine On
RewriteCond %{HTTPS} =on 
RewriteRule (.*) https://%{HTTP_HOST}%{REQUEST_URI} [QSA,L]
</IfModule>

Вариант 3
<IfModule mod_rewrite.c>
RewriteEngine On
RewriteBase /
RewriteCond %{HTTP:SSL} !=1 [NC]
RewriteRule ^(.*) https://www.pupi-boy.ru/$1 [L,R=301]
</IfModule>

Вариант 4 (При возникновении циклической переадресации)
<IfModule mod_rewrite.c>
RewriteEngine On
RewriteCond %{HTTPS} off
RewriteCond %{HTTP:X-Forwarded-Proto} !https
RewriteRule ^(.*)$ https://%{HTTP_HOST}%{REQUEST_URI} [L,R=301]
</IfModule>

WordPress спешл, вставьте перед правилами WordPress
<IfModule mod_rewrite.c>
RewriteEngine On
RewriteCond %{THE_REQUEST} ^[A-Z]{3,9}\ /(.*)\ HTTP/ [NC]
RewriteCond %{HTTPS} off [NC]
RewriteRule .* https://%{HTTP_HOST}%{REQUEST_URI}%{QUERY_STRING} [R=301,QSA,L]
</IfModule>

Редирект всех страниц кроме одной
Рекомендую не перенаправлять файл robots.txt
<IfModule mod_rewrite.c>
RewriteEngine On
RewriteCond %{HTTPS} =off
RewriteCond %{REQUEST_URI} !^/robots.txt
RewriteRule (.*) https://%{HTTP_HOST}%{REQUEST_URI} [QSA,L]
</IfModule>
----------------------------------------------------------------------------------
HTTPS To HTTP
----------------------------------------------------------------------------------
RewriteEngine On
RewriteCond %{SERVER_PORT} ^443$ [OR]
RewriteCond %{HTTPS} =on
RewriteRule ^(.*)$ http://site.ru/$1 [R=301,L]
----------------------------------------------------------------------------------
RabbitMQ
-----------------------------------------------------------------------------
yum -y update
yum -y install epel-release
yum -y update
yum -y install erlang socat
erl -version
-----------------------------------------------------------------------------
yum -y install wget
wget https://www.rabbitmq.com/releases/rabbitmq-server/v3.6.10/rabbitmq-server-3.6.10-1.el7.noarch.rpm
rpm --import https://www.rabbitmq.com/rabbitmq-release-signing-key.asc
rpm -Uvh rabbitmq-server-3.6.10-1.el7.noarch.rpm
-----------------------------------------------------------------------------
systemctl start rabbitmq-server
systemctl enable rabbitmq-server
systemctl status rabbitmq-server
-----------------------------------------------------------------------------
firewall-cmd --zone=public --permanent --add-port=4369/tcp
firewall-cmd --zone=public --permanent --add-port=25672/tcp
firewall-cmd --zone=public --permanent --add-port=5671-5672/tcp
firewall-cmd --zone=public --permanent --add-port=15672/tcp
firewall-cmd --zone=public --permanent --add-port=61613-61614/tcp
firewall-cmd --zone=public --permanent --add-port=1883/tcp
firewall-cmd --zone=public --permanent --add-port=8883/tcp

firewall-cmd --reload

setsebool -P nis_enabled 1
-----------------------------------------------------------------------------
rabbitmq-plugins enable rabbitmq_management
-----------------------------------------------------------------------------
Provide ownership of RabbitMQ files to the RabbitMQ user by running:

chown -R rabbitmq:rabbitmq /var/lib/rabbitmq/
-----------------------------------------------------------------------------
rabbitmqctl add_user admin StrongPassword
rabbitmqctl set_user_tags admin administrator
rabbitmqctl set_permissions -p / admin ".*" ".*" ".*"
-----------------------------------------------------------------------------
http://Your_Server_IP:15672/
You should delete the Guest user for security considerations.
-----------------------------------------------------------------------------
You can now easily install RabbitMQ for message queuing among the processes,
servers, and clients. To learn more about RabbitMQ, you can browse RabbitMQ site.
-----------------------------------------------------------------------------
APCu
-----------------------------------------------------------------------------
apc до php 5.4 
apcu после 5.4

apc = opcode cache and data store
apcu = data store. 
в php70 включить еще opcache = opcode cache

В PHP 7 существует отдельный модуль (» apc.so) для обеспечения обратной совместимости с APC. 

http://sitear.ru/apc.php
Для этого найдите папку в которой было установлено расширение.
В папке вы найдете файл по имени apc.php. Этот файл, также присутствует в
архиве установки. Скопируйте его в любую директорию из сайтов вашего сервера.
Например, что-бы он был доступен по адресу http://sitear.ru/apc.php. Если пакет
был установлен успешно, то при загрузке этого файла, вы увидите следующую
таблицу информации о текущем APC пакете.
-----------------------------------------------------------------------------
yum install php-apcu
yum install php-pecl-apcu
или
pecl install apcu
-----------------------------------------------------------------------------
Опции конфигурации APCu
-----------------------------------------------------------------------------
http://php.net/manual/ru/apcu.configuration.php
-----------------------------------------------------------------------------
apcu.so
-----------------------------------------------------------------------------
apcu.ini
-----------------------------------------------------------------------------
extension=apcu.so
  apc.enabled=1
  apc.shm_size=32M
  apc.ttl=7200
  apc.enable_cli=1
-----------------------------------------------------------------------------
php.ini
-----------------------------------------------------------------------------
    extension="apcu.so"
-----------------------------------------------------------------------------
Memcached
-----------------------------------------------------------------------------
yum install php-pecl-memcache memcached memcached-selinux
-----------------------------------------------------------------------------
Просмотр и изменение параметров:
nano /etc/sysconfig/memcached
-----------------------------------------------------------------------------
Для доступа к memcached только с локального сервера, изменяем параметр OPTIONS:
PORT=»11211″
USER=»memcached»
MAXCONN=»2048″ Максимальное количество подключений
CACHESIZE=»4096″ Количество фактической ОЗУ на сервере
OPTIONS=»-l 127.0.0.1″
-----------------------------------------------------------------------------
Запуск сервиса и добавление его в автозагрузку:
service memcached start
chkconfig memcached on

systemctl enable memcached
systemctl start memcached
-----------------------------------------------------------------------------
Убеждаемся в том, что memcached запущен и работает, командами:
pgrep memcached
netstat -tulpn | grep :11211
ps auwx | grep memcache
-----------------------------------------------------------------------------
Смотрим статистику:
memcached-tool 127.0.0.1:11211 stats
-----------------------------------------------------------------------------
не забываем перезапустить apache:
service httpd restart
-----------------------------------------------------------------------------
Смотрим информацию из phpinfo о установленном модуле:
php -r "phpinfo();" | grep memcache
-----------------------------------------------------------------------------
/etc/php.d/memcache.ini,
memcache
memcache support => enabled
memcache.allow_failover => 1 => 1
memcache.chunk_size => 8192 => 8192
memcache.default_port => 11211 => 11211
memcache.default_timeout_ms => 1000 => 1000
memcache.hash_function => crc32 => crc32
memcache.hash_strategy => standard => standard
memcache.max_failover_attempts => 20 => 20
Registered save handlers => files user memcache

или

# memcached-tool 127.0.0.1:11211 stats
-----------------------------------------------------------------------------
Важное дополнение.

Если у вас при выполнении команды php -i |grep memcache вылазят ошибки ,
то здесь необходимо пересобрать модуль расширения php-pecl-memcache, вручную:

1. Сначала удалим php-pecl-memcache из системы

# yum remove php-pecl-memcache

2. Теперь приступим к установке модуля:

Скачаем модуль к себе в папочку

# wget http://pecl.php.net/get/memcache-2.2.5.tgz

Разархивируем

# tar -xvf memcache-2.2.5.tgz

# cd memcache-2.2.5

Скомпилируем (должны быть установлены библиотеки gcc и gcc-c++)

# phpize && ./configure --enable-memcache && make && make install
Если не компилируется и ругается на отсутствие ZLIB, то доустановите
его – yum install zlib-devel (либо yum install openssl-devel)

Добавим в php.ini, строчку extension = memcache.so, для активации модуля

# echo «extension = memcache.so» >> /etc/php.ini

-----------------------------------------------------------------------------
Keepalived
-----------------------------------------------------------------------------
https://kamaok.org.ua/?p=834
-----------------------------------------------------------------------------
NGINX Plus Release 6 (R6) and later includes a solution for fast and easy
configuration of NGINX Plus in an active-passive high-availability (HA) setup.
It is based on Keepalived.

The Keepalived open source project provides the keepalive daemon for Linux
servers, an implementation of the Virtual Router Redundancy Protocol (VRRP)
to manage virtual routers (virtual IP addresses), and a health check facility
to determine whether a service (for example, a web server, PHP backend, or
database server) is up and operational. If a service on a node fails the
configured number of health checks, Keepalived reassigns the virtual IP
address from the master (active) node to the backup (passive) node.

VRRP ensures that there is a master node at all times. The backup node
listens for VRRP advertisement packets from the master node. If it does
not receive an advertisement packet for a period longer than three times
the configured advertisement interval, the backup node takes over as master
and assigns the configured virtual IP addresses to itself.
-----------------------------------------------------------------------------
! Configuration File for keepalived

global_defs {
   vrrp_sync_group IMEDIA_OUT { # группа серверов, между которыми будет синхронизироваться VRRP
      group {
             62.152.54.190     # master сервер
             62.152.53.210     # secondary сервер
	}
}

   vrrp_sync_group IMEDIA_IN { # группа серверов, между которыми будет синхронизироваться VRRP
      group {
             10.0.2.1     # master сервер
             10.0.2.2     # secondary сервер
        }
}

   notification_email {
     dmitriy.sheludko@i-media.ru     # e-mail на который будут приходить уведомления
   }
   robot@i-media.ru      # e-mail от которого будут приходить уведомления
   smtp_server office.i-media.ru      # почтовый сервер
   smtp_connect_timeout 30
   router_id LVS_DEVEL
}

vrrp_instance 62.152.54.190 {
    state MASTER
    interface eth1     # интерфейс на котором будет находится наш "плавающий" ip
    virtual_router_id 51     # id VRRP - должен находится в диапазоне 1-255
    priority 101     # приоритет сервера - должен иметь значение 1-255
    advert_int 1
    authentication {
        auth_type PASS     # способ авторизации между серверами
        auth_pass imedianetwork   # ваш пароль
    }
    virtual_ipaddress {
        62.152.54.198/30      # собственно наш "плавающий" ip
    }
}

#vrrp_instance 10.0.2.1 {
#    state MASTER
#    interface eth0     # интерфейс на котором будет находится наш "плавающий" ip
#    virtual_router_id 61     # id VRRP - должен находится в диапазоне 1-255
#    priority 99     # приоритет сервера - должен иметь значение 1-255
#    advert_int 1
#    authentication {
#        auth_type PASS     # способ авторизации между серверами
#        auth_pass imedianetwork   # ваш пароль
#    }
#    virtual_ipaddress {
#        10.0.3.1/24      # собственно наш "плавающий" ip
#    }
#}
-----------------------------------------------------------------------------
DRBD
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
===============		
L7.SERVICES
===============
-----------------------------------------------------------------------------
Nfs
-----------------------------------------------------------------------------
	Пример 1
-----------------------------------------------------------------------------
Установка NFS сервера на CentOS 7
-----------------------------------------------------------------------------
Установка и настройка серверной части NFS service
-----------------------------------------------------------------------------
устанавливает требуемые пакеты:

    sudo yum install nfs-utils nfs-utils-lib
-----------------------------------------------------------------------------
Затем включаем установленную службу:

    sudo systemctl enable rpcbind

    sudo systemctl enable nfs-server

    sudo  systemctl enable nfs-lock

    sudo systemctl enable nfs-idmap

    sudo systemctl start rpcbind

    sudo systemctl start nfs-server

    sudo systemctl start nfs-lock

    sudo systemctl start nfs-idmap
-----------------------------------------------------------------------------
После этого переходим к настройке каталога, которые будет использоваться для
раздачи контента нашим NFS сервером. Рекомендуется делать NFS шару в
«/var/nfs_name», чтобы не иметь проблем с записью файлов и назначением прав
доступа. В моей ситуации по определенным причинам используется каталог
«/home/nfs». Итак, создаем папку и назначаем права доступа:
-----------------------------------------------------------------------------
    sudo mkdir -p /home/nfs

    sudo chmod -R 777 /home/nfs
-----------------------------------------------------------------------------
После этого необходимо добавить в файл «/etc/exports’ информацию о
предоставляемой шаре через NFS:
-----------------------------------------------------------------------------
    sudo nano /etc/exports
-----------------------------------------------------------------------------
и добавляем строку:

    /home/nfs 192.168.10.0/24(rw,sync,no_root_squash,no_all_squash)
-----------------------------------------------------------------------------
При этом:
-----------------------------------------------------------------------------
/home/nfs – расшариваемая директория

192.168.10.0/24 – IP адрес клиента (или, как в моем случае, возможность
подключения для всей подсети)
-----------------------------------------------------------------------------
Опции конфигурационного файла /etc/fstab
-----------------------------------------------------------------------------
ro — Только чтение;
rw Чтение и запись;

root_squash Не разрешает пользователю root получать root-привилегии в удаленной
файловой системе, все действия будут сделаны от лица пользователя nobody;

no_root_squash Пользователь root в локальной системе получает такие же права
в удаленной. Стоит использовать эту опцию только в случае острой необходимости.
Используется для бездисковых клиентов;

all_squash Все запросы происходят от анонимного пользователя, что способствует
повышению безопасности. Актуально для публичных разделов;

anonuid/anongid Позволяет задать UID и GID пользователя от лица которого будут
выполняться все запросы;

sync Синхронный режим работы, ответы на запросы происходят только после того,
как данные будут надежно записаны на диск. Надежность выше, производительность меньше;

async Асинхронный режим работы, ответы на запросы происходят сразу, не
дожидаясь записи на диск. Надежность ниже, производительность выше;

insecure Разрешать запросы с портов более чем 1024;

no_subtree_check Если экспортируется подкаталог файловой системы, но не вся
файловая система, сервер, проверяет, находится ли запрошенный файл в
экспортированном подкаталоге. Эта проверка называется проверкой подкаталога.
Отключение проверки уменьшает безопасность, но увеличивает скорость передачи данных.
-----------------------------------------------------------------------------
Дополнительная информация
-----------------------------------------------------------------------------
Описанного выше должно хватить сполна, но если хочется больше то:
# man nfs
# man exports
# man exportfs

Не путайте exports и exportfs.
exports – это конфигурационный файл, exportfs — программа для работы с ним.
----------------------------------------------------------------------------------
Выполняем в командной строке 

exportfs -a

чтобы подключить этот каталог в	список экспортируемых. 
-----------------------------------------------------------------------------
В завершение настройки NFS сервера перезапускаем его:

    sudo systemctl restart nfs-server
-----------------------------------------------------------------------------
Теперь добавляем (открываем) порты NFS сервера в брандмауэре (firewalld) для
корректной работы в сети:
-----------------------------------------------------------------------------
    firewall-cmd —permanent —add-port=111/tcp

    firewall-cmd —permanent —add-port=54302/tcp

    firewall-cmd —permanent —add-port=20048/tcp

    firewall-cmd —permanent —add-port=2049/tcp

    firewall-cmd —permanent —add-port=46666/tcp

    firewall-cmd —permanent —add-port=42955/tcp

    firewall-cmd —permanent —add-port=875/tcp

    firewall-cmd —permanent —zone=public —add-service=nfs

    firewall-cmd —permanent —zone=public —add-service=mountd

    firewall-cmd —permanent —zone=public —add-service=rpc-bind

    firewall-cmd —reload
-----------------------------------------------------------------------------
Готово! Установка и настройка NFS сервера на CentOS 7 завершена.
-----------------------------------------------------------------------------
Установка и настройка клиента NFS
-----------------------------------------------------------------------------
    sudo yum install nfs-utils nfs-utils-lib
-----------------------------------------------------------------------------
Включаем сервис и активируем автозагрузку:

    systemctl enable rpcbind

    systemctl enable nfs-server

    systemctl enable nfs-lock

    systemctl enable nfs-idmap

    systemctl start rpcbind

    systemctl start nfs-server

    systemctl start nfs-lock

    systemctl start nfs-idmap
-----------------------------------------------------------------------------
Создаем каталог, куда будем монтировать шару:

sudo mkdir /media/nfs_share

mount -t nfs 192.168.10.101:/home/nfs/ /media/nfs_share/
-----------------------------------------------------------------------------
Добавление автомонтирования при включение системы:

    sudo nano /etc/fstab

# # /etc/fstab # Created by anaconda on Tue Aug 19 12:15:24 2014 
# # Accessible filesystems, by reference, are maintained under '/dev/disk' 
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info #
/dev/mapper/centos-root 			/			xfs     defaults        	1 1
UUID=2ba8d78a-c420-4792-b381-5405d755e544 	/boot			xfs     defaults        	1 2
/dev/mappe					/centos-swap swap       swap    defaults        	0 0
192.168.1.101:/home/nfs/			/media/nfs_share/ 	nfs 	rw,sync,hard,intr	0 0
-----------------------------------------------------------------------------
Проверяем, что все примонтировалось правильно:

    mount -fav
-----------------------------------------------------------------------------
	Пример 2
-----------------------------------------------------------------------------
Установка и настройка NFS-сервера и NFS-клиента на Centos
-----------------------------------------------------------------------------
1.Установка NFS
-----------------------------------------------------------------------------
Проверка, установлен ли nfs уже в системе
-----------------------------------------------------------------------------
[root@guk5 ~]# chkconfig —list nfs
-----------------------------------------------------------------------------
nfs             0:выкл  1:выкл  2:вкл   3:вкл   4:вкл   5:вкл   6:выкл

Аналогично проверяем службу portmap
-----------------------------------------------------------------------------
[root@kit ~]#  chkconfig —list portmap
-----------------------------------------------------------------------------
portmap         0:выкл  1:выкл  2:вкл   3:вкл   4:вкл   5:вкл   6:выкл

Если нет, то устанавливаем ,добавляем в автозагрузку, запускаем
-----------------------------------------------------------------------------
yum -y install nfs-utils portmap

chkconfig —level 2345 portmap on

chkconfig —level 2345 nfs on

/etc/init.d/portmap start

/etc/init.d/nfs start
-----------------------------------------------------------------------------
В своей работе NFS использует RPC-вызовы а значит работоспособность службы
можно проверить с помощью portmapper (/etc/init.d/portmap) (он тоже должен
быть запущен на сервере где выполняются программы использующие RPC Calls).
-----------------------------------------------------------------------------
[root@guk5 ~]# rpcinfo -p localhost | grep nfs

100003    2   udp   2049  nfs

100003    3   udp   2049  nfs

100003    4   udp   2049  nfs

100003    2   tcp   2049  nfs

100003    3   tcp   2049  nfs

100003    4   tcp   2049  nfs

Как видим на моем сервере обслуживаются NFS-запросы всех версий NFS
(4-ая — последняя на данный момент).
-----------------------------------------------------------------------------
2.Настройка NFS-сервера

Файл конфигурации /etc/exports содержит список файловых систем которые мы
экспортируем, то есть разрешаем монтировать по протоколу NFS на удаленных
системах. Каждая строка в файле это указание на экспортируемую ФС и режим
доступа к ней, шаблон следующий:
-----------------------------------------------------------------------------
[файловая система] [кому разрешено получать доступ] [опциональные ключи]
-----------------------------------------------------------------------------
[root@kit ~]# cat /etc/exports

/home 192.168.1.16(rw,no_root_squash)
-----------------------------------------------------------------------------
Здесь мы разрешаем монтировать /home на сервере 192.168.1.16 в режиме rw

После изменения в /etc/exports обязательно перечитываем, чтобы изменения вступили в силу
-----------------------------------------------------------------------------
exportfs –r
-----------------------------------------------------------------------------
Проверка списка экспортируемых файловых систем
-----------------------------------------------------------------------------
[root@guk5 ~]# exportfs
-----------------------------------------------------------------------------
/home           192.168.1.17
-----------------------------------------------------------------------------
3.Настройка NFS- клиента
-----------------------------------------------------------------------------
создаем точку монтировании

mkdir /mnt/nfs
-----------------------------------------------------------------------------
Ручное монтирование

mount -t nfs 192.168.1.16:/home /mnt/nfs
-----------------------------------------------------------------------------
Монтируем с помощью команды mount. Ключем -t задаем тип монтируемой ФС, далее
: <точка монтирования в локальной системе>

Используя опцию -o можно указать дополнительные ключи монтирования.
По умолчанию монтирование происходит в режиме rw.
-----------------------------------------------------------------------------
Проверяем наличие файлов в /mnt/nfs

ls –al /mnt/nfs
-----------------------------------------------------------------------------
Для автоматического монтирования на клиенте добавляем в /etc/fstab

192.168.1.16:/home  /mnt/nfs  nfs  defaults  0 0
-----------------------------------------------------------------------------
	Пример 3
-----------------------------------------------------------------------------
http://ru.bmstu.wiki/NFS_(Network_File_System)

NFS (Network File System)
Материал из Национальной библиотеки им. Н. Э. Баумана
Последнее изменение этой страницы: 18:55, 20 июля 2016.
-----------------------------------------------------------------------------

NFS (англ. Network File System) — протокол сетевого доступа к файловым системам,
первоначально разработан Sun Microsystems в 1984 году. Основан на протоколе
вызова удалённых процедур (ONC RPC). Позволяет подключать (монтировать)
удалённые файловые системы через сеть.[1]

NFS абстрагирован от типов файловых систем как сервера, так и клиента, существует
множество реализаций NFS-серверов и клиентов для различных операционных систем и
аппаратных архитектур. Наиболее зрелая версия NFS — v.4, поддерживающая различные
средства аутентификации (в частности, Kerberos и LIPKEY с использованием протокола
RPCSEC GSS) и списков контроля доступа (как POSIX, так и Windows-типов).
Общая организация NFS

NFS предоставляет клиентам прозрачный доступ к файлам и файловой системе сервера.
 В отличие от FTP, протокол NFS осуществляет доступ только к тем частям файла, к
которым обратился процесс, и основное достоинство его в том, что он делает этот
доступ прозрачным. Это означает, что любое приложение клиента, которое может
работать с локальным файлом, с таким же успехом может работать и с NFS файлом,
без каких либо модификаций самой программы.

NFS-клиенты получают доступ к файлам на NFS-сервере путём отправки RPC-запросов
на сервер. Это может быть реализовано с использованием обычных пользовательских
процессов — а именно, NFS-клиент может быть пользовательским процессом, который
осуществляет конкретные RPC-вызовы на сервер, который так же может быть
пользовательским процессом.

Важной частью последней версии стандарта NFS (v4.1) стала спецификация pNFS,
нацеленная на обеспечение распараллеленной реализации общего доступа к файлам,
увеличивающая скорость передачи данных пропорционально размерам и степени
параллелизма системы.
-----------------------------------------------------------------------------
Содержание
-----------------------------------------------------------------------------
    1 История
    2 Цели разработки
    3 Принцип работы NFS
    4 Настройка сервера NFS
    5 Управление сервером NFS
        5.1 showmount
        5.2 exportfs
    6 Монтирование файловой системы Network Files System командой mount
    7 Опции обработки ошибок NFS
    8 Повышение производительности NFS
    9 Примечания
-----------------------------------------------------------------------------
История
-----------------------------------------------------------------------------
Протокол NFS имеет в своей истории 4 версии.
-----------------------------------------------------------------------------
Цели разработки
-----------------------------------------------------------------------------
Изначальными требованиями при разработке NFS были:

    потенциальная поддержка различных операционных систем (не только UNIX),
чтобы серверы и клиенты NFS возможно было бы реализовать в разных операционных системах;
    протокол не должен зависеть от каких-либо определённых аппаратных средств;
    должны быть реализованы простые механизмы восстановления в случае отказов сервера или клиента;
    приложения должны иметь прозрачный доступ к удаленным файлам без использования
специальных путевых имен или библиотек и без перекомпиляции;
    для UNIX-клиентов должна поддерживаться семантика UNIX;
    производительность NFS должна быть сравнима с производительностью локальных дисков;
    реализация не должна быть зависимой от транспортных средств.
-----------------------------------------------------------------------------
Принцип работы NFS
-----------------------------------------------------------------------------
NFS строится по крайней мере из двух основных частей: сервера и одного или
большего количества клиентов. Клиент обращается к данным, находящимся на сервере,
в режиме удалённого доступа. Для того, чтобы это нормально функционировало, нужно
настроить и запустить несколько процессов. Реализация NFS состоит из нескольких
компонентов. Некоторые из них локализованы либо на сервере, либо на клиенте, а
некоторые используются и на обеих сторонах соединения. Некоторые компоненты не
требуются для обеспечения основных функциональных возможностей, но составляют
часть расширенного интерфейса NFS.

Протокол NFS определяет набор запросов (операций), которые могут быть
направлены клиентом к серверу, а также набор аргументов и возвращаемые значения
для каждого из этих запросов. Версия 1 этого протокола существовала только в
недрах Sun Microsystems и никогда не была выпущена. Все реализации NFS (в том
числе NFSv3) поддерживают версию 2 NFS (NFSv2), которая впервые была выпущена
в 1985 году в SunOS 2.0. Версия 3 протокола была опубликована в 1993 году и
реализована некоторыми фирмами-поставщиками.
-----------------------------------------------------------------------------
Протокол удаленного вызова процедур (RPC) определяет формат всех взаимодействий
между клиентом и сервером. Каждый запрос NFS посылается как пакет RPC. На
сервере работают следующие даемоны[2]:
-----------------------------------------------------------------------------
    rpc.nfsd - Основной даемон сервера NFS - nfsd (в новых версиях иногда
называется nfsd4). Этот демон обслуживает запросы клиентов NFS. Параметр
RPCNFSDCOUNT в файле /etc/default/nfs-kernel-server в Debian и NFSDCOUNT
в файле /etc/sysconfig/nfs в RedHat определяет число запускаемых демонов
(по-умолчанию - 8). (RPC программа 100003)

    rpc.mountd - Даемон монтирования NFS mountd обрабатывает запросы клиентов
на монтирование каталогов. Демон mountd работает на серверах NFS. (RPC программа 100005)

    rpc.statd - Даемон наблюдения за сетевым состоянием (он же Network
Status Monitor, он же NSM). Он позволяет корректно отменять блокировку
после сбоя/перезагрузки. Для уведомления о сбое использует программу
/usr/sbin/sm-notify. Демон statd работает как на серверах, так и на клиентах.
Ранее данный сервер был необходим для работы rpc.lockd, но за блокировки сейчас
отвечает ядро. (RPC программа 100021 и 100024 - в новых версиях)

    rpc.lockd - Даемон блокировки lockd (он же NFS lock manager (NLM)) обрабатывает
запросы на блокировку файлов. Демон блокировки работает как на серверах, так и
на клиентах. Клиенты запрашивают блокировку файлов, а серверы ее разрешают.
(устарел и в новых дистрибутивах не используется как демон. Его функции в
современных дистрибутивах (с ядром старше 2.2.18) выполняются ядра (lockd).
(RPC программа 100024)

    rpc.idmapd - Даемон idmapd для NFSv4 на сервере преобразует локальные uid/gid
пользователей в формат вида имя@домен, а сервис на клиенте преобразует имена
пользователей/групп вида имя@домен в локальные идентификаторы пользователя и
группы (согласно конфигурационному файлу /etc/idmapd.conf).

Клиент может запустить также даемон, называемый nfsiod. 
    nfsiod обслуживает запросы, поступающие от сервера от сервера NFS.
Он необязателен, увеличивает производительность, однако для нормальной и
правильной работы не требуется.[3]
-----------------------------------------------------------------------------
В NFSv4 при использовании Kerberos дополнительно запускаются демоны:

    rpc.gssd - Даемон NFSv4 обеспечивает методы аутентификации через GSS-API
(Kerberos-аутентификация). Работает на клиенте и сервере.
    rpc.svcgssd - Даемон сервера NFSv4, который обеспечивает проверку
подлинности клиента на стороне сервера.
-----------------------------------------------------------------------------
Даемоны старых версий (NFS v.3 и ниже):

    nfslogd - даемон журналов NFS фиксирует активность для экспортированных
файловых систем, работает на серверах NFS
    rpc.rquotad - сервер удаленных квот предоставляет информацию о квотах
пользователей в удаленных файловых системах, может работать как на серверах,
так и на клиентах.
-----------------------------------------------------------------------------
Кроме указанных выше пакетов, для корректной работы NFSv2 и v3 требуется
дополнительный пакет 

portmap (в более новых дистрибутивах заменен на переименован в rpcbind).
Sun RPC — это сервер, который преобразует номера программ RPC
(Remote Procedure Call) в номера портов TCP/UDP.
-----------------------------------------------------------------------------
portmap оперирует несколькими сущностями:
-----------------------------------------------------------------------------
    RPC-вызовами или запросами
    TCP/UDP портами, версией протокола (tcp или udp)
    номерами программ и версиями программ 
-----------------------------------------------------------------------------
Даемон portmap запускается скриптом /etc/init.d/portmap до старта NFS-сервисов.
-----------------------------------------------------------------------------
Работа сервера RPC (Remote Procedure Call) заключается в обработке RPC-вызовов
(т.н. RPC-процедур) от локальных и удаленных процессов. Используя RPC-вызовы,
сервисы регистрируют или удаляют себя в/из преобразователя портов ( portmap,
portmapper, он же, в новых версиях, rpcbind), а клиенты с помощью RPC-вызовов
направляя запросы к portmapper получают необходимую информацию.
Механизм работы RPC
-----------------------------------------------------------------------------
Работу RPC-сервера можно представить следующими шагами:
-----------------------------------------------------------------------------
    Преобразователь портов должен стартовать первым, обычно при загрузке системы.
При этом создается конечная точка TCP и осуществляется открытие TCP порта 111.
Также создается конечная точка UDP, которая находится в ожидании, когда на UDP
порт 111 прибудет UDP датаграмма.
    При старте программа, работающая через сервер RPC создает конечную точку
TCP и конечную точку UDP для каждой поддерживаемой версии программы. (Сервер
RPC может поддерживать несколько версий. Клиент указывает требуемую версию
при посылке RPC-вызова.) Динамически назначаемый номер порта закрепляется
за каждой версией сервиса. Сервер регистрирует каждую программу, версию,
 протокол и номер порта, осуществляя соответствующий RPC-вызов.
    Когда программе клиента RPC необходимо получить необходимую информацию,
 она вызывает вызов процедуру преобразователя портов, чтобы получить динамически
назначаемый номер порта для заданной программы, версии и протокола.
    В ответ на этот запрос север возвращает номер порта.
    Клиент отправляет сообщение RPC-запрос на номер порта, полученный в пункте 4.
Если используется UDP, клиент просто посылает UDP датаграмму, содержащую сообщение
RPC-вызова , на номер UDP порта, на котором работает запрошенный сервис. В ответ
сервис отправляет UDP датаграмму, содержащую сообщение RPC отклика. Если
используется TCP, клиент осуществляет активное открытие на номер TCP порта
требуемого сервиса и затем посылает сообщение вызова RPC по установленному
соединению. Сервер отвечает сообщением отклика RPC по соединению.

Для получения информации от RPC-сервера используется утилита rpcinfo, она
отображает номер зарегистрированной программы, версию, протокол, порт и название.
С помощью rpcinfo также можно удалить регистрацию программы или получить информацию
об отдельном сервисе RPC. При указании параметров -p host программа выводит список
всех зарегистрированных RPC программ на хосте host. Без указания хоста программа
выведет сервисы на localhost.
-----------------------------------------------------------------------------
NFS сервер (точнее даемон rpc.nfsd) получает запросы от клиента в виде UDP
датаграмм на порт 2049. Несмотря на то, что NFS работает с преобразователем
портов, что позволяет серверу использовать динамически назначаемые порты,
UDP порт 2049 жестко закреплен за NFS в большинстве реализаций.
-----------------------------------------------------------------------------
Описание процесса обращения к файлу, расположенному на сервере NFS:

    Клиенту (пользовательскому процессу) безразлично, получает ли он доступ к
локальному файлу или к NFS файлу. Ядро занимается взаимодействием с железом
через модули ядра или встроенные системные вызовы.
    Модуль ядра kernel/fs/nfs/nfs.ko, который выполняет функции NFS клиента
отправляет RPC запросы NFS серверу через модуль TCP/IP. NFS обычно использует
UDP, однако более новые реализации могут использовать TCP.
    NFS сервер получает запросы от клиента в виде UDP датаграмм на порт 2049.
Несмотря на то, что NFS может работать с преобразователем портов, что позволяет
серверу использовать динамически назначаемые порты, UDP порт 2049 жестко
закреплен за NFS в большинстве реализаций.
    Когда NFS сервер получает запрос от клиента, он передаётся локальной
подпрограмме доступа к файлу, которая обеспечивает доступ к локальному диску на сервере.
    Результат обращения диску возвращается клиенту.
-----------------------------------------------------------------------------
Настройка сервера NFS
-----------------------------------------------------------------------------
Настройка сервера в целом заключается в задании локальных каталогов, разрешенных
для монтирования удаленными системами в файле /etc/exports. Это действие
называется экспорт иерархии каталогов. Основными источниками информации об
экспортированных каталогах служат следующие файлы:
Структура папки Root
-----------------------------------------------------------------------------
    /etc/exports - основной конфигурационный файл, хранящий в себе конфигурацию
экспортированных каталогов. Используется при запуске NFS и утилитой exportfs.
    /var/lib/nfs/xtab - содержит список каталогов, монтированных удаленными
клиентами. Используется демоном rpc.mountd, когда клиент пытается смонтировать иерархию (создается запись о монтировании).
    /var/lib/nfs/etab - список каталогов, которые могут быть смонтированы
удаленными системами с указанием всех параметров экспортированных каталогов.
    /var/lib/nfs/rmtab - список каталогов, которые не разэкспортированы в
данный момент.
    /proc/fs/nfsd - специальная файловая система (ядро 2.6) для управления
NFS сервером.
    /proc/net/rpc - содержит "сырую" (raw) статистику, которую можно получить
с помощью nfsstat, а также различные кеши.
    /var/run/portmap_mapping - информация о зарегистрированных в RPC сервисах.
-----------------------------------------------------------------------------
В файле exports используются следующие общие опции:[4]
-----------------------------------------------------------------------------
    auth_nlm (no_auth_nlm) или secure_locks (insecure_locks) - указывает, что
сервер должен требовать аутентификацию запросов на блокировку (с помощью
протокола NFS Lock Manager (диспетчер блокировок NFS)).
    nohide (hide) - если сервер экспортирует две иерархии каталогов, при этом
одна вложенна (примонтированна) в другую. Клиенту необходимо явно смонтировать
вторую (дочернюю) иерархию, иначе точка монтирования дочерней иерархии будет
выглядеть как пустой каталог. Опция nohide приводит к появлению второй
иерархии каталогов без явного монтирования.
    ro - Разрешает только запросы на чтение.
    rw - Разрешает запросы на запись.
    secure (insecure) - требует, чтобы запросы NFS поступали с защищенных
портов (< 1024), чтобы программа без прав root не могла монтировать иерархию каталогов.
    subtree_check (no_subtree_check) - Если экспортируется подкаталог фаловой
системы, но не вся файловая система, сервер проверяет, находится ли запрошенный
файл в экспортированном подкаталоге. Отключение проверки уменьшает безопасность,
но увеличивает скорость передачи данных.
    sync (async) - указывает, что сервер должен отвечать на запросы только
после записи на диск изменений, выполненных этими запросами. Опция async
указывает серверу не ждать записи информации на диск, что повышает
производительность, но понижает надежность, т.к. в случае обрыва соединения
или отказа оборудования возможна потеря информации.
    wdelay (no_wdelay) - указывает серверу задерживать выполнение запросов
на запись, если ожидается последующий запрос на запись, записывая данные более
большими блоками. Это повышает производительность при отправке больших очередей
команд на запись. no_wdelay указывает не откладывать выполнение команды на запись,
что может быть полезно, если сервер получает большое количество команд не
связанных друг с другом.
-----------------------------------------------------------------------------
Управление сервером NFS
-----------------------------------------------------------------------------
Управление сервером NFS осуществляется с помощью следующих утилит:

    nfsstat
    showmsecure (insecure)ount
    exportfs
-----------------------------------------------------------------------------
Утилита nfsstat позволяет посмотреть статистику RPC и NFS серверов.
-----------------------------------------------------------------------------
showmount
-----------------------------------------------------------------------------
Утилита showmount запрашивает демон rpc.mountd на удалённом хосте о
смонтированных файловых системах. По умолчанию выдаётся отсортированный список
клиентов. Команды:

    --all - выдаётся список клиентов и точек монтирования с указанием куда
клиент примонтировал каталог. Эта информация может быть не надежной.
    --directories - выдаётся список точек монтирования.
    --exports - выдаётся список экспортируемых файловых систем с точки зрения nfsd.

При запуске showmount без аргументов, на консоль будет выведена информация о
системах, которым разрешено монтировать локальные каталоги.
-----------------------------------------------------------------------------
exportfs
-----------------------------------------------------------------------------
Данная команда синхронизирует экспортированные каталоги, заданные в файле
/etc/exports, с файлом /var/lib/nfs/xtab и удаляет из xtab несуществующие.
exportfs выполняется при запуске демона nfsd с аргументом -r. Утилита exportfs
в режиме ядра 2.6 общается с демоном rpc.mountd через файлы каталога
/var/lib/nfs/ и не общается с ядром напрямую. Без параметров выдаёт список
текущих экспортируемых файловых систем. Параметры exportfs:

    [клиент:имя-каталога] - добавить или удалить указанную файловую систему
для указанного клиента)
    -v - выводить больше информации
    -r - переэкспортировать все каталоги (синхронизировать /etc/exports и
/var/lib/nfs/xtab)
    -u - удалить из списка экспортируемых
    -a - добавить или удалить все файловые системы
    -o - опции через запятую (аналогичен опциям применяемым в /etc/exports;
т.о. можно изменять опции уже смонтированных файловых систем)
    -i - не использовать /etc/exports при добавлении, только параметры
текущей командной строки
    -f - сбросить список экспортируемых систем в ядре 2.6.
-----------------------------------------------------------------------------
Монтирование файловой системы Network Files System командой mount
-----------------------------------------------------------------------------
Пример команды mount для монтирования файловой системы NFS в Debian:

FILES ~ # mount -t nfs archiv:/archiv-small /archivs/archiv-small
FILES ~ # mount -t nfs -o ro archiv:/archiv-big /archivs/archiv-big
FILES ~ # mount
.......
archiv:/archiv-small on /archivs/archiv-small type nfs (rw,addr=10.0.0.6)
archiv:/archiv-big on /archivs/archiv-big type nfs (ro,addr=10.0.0.6)
-----------------------------------------------------------------------------
Первая команда монтирует экспортированный каталог /archiv-small на сервере
archiv в локальную точку монтирования /archivs/archiv-small с опциями по
умолчанию (то есть для чтения и записи). Вторая команда монтирует
экспортированный каталог /archiv-big на сервере archiv в локальный каталог
/archivs/archiv-big с опцией только для чтения (ro). Команда mount без
параметров наглядно отображает нам результат монтирования. Кроме опции только
чтения (ro), 
-----------------------------------------------------------------------------
возможно задать другие основные опции при монтировании NFS[5]:
-----------------------------------------------------------------------------
    nosuid - Данная опция запрещает исполнять setuid программы из
смонтированного каталога.
    nodev (no device - не устройство) - Данная опция запрещает использовать в
качестве устройств символьные и блочные специальные файлы.
    lock (nolock) - Разрешает блокировку NFS (по умолчанию). nolock отключает
блокировку NFS (не запускает демон lockd) и удобна при работе со старыми
серверами, не поддерживающими блокировку NFS.
    mounthost=имя - Имя хоста, на котором запущен демон монтирования NFS - mountd.
    mountport=n - Порт, используемый демоном mountd.
    port=n - порт, используемый для подключения к NFS серверу (по умолчанию
2049, если демон rpc.nfsd не зарегистрирован на RPC-сервере). Если n=0 (по
умолчанию), то NFS посылает запрос к portmap на сервере, чтобы определить порт.
    rsize=n (read block size - размер блока чтения) - Количество байтов,
читаемых за один раз с NFS-сервера. Стандартно - 4096.
    wsize=n (write block size - размер блока записи) - Количество байтов,
записываемых за один раз на NFS-сервер. Стандартно - 4096.
    tcp или udp - Для монтирования NFS использовать протокол TCP или UDP
соответственно.
    bg - При потери доступа к серверу, повторять попытки в фоновом режиме,
чтобы не блокировать процесс загрузки системы.
    fg - При потери доступа к серверу, повторять попытки в приоритетном режиме.
Данный параметр может заблокировать процесс загрузки системы повторениями
попыток монтирования. По этой причине параметр fg используется преимущественно
при отладке.
    Опции, влияющие на кэширование атрибутов при монтировании NFS
    Атрибуты файлов, хранящиеся в inod (индексных дескрипторах), такие как
время модификации, размер, жесткие ссылки, владелец, обычно изменяются не
часто для обычных файлов и еще реже - для каталогов. Ядро использует время
модификации файла, чтобы определить устарел ли кэш, сравнивая время
модификации в кэше и время модификации самого файла.
-----------------------------------------------------------------------------
Кэш атрибутов периодически обновляется в соответствии с заданными параметрами:
-----------------------------------------------------------------------------
    ac (noac) (attrebute cache - кэширование атрибутов) - Разрешает кэширование
атрибутов (по-умолчанию). Хотя опция noac замедляет работу сервера, она позволяет
избежать устаревания атрибутов, когда несколько клиентов активно записывают
информацию в общию иерархию.
    acdirmax=n (attribute cache directory file maximum - кэширование атрибута
максимум для файла каталога) - Максимальное количество секунд, которое NFS
ожидает до обновления атрибутов каталога (по-умолчанию 60 сек.)
    acdirmin=n (attribute cache directory file minimum - кэширование атрибута
минимум для файла каталога) - Минимальное количество секунд, которое NFS
ожидает до обновления атрибутов каталога (по-умолчанию 30 сек.)
    acregmax=n (attribute cache regular file maximum - кэширование атрибута
максимум для обычного файла) - Максимаьное количество секунд, которое NFS
ожидает до обновления атрибутов обычного файла (по-умолчанию 60 сек.)
    acregmin=n (attribute cache regular file minimum- кэширование атрибута
минимум для обычного файла) - Минимальное количество секунд, которое NFS
ожидает до обновления атрибутов обычного файла (по-умолчанию 3 сек.)
    actimeo=n (attribute cache timeout - таймаут кэширования атрибутов) -
Заменяет значения для всех вышуказаных опций. Если actimeo не задан, то
вышеуказанные значения принимают значения по умолчанию.
-----------------------------------------------------------------------------
Опции обработки ошибок NFS
-----------------------------------------------------------------------------
Следующие опции управляют действиями NFS при отсутствии ответа от сервера или
в случае возникновения ошибок ввода/вывода:

    fg (bg) (foreground - передний план, background - задний план) -
Производить попытки монтирования отказавшей NFS на переднем плане/в фоне.
    hard (soft) - выводит на консоль сообщение "server not responding" при
достижении таймаута и продолжает попытки монтирования. При заданной опции
soft - при таймауте сообщает вызвавшей операцию программе об ошибке ввода/вывода.
    nointr (intr) (no interrupt - не прерывать) - Не разрешает сигналам
прерывать файловые операции в жестко смонтированной иерархии каталогов при
достижении большого таймаута. intr - разрешает прерывание.
    retrans=n (retransmission value - значение повторной передачи) - После
n малых таймаутов NFS генерирует большой таймаут (по-умолчанию 3). Большой
таймаут прекращает выполнение операций или выводит на консоль сообщение
"server not responding", в зависимости от указания опции hard/soft.
    retry=n (retry value - значение повторно попытки) - Количество минут
повторений службы NFS операций монтирования, прежде чем сдаться
(по-умолчанию 10000).
    timeo=n (timeout value - значение таймаута) - Количество десятых долей
секунды ожидания службой NFS до повторной передачи в случае RPC или малого
таймаута (по-умолчанию 7). Это значение увеличивается при каждом таймауте до
максимального значения 60 секунд или до наступления большого таймаута. В
случае занятой сети, медленного сервера или при прохождении запроса через
несколько маршрутизаторов или шлюзов увеличение этого значения может повысить
производительность.
-----------------------------------------------------------------------------
Повышение производительности NFS
-----------------------------------------------------------------------------
На производительность NFS могут влиять несколько параметров, особенно при
работе через медленные соединения. При работе с медленными и высоконагруженными
оединениями, желательно использовать параметр hard, чтобы таймауты не привели
к прекращению работы программ. Но необходимо осознавать, что если смонтировать
файловую систему через NFS с параметром hard через fstab, а удаленный хост
окажется недоступен, то при загрузке системы произойдет зависание.

Одним из способов повышения производительности NFS - увеличение количества
байтов, передаваемых за один раз. Размер в 4096 байт слишком мал для современных
быстрых соединений, увеличивая это значение до 8192 и более можно
экспериментальным путем найти оптимальную скорость.

Так же, не стоит упускать из внимания и настройки тайм-аутов. NFS ожидает ответа
на пересылку данных в течении промежутка времени, указанного в опции timeo, если
ответ за это время не получен, то выполняется повторная пересылка. На загруженных
и медленных соединениях это время может быть меньше времени реакции сервера и
способности каналов связи, в результате чего могут быть излишние повторные
пересылки, замедляющие работу.По умолчанию, timeo равно 0,7 сек (700 миллисекунд).
после обнаружения факта обрыва связи в течении 700 мс сервер совершит повторную
пересылку и удвоит время ожидания до 1,4 сек., увеличение timeo будет продолжаться
до максимального значения в 60 сек. 
----------------------------------------------------------------------------------
	Пример 4
-----------------------------------------------------------------------------
==============
NFS for oVirt
==============
# yum install nfs-utils 
# systemctl daemon-reload
# systemctl enable rpcbind.service
# systemctl enable nfs-server.service
# systemctl start rpcbind.service
# systemctl start nfs-server.service 
# mkdir -p /exports/data # mkdir -p /exports/export 
/etc/exports
	/exports/data *(rw)
	/exports/export *(rw) 
# exportfs -r
# systemctl reload nfs-server.service
# groupadd kvm -g 36 
# useradd vdsm -u 36 -g 36
# chown -R 36:36 /exports/data
# chown -R 36:36 /exports/export 
# chmod 0755 /exports/data
# chmod 0755 /exports/export
-------------------------------------------------------------------------------
iSCSI
----------------------------------------------------------------------------------
#######
#iSCSI
#######
----------------------------------------------------------------------------------
iSCSI (англ. Internet Small Computer System Interface) — протокол, который
базируется на TCP/IP и разработан для установления взаимодействия и управления
системами хранения данных, серверами и клиентами.

iSCSI описывает:

    Транспортный протокол для SCSI, который работает поверх TCP.
    Механизм инкапсуляции SCSI команд в IP сети.
    Протокол для нового поколения систем хранения данных, которые будут использовать
«родной» TCP/IP.

Протокол iSCSI является стандартизованным по RFC 3720. Существует много
коммерческих и некоммерческих реализаций этого протокола.

Системы на основе iSCSI могут быть построены на любой достаточно быстрой физической
основе, поддерживающей протокол IP, например Gigabit Ethernet или 10G Ethernet.
----------------------------------------------------------------------------------
Терминология

Терминология iSCSI во многом основывается на терминологии, использующейся в SCSI:

    initiator — тот, кто устанавливает соединение с целью(target). Чаще всего это
	узел (в общем случае) осуществляет ввод/вывод на блочные устройства.
    target — экспортируемый объект. В зависимости от контекста цель(target) называют
	или целиком экспортирующий узел, или только экспортируемый объект. Сам
	объект может делиться на lun’ы.
    Портал — группа целей(targets), которые анонсируются вместе. Чаще всего один
	узел хранения — один портал.
    IQN — полное имя участника взаимодействия. На практике существует iqn у
	инициатора и у цели(target).
    endpoint — уточнённое имя ресурса, чаще всего включает в себя iqn, номер
	LUN’а и указание на конкретный метод доступа к нему (например, номер
	соединения, LUN и IP-адрес, с которого следует получать доступ к устройству).
    LUN (Logical Unit Number) — номер объекта внутри цели(target). Ближайшим
	аналогом является раздел диска или отдельный том.
----------------------------------------------------------------------------------
LUN или Logical Unit Number — это адрес диска (в ранних версиях) или дискового
устройства в сетях хранения (современное использование).
Использование

Изначально, термин использовался в протоколе SCSI как метод адресации дисков
в пределах устройства с одним SCSI Target ID, такого как дисковый массив. LUN
не означает отдельный жесткий диск, скорее он определяет виртуальный раздел в
RAID-массиве. При этом один и тот же виртуальный раздел массива может иметь разные
значения LUN для разных хостов, которым этот LUN назначен. Также возможно наличие
на одном хосте одинаковых LUN, принадлежащих разным системам хранения (разным SCSI Target ID).

Таким образом, полный адрес диска (физического раздела жёсткого диска) на
SCSI-устройстве складывается из SCSI Target ID (уникального для хоста и определяемого
драйвером) и LUN, уникального в пределах SCSI-устройства и назначаемого ему в
настройках или автоматически по порядку.

На данный момент, как правило, этот термин используется в сетях хранения данных.
----------------------------------------------------------------------------------
OpenVPN 
----------------------------------------------------------------------------------
Вариант 1
----------------------------------------------------------------------------------
https://serveradmin.ru/nastroyka-openvpn-na-centos-7/#_openvpn_8212_TAP_TUN
----------------------------------------------------------------------------------
Имя 		Centos-server 	PC1 			Centos-client 		PC2
Внешний ip 	192.168.1.25 				192.168.1.26 	
Локальный ip 	192.168.10.1 	192.168.10.50 		192.168.20.1 		192.168.20.50
Комментарий 	Сервер openvp 	Компьютер с  		Клиент openvp  		Компьютер с 
		и шлюз в офисе	Windows 7 в офисе	и шлюз в филиале	Windows 7 в филиале
----------------------------------------------------------------------------------
Для роутинга трафика между сетевыми интерфейсами, необходимо добавить строку:
----------------------------------------------------------------------------------
net.ipv4.ip_forward = 1
----------------------------------------------------------------------------------
в файл /etc/sysctl.conf и применить настройку:
----------------------------------------------------------------------------------
# sysctl -p
----------------------------------------------------------------------------------
Если у вас этого не сделано, то трафик между интерфейсами ходить не будет.
----------------------------------------------------------------------------------
# yum -y install epel-release
# yum -y install openvpn
----------------------------------------------------------------------------------
# mkdir /etc/openvpn/keys
# yum -y install unzip zip
----------------------------------------------------------------------------------
# cd /etc/openvpn/keys
# wget https://github.com/OpenVPN/easy-rsa/archive/master.zip
# unzip master.zip
# cd /etc/openvpn/keys/easy-rsa-master/easyrsa3
----------------------------------------------------------------------------------
# mv vars.example vars
# ./easyrsa init-pki
Note: using Easy-RSA configuration from: ./vars
init-pki complete; you may now create a CA or requests.
 Your newly created PKI dir is: /etc/openvpn/keys/easy-rsa-master/easyrsa3/pki
----------------------------------------------------------------------------------
Создайте удостоверяющий центр CA:
----------------------------------------------------------------------------------
# ./easyrsa build-ca
----------------------------------------------------------------------------------
Не забудьте указанный пароль. Его нужно будет вводить каждый раз при создании
нового сертификата openvpn.
----------------------------------------------------------------------------------
Мы получили 2 ключа:
----------------------------------------------------------------------------------
    /etc/openvpn/keys/easy-rsa-master/easyrsa3/pki/private/ca.key	#секретный
    /etc/openvpn/keys/easy-rsa-master/easyrsa3/pki/ca.crt		#открытый

----------------------------------------------------------------------------------
Создаем запрос сертификата для сервера без пароля с помощью опции nopass,
иначе придется вводить пароль с консоли при каждом запуске сервера:
----------------------------------------------------------------------------------
# ./easyrsa gen-req server nopass
----------------------------------------------------------------------------------
Подписываем запрос на получение сертификата у нашего CA:
----------------------------------------------------------------------------------
# ./easyrsa sign-req server server
----------------------------------------------------------------------------------
В процессе работы скрипта вводим пароль от CA, который указывали раньше и отвечаем
на вопрос yes. Мы получили подписанный удостоверяющим центром сертификат для сервера
— /etc/openvpn/keys/easy-rsa-master/easyrsa3/pki/issued/server.crt
----------------------------------------------------------------------------------
Нам еще пригодится ключ Диффи-Хелмана, генерируем его:
----------------------------------------------------------------------------------
# ./easyrsa gen-dh
/etc/openvpn/keys/easy-rsa-master/easyrsa3/pki/dh.pem
----------------------------------------------------------------------------------
Копируем в папку /etc/openvpn все необходимые для работы openvpn сервера ключи:
----------------------------------------------------------------------------------
# cp pki/ca.crt /etc/openvpn/ca.crt
# cp pki/dh.pem /etc/openvpn/dh.pem
# cp pki/issued/server.crt /etc/openvpn/server.crt
# cp pki/private/server.key /etc/openvpn/server.key
----------------------------------------------------------------------------------
Создадим ключ для клиента openvpn:
----------------------------------------------------------------------------------
# ./easyrsa gen-req client nopass
# ./easyrsa sign-req client client
----------------------------------------------------------------------------------
Процедура аналогична созданию сертификата для сервера. Так же вводим пароль,
отвечаем yes. В результате получаем подписанный сертификат клиента:
----------------------------------------------------------------------------------
     /etc/openvpn/keys/easy-rsa-master/easyrsa3/pki/issued/client.crt
    /etc/openvpn/keys/easy-rsa-master/easyrsa3/pki/private/client.key
----------------------------------------------------------------------------------
Клиенту, которым у нас является шлюз филиала нужно будет передать следующий набор
файлов — client.crt, client.key, ca.crt.
----------------------------------------------------------------------------------
# mcedit /etc/openvpn/server.conf
----------------------------------------------------------------------------------
port 13555 # я предпочитаю использовать нестандартные порты для работы
proto udp # протокол может быт и tcp, если есть необходимость в этом
dev tun

ca /etc/openvpn/ca.crt
cert /etc/openvpn/server.crt
key /etc/openvpn/server.key
dh /etc/openvpn/dh.pem

server 10.0.0.0 255.255.255.0 # подсеть для туннеля, может быть любой
route 192.168.20.0 255.255.255.0 # указываем подсеть, к которой будем обращаться через vpn
push "route 192.168.20.0 255.255.255.0" # передаем маршрут клиентам

ifconfig-pool-persist ipp.txt # файл с записями соответствий clinet - ip
client-to-client # позволяет клиентам openvpn подключаться друг к другу
client-config-dir /etc/openvpn/ccd # директория с индивидуальными настройками клиентов

keepalive 10 120
comp-lzo
persist-key
persist-tun
status /var/log/openvpn/openvpn-status.log
log /var/log/openvpn/openvpn.log
verb 3
----------------------------------------------------------------------------------
Создаем необходимые директории:
----------------------------------------------------------------------------------
# mkdir /etc/openvpn/ccd && mkdir /var/log/openvpn
----------------------------------------------------------------------------------
Создаем файл конфигурации клиента в папке, указанной в параметре client-config-dir :
----------------------------------------------------------------------------------
mcedit /etc/openvpn/ccd/client
----------------------------------------------------------------------------------
iroute 192.168.20.0 255.255.255.0
----------------------------------------------------------------------------------
Здесь client — имя сертификата пользователя. Параметр iroute означает, что за
подсеть 192.168.20.0/24 отвечает именно этот клиент. Если в openvpn не передать
эту настройку, то сеть, находящуюся за клиентом будет не видно, при этом сам клиент
будет видеть всю сеть, которую обслуживает сервер. Такой вариант подходит для
подключения удаленных сотрудников.
----------------------------------------------------------------------------------
НЕОБХОДИМО НАСТРОИТЬ SELINUX
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
# systemctl start openvpn@server
# netstat -tulnp | grep 13555
# systemctl enable openvpn@server
----------------------------------------------------------------------------------
Теперь внимательно проверим корректность всех настроек на сервере. Сначала
посмотрим информацию о сетевых интерфейсах:
----------------------------------------------------------------------------------
# ifconfig
tun0	inet 10.0.0.1	destination 10.0.0.2
----------------------------------------------------------------------------------
Обращаем внимание на адреса туннеля vpn. Теперь проверяем статические маршруты:
----------------------------------------------------------------------------------
# netstat -nr

destination	gate		iface
192.168.20.0	10.0.0.2	tun0
----------------------------------------------------------------------------------
Тут тоже все в порядке. Траффик из подсети филиала 192.168.20.0/24 будет
маршрутизироваться в тоннель. С настройкой сервера закончили, идем теперь на клиент.
----------------------------------------------------------------------------------
Настройка в CentOS 7 клиента openvpn
----------------------------------------------------------------------------------
НЕОБХОДИМО НАСТРОИТЬ SELINUX
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
# mcedit /etc/openvpn/client.conf
----------------------------------------------------------------------------------
dev tun
proto udp
remote 192.168.1.25 13555
client
resolv-retry infinite
ca /etc/openvpn/ca.crt
cert /etc/openvpn/client.crt
key /etc/openvpn/client.key
route 192.168.10.0 255.255.255.0
persist-key
persist-tun
comp-lzo
verb 3
status /var/log/openvpn/openvpn-status.log 1
status-version 3
log-append /var/log/openvpn/openvpn-client.log
----------------------------------------------------------------------------------
Не забываем скопировать в /etc/openvpn сохраненные ранее ключи ca.crt, client.crt,
client.key.
----------------------------------------------------------------------------------
Обращаю внимание на параметр route в данном конфиге. Его можно здесь не указывать,
сделав конфиг более унифицированным для множества клиентов. Вместо этого данную
настройку можно передавать с сервера openvpn, указав в файле настроек клиента
параметр push route следующим образом:
----------------------------------------------------------------------------------
push "route 192.168.10.0 255.255.255.0"
----------------------------------------------------------------------------------
Создаем каталог для логов:
----------------------------------------------------------------------------------
# mkdir /var/log/openvpn
----------------------------------------------------------------------------------
Запускаем openvpn client:
----------------------------------------------------------------------------------
# systemctl start openvpn@client
----------------------------------------------------------------------------------
Добавляем в автозагрузку:
----------------------------------------------------------------------------------
# systemctl enable openvpn@client
----------------------------------------------------------------------------------
# ifconfig
tun0	inet 10.0.0.6	destination 10.0.0.5
----------------------------------------------------------------------------------
# netstat -nr
destination	gate		iface
192.168.10.0	10.0.0.5	tun0	
----------------------------------------------------------------------------------
Iptables
----------------------------------------------------------------------------------
Centos-server:
----------------------------------------------------------------------------------
#!/bin/bash
#
# Объявление переменных
export IPT="iptables"

# Интерфейс который смотрит в интернет
export WAN=eth0
export WAN_IP=192.168.1.25

# Локалка
export LAN=eth1
export LAN_IP_RANGE=192.168.10.0/24

# Очистка всех цепочек iptables
$IPT -F
$IPT -F -t nat
$IPT -F -t mangle
$IPT -X
$IPT -t nat -X
$IPT -t mangle -X

# Установим политики по умолчанию для трафика, не соответствующего ни одному из правил
$IPT -P INPUT DROP
$IPT -P OUTPUT DROP
$IPT -P FORWARD DROP

# разрешаем трафик для loopback и локалки
$IPT -A INPUT -i lo -j ACCEPT
$IPT -A OUTPUT -o lo -j ACCEPT
$IPT -A INPUT -i $LAN -j ACCEPT
$IPT -A OUTPUT -o $LAN -j ACCEPT

# разрешаем пинги
$IPT -A INPUT -p icmp --icmp-type echo-reply -j ACCEPT
$IPT -A INPUT -p icmp --icmp-type destination-unreachable -j ACCEPT
$IPT -A INPUT -p icmp --icmp-type time-exceeded -j ACCEPT
$IPT -A INPUT -p icmp --icmp-type echo-request -j ACCEPT

# Разрешаем исходящие соединения самого сервера
$IPT -A OUTPUT -o $WAN -j ACCEPT

# Разрешаем OpenVPN
$IPT -A INPUT -i tun+ -j ACCEPT
$IPT -A OUTPUT -o tun+ -j ACCEPT
$IPT -A FORWARD -i tun+ -j ACCEPT
# Разрешаем доступ из внутренней сети в vpn
$IPT -A FORWARD -i $LAN -o tun+ -j ACCEPT

# Разрешаем доступ из внутренней сети наружу
$IPT -A FORWARD -i $LAN -o $WAN -j ACCEPT

# Маскарадинг
$IPT -t nat -A POSTROUTING -o tun0 -j MASQUERADE
$IPT -t nat -A POSTROUTING -o $WAN -s $LAN_IP_RANGE -j MASQUERADE

# Состояние ESTABLISHED говорит о том, что это не первый пакет в соединении.
# Пропускать все уже инициированные соединения, а также дочерние от них
$IPT -A INPUT -p all -m state --state ESTABLISHED,RELATED -j ACCEPT
# Пропускать новые, а так же уже инициированные и их дочерние соединения
$IPT -A OUTPUT -p all -m state --state ESTABLISHED,RELATED -j ACCEPT
# Разрешить форвардинг для уже инициированных и их дочерних соединений
$IPT -A FORWARD -p all -m state --state ESTABLISHED,RELATED -j ACCEPT

# Включаем фрагментацию пакетов. Необходимо из за разных значений MTU
$IPT -I FORWARD -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu

# Отбрасывать все пакеты, которые не могут быть идентифицированы
# и поэтому не могут иметь определенного статуса.
$IPT -A INPUT -m state --state INVALID -j DROP
$IPT -A FORWARD -m state --state INVALID -j DROP

# Приводит к связыванию системных ресурсов, так что реальный
# обмен данными становится не возможным.
$IPT -A INPUT -p tcp ! --syn -m state --state NEW -j DROP
$IPT -A OUTPUT -p tcp ! --syn -m state --state NEW -j DROP

# Открываем порт для ssh
$IPT -A INPUT -i $WAN -p tcp --dport 22 -j ACCEPT

# Открываем порт для openvpn
$IPT -A INPUT -i $WAN -p udp --dport 13555 -j ACCEPT

# Записываем правила
/sbin/iptables-save > /etc/sysconfig/iptables
----------------------------------------------------------------------------------
Centos-client:
----------------------------------------------------------------------------------
Настройки абсолютно такие же, кроме переменных WAN, LAN и LAN_IP_RANGE.
----------------------------------------------------------------------------------
Если ваш openvpn клиент не подключается, то в первую очередь проверяйте настройки
firewall — входящие подключения к серверу и исходящие клиента. Обратите внимание
на номер порта и тип (TCP или UDP) если вы их меняли. У меня были затупы, когда
никак не мог разобраться, почему нет соединения. Оказывалось, что я менял порт
c UDP на TCP, но по привычке на фаерволе оставлял UDP.
----------------------------------------------------------------------------------
Проверка нашей vpn сети
----------------------------------------------------------------------------------
Заходим на centos-client (192.168.20.1) и пингуем centos-server (192.168.10.1) и
pc1 (192.168.10.50):
----------------------------------------------------------------------------------
Заходим на pc2 (192.168.20.50) и пингуем centos-server и pc1:
----------------------------------------------------------------------------------
аходим на pc1 (192.168.10.50) и пингуем centos-client (192.168.20.1) и pc2 (192.168.20.50):
----------------------------------------------------------------------------------
И напоследок пропингуем с vpn сервера подсеть клиента:
----------------------------------------------------------------------------------
В завершение темы объединения удаленных офисов, проверим доступ к общим сетевым
ресурсам. Расшарим папку на PC2 и зайдем на нее с PC1:
----------------------------------------------------------------------------------
Все получилось. Мы реально объединили удаленные офисы в единую логическую сеть с
помощью openvpn сервера.
----------------------------------------------------------------------------------
Подключения удаленного сотрудника
----------------------------------------------------------------------------------
Нам необходимо, чтобы удаленный пользователь смог подключиться либо к обоим сетям,
либо выборочно только к основному офису, либо только к филиалу.
----------------------------------------------------------------------------------
Первым делом идем на сервер и создаем для клиента сертификаты.
----------------------------------------------------------------------------------
# cd /etc/openvpn/keys/easy-rsa-master/easyrsa3
# ./easyrsa gen-req user1 nopass
# ./easyrsa sign-req client user1
----------------------------------------------------------------------------------
Процедура такая же, как и при создании первого сертификата клиента, который мы уже
сгенерировали ранее. На выходе имеем два файла: user1.key и user1.crt. Добавляем
сюда ключ ca.crt и передаем пользователю на компьютер.
----------------------------------------------------------------------------------
Дальше создаем файл конфигурации для этого клиента:
----------------------------------------------------------------------------------
# cd /etc/openvpn/ccd
# mcedit user1
push "route 192.168.10.0 255.255.255.0"
push "route 192.168.20.0 255.255.255.0"
----------------------------------------------------------------------------------
Этими параметрами мы передаем клиенту маршруты к обоим сетям офисов. Если нужно
подключать клиента только к какой-то одной сети, то оставляйте одну сеть, вторую
удаляйте.
----------------------------------------------------------------------------------
Приступаем к настройке клиента в windows. Для этого нам понадобится файл
конфигурации. Можно взять уже готовый config, который мы создавали ранее и немного
изменить его. Файл конфигурации openvpn клиента должен выглядеть вот так:
----------------------------------------------------------------------------------
dev tun
proto udp
remote 192.168.1.25
port 13555
client
resolv-retry infinite
ca ca.crt
cert user1.crt
key user1.key
persist-key
persist-tun
comp-lzo
----------------------------------------------------------------------------------
У нас нет задачи видеть сеть за клиентом, да и он скорее всего не будет являться
шлюзом, поэтому параметра route в конфиге нет. Плюс убраны пути для логов — openvpn
будет создавать их в папке по-умолчанию. Сохраняем конфигурацию под именем
openvpn.ovpn в папку C:\Program Files\OpenVPN\config, туда же копируем файлы
сертификатов и запускаем OpenVPN GUI от имени администратора!
----------------------------------------------------------------------------------
Для того, чтобы openvpn client автоматически подключался при запуске, нужно создать
для него ярлык с параметрами:
----------------------------------------------------------------------------------
"C:\Program Files\OpenVPN\bin\openvpn-gui.exe" --connect "openvpn.ovpn"
----------------------------------------------------------------------------------
Вариант 2
----------------------------------------------------------------------------------
yum install epel-release
----------------------------------------------------------------------------------
Шаг #1: Установка пакета OpenVPN

Прежде всего, необходимо установить OpenVPN. Также мы установим инструмент Easy
RSA — он будет использоваться для создания пар SSL-ключей, которые обеспечат
безопасность VPN-соединений.

# yum install openvpn easy-rsa –y
----------------------------------------------------------------------------------
Шаг #2: Настройка сервиса

В директории документации OpenVPN содержатся файлы с тестовыми конфигурациями
программы. Скопируем файл server.conf — на его основе мы создадим свою конфигурацию.
cp /usr/share/doc/openvpn-*/sample/sample-config-files/server.conf /etc/openvpn
----------------------------------------------------------------------------------
Теперь откроем его для редактирования:
vi /etc/openvpn/server.conf
----------------------------------------------------------------------------------
Здесь нужно будет внести несколько изменений. Когда в дальнейшем мы будем
генерировать ключы в программе Easy RSA, их размер будет по умолчанию составлять
2048 байт, поэтому нужно убедиться, что соответствующее значение указано в файле
настроек. Нужно изменить название файла dh на dh2048.pem:
----------------------------------------------------------------------------------
dh dh2048.pem
----------------------------------------------------------------------------------
Затем нужно раскомментировать (удалить символ “;”) строку 
----------------------------------------------------------------------------------
push "redirect-gateway def1 bypass-dhcp"
----------------------------------------------------------------------------------
, которая сообщает клиенту о необходимости редиректа трафика через OpenVPN.
----------------------------------------------------------------------------------
Затем нужно указать DNS-серверы, поскольку клиентские приложения не смогут
использовать серверы интернет-провайдера. Самым логичным выходом является
использование публичных DNS-серверов Google 8.8.8.8 и 8.8.4.4.

Для этого нужно раскомментировать строки, начинающиеся с push "dhcp-option DNS"
и вписать туда адреса DNS-серверов Google:
----------------------------------------------------------------------------------
push "dhcp-option DNS 8.8.8.8"
push "dhcp-option DNS 8.8.4.4"
----------------------------------------------------------------------------------
Нам нужно, чтобы OpenVPN запускался без привилегий, поэтому нужно указать, что он
запускается от имени пользователя и группы nobody. Для этого нужно
раскомментировать соответствующие строки:
----------------------------------------------------------------------------------
user nobody
group nobody
----------------------------------------------------------------------------------
Затем нужно сохранить файл и выйти из него.
Шаг #3: Создание ключей и сертификатов

После завершения работы с конфигурационным файлом, нужно создать ключи и сертификаты.
Пакет Easy RSA включает скрипты, с помощью которых можно это сделать.
----------------------------------------------------------------------------------
Создадим директорию, в которой будут храниться ключи:
mkdir -p /etc/openvpn/easy-rsa/keys
----------------------------------------------------------------------------------
В эту директорию нужно скопировать скрипты для генерации ключей и сертификатов:
cp -rf /usr/share/easy-rsa/2.0/* /etc/openvpn/easy-rsa
----------------------------------------------------------------------------------
В целях оптимизации дальнейшей работы с OpenVPN можно несколько модифицировать
скрипты генерации, чтобы каждый раз не вводить одни и те же значения. Нужная
информация хранится в файле vars, поэтому отредактируем его:
vi /etc/openvpn/easy-rsa/vars
----------------------------------------------------------------------------------
Будем изменять строки, которые начинаются с KEY_ . В них следует указать данные
своей компании. Самые важные параметры:
----------------------------------------------------------------------------------
    KEY_NAME: Следует указать значение server, иначе придется вносить изменения в
конфигурационные файлы, в которых упоминается server.key и server.crt.
    KEY_CN: здесь надо написать домен или поддомен, который указывает на ваш сервер.
----------------------------------------------------------------------------------
В остальные поля можно внести информацию о компании:
# These are the default values for fields
# which will be placed in the certificate.
# Don't leave any of these fields blank.
export KEY_COUNTRY="RU"
export KEY_PROVINCE="Moscow"
export KEY_CITY="Moscow"
export KEY_ORG="OOO Romashka"
export KEY_EMAIL="ivan@example.com"
export KEY_OU="Community"

# X509 Subject Field
export KEY_NAME="server"

. . .

export KEY_CN=openvpn.example.com
----------------------------------------------------------------------------------
Также следует предотвратить возможность сбоя загрузки конфигурации SSL из-за
невозможности определения версии программы. Для скопируем нужный конфигурационный
файл и удалим из названия номер версии:
cp /etc/openvpn/easy-rsa/openssl-1.0.0.cnf /etc/openvpn/easy-rsa/openssl.cnf
----------------------------------------------------------------------------------
Теперь создадим ключи и сертификаты. Для этого перейдем в директорию easy-rsa и
запустим команду source для новых переменных:
----------------------------------------------------------------------------------
cd /etc/openvpn/easy-rsa
source ./vars
----------------------------------------------------------------------------------
Затем нужно удалить все предыдущие версии ключей и сертификатов, которые могут
содержаться в этой директории:
./clean-all
----------------------------------------------------------------------------------
Указываем информацию об организации, выдавшей сертификат:
./build-ca
----------------------------------------------------------------------------------
Система задаст несколько вопросов, но поскольку мы уже вносили необходимые данные
в конфигурационный файл, можно просто нажимать Enter вместо ответа.
----------------------------------------------------------------------------------
Теперь нужно сгенерировать ключ и сертификат сервера. И снова можно просто нажимать
Enter в ответ на вопросы системы. Чтобы сохранить данные, в конце процедуры следует
нажать Y (yes).
./build-key-server server
----------------------------------------------------------------------------------
Также нужно сгенерировать файл обмена по алгоритму Диффи-Хеллмана. Процесс может
занять несколько минут:
./build-dh
----------------------------------------------------------------------------------
Сгенерируем дополнительный ключ ta.key.
openvpn --genkey --secret /etc/openvpn/easy-rsa/keys/ta.key
----------------------------------------------------------------------------------
Теперь скопируем созданные сертификаты и ключи в директорию OpenVPN.
cd /etc/openvpn/easy-rsa/keys
cp dh2048.pem ca.crt server.crt server.key ta.key /etc/openvpn
----------------------------------------------------------------------------------
Всем клиентским приложениям для установления связи также понадобятся эти ключи и
сертификаты. Лучше создавать отдельные ключи для каждого пользовательского
приложения и давать ключам описательные имена. Сейчас же мы рассматриваем ситуацию
с одним клиентом, поэтому назовем его просто client:
cd /etc/openvpn/easy-rsa
./build-key client
----------------------------------------------------------------------------------
Шаг 4: Маршрутизация
----------------------------------------------------------------------------------
Чтобы упростить настройку, проведем все манипуляции с помощью стандартного
фаерволла iptables, а не нового инструмента firewallcd.
----------------------------------------------------------------------------------
Прежде всего надо убедиться в том, что сервис iptables установлен и включен.
yum install iptables-services -y
systemctl mask firewalld
systemctl enable iptables
systemctl stop firewalld
systemctl start iptables
iptables --flush
----------------------------------------------------------------------------------
Затем следует добавить в iptables правило, согласно которому соединения будут направляться в создаваемую подсеть OpenVPN:
iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o eth0 -j MASQUERADE
iptables-save > /etc/sysconfig/iptables
----------------------------------------------------------------------------------
Активируем IP-форвардинг в sysctl, отредактировав файл sysctl.conf для редактирования:
vi /etc/sysctl.conf
----------------------------------------------------------------------------------
В самом верху добавляем следующую строку:
net.ipv4.ip_forward = 1
----------------------------------------------------------------------------------
Перезапускаем сетевой сервис для применения внесенных изменений:
systemctl restart network.service
----------------------------------------------------------------------------------
Шаг 5: Запуск OpenVPN

Теперь все готово к запуску OpenVPN. Добавим этот сервис в systemctl:
systemctl -f enable openvpn@server.service
----------------------------------------------------------------------------------
Запускаем OpenVPN:
openvpn /etc/openvpn/server.conf
----------------------------------------------------------------------------------
На этом конфигурация со стороны сервера завершена. Настроим подключение со стороны клиента.
----------------------------------------------------------------------------------
Шаг 6: Настройка клиента
----------------------------------------------------------------------------------
Вне зависимости от того, какая операционная система установлена на клиентском
устройстве, для соединения с сервером все равно потребуются ключи и сертификаты,
сгенерированные на сервере.
----------------------------------------------------------------------------------
Необходимые сертификаты (в нашем случае для клиента "client") хранятся в директории /easy-rsa:
/etc/openvpn/easy-rsa/keys/ca.crt
/etc/openvpn/easy-rsa/keys/client.crt
/etc/openvpn/easy-rsa/keys/client.key
----------------------------------------------------------------------------------
Загрузить эти файлы на клиентское устройство можно с помощью SFTP или другим способом.
Можно даже просто открыть их в текстовом редакторе и скопировать содержимое в
новые файлы, созданные прямо непосредственно на пользовательском компьютере
(главное - сохранить под идентичными именами).
----------------------------------------------------------------------------------
Теперь создадим файл под client.ovpn - конфигурационный файл для клиента OpenVPN.
В нем содержатся параметры подключения к серверу. Ниже представлено содержимое
этого файла, в котором необходимо заменить имя клиента (в нашем случае client),
указать корректный ip-адрес сервера и верный путь к файлам сертификатов и ключей:
----------------------------------------------------------------------------------
client
dev tun
proto udp
remote your_server_ip 1194
resolv-retry infinite
nobind
persist-key
persist-tun
comp-lzo
verb 3
ca /path/to/ca.crt
cert /path/to/client.crt
key /path/to/client.key
----------------------------------------------------------------------------------
Теперь этот файл можно использовать для подключения к серверу.
----------------------------------------------------------------------------------
Подключение с компьютера под управлением Windows:
----------------------------------------------------------------------------------
Скачиваем официальную версию бинарных файлов OpenVPN Community Edition с графическим
интерфейсом управления.

Перемещаем .ovpn-файл в директорию C:\Program Files\OpenVPN\config, затем нажимаем
Connect в графическом интерфейсе OpenVPN.

MacOS:

Для соединения можно использовать open-source инструмент Tunnelblick. Перемещаем
.ovpn-файл в директорию ~/Library/Application Support/Tunnelblick/Configurations
или просто кликнаем по этому файлу.

Linux:

На Linux нужно установить OpenVPN из официальных репозиториев конкретного
дистрибутива. Затем запустить его с помощью команды:
sudo openvpn --config ~/path/to/client.ovpn

На этом все. Теперь у нас есть полностью функциональная частная виртуальная сеть
с собственным OpenVPN-сервером на CentOS 7 VPN.

После успешного подключения клиента следует проверить, туннелируется ли трафик
через VPN. Сделать это можно с помощью любого сервиса, показывающего ваш публичный
IP-адрес (например, http://myip.ru/) - он должен отображать адрес VPN-сервера.
----------------------------------------------------------------------------------
OPENVPN Вариант 3
----------------------------------------------------------------------------------
СЕРВЕРА
-----------------------------------------------------------------------------
1. Точка – точка, клиент – сервер
2. Порт 1194
3. Сетевые интерфейсы (TUN: Layer 3-based IP – маршрутизируемый IP тунель, МАРШРУТИЗАТОР - 2 СЕТИ;
TAP: Layer 2-based, ETHERNET тунель, МОСТ - ОДНА ЕДИНАЯ СЕТЬ)
4. DLL Compression LZO
5. Шифрование SSL/TLS симметричное (у всех один ключ) и ассиметричное
(public – шифрует, private – расшифровывает)
6. Установка openvpn, openssl
7. /etc/sysctl.conf –> net.ipv4.ip_forward = 1 – > sysctl -p
8. iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o eth0 -j MASQUERADE (чтобы
трафик VPN-клиентов достигший нашего сервера мог попадать в другие сети и успешно
возвращаться нам нужно включить трансляцию сетевых адресов (NAT).)
-----------------------------------------------------------------------------
АУТЕНТИФИКАЦИЯ
-----------------------------------------------------------------------------
9. Предустановленный ключ, — самый простой метод.
10. Сертификатная аутентификация, — наиболее гибкий в настройках метод.
11. С помощью логина и пароля, — может использоваться без создания клиентского
сертификата (серверный сертификат всё равно нужен).
-----------------------------------------------------------------------------
ГЕНЕРАЦИЯ КЛЮЧЕЙ
-----------------------------------------------------------------------------
12. mkdir /etc/openvpn/easy-rsa/
13. cp -r /usr/share/doc/openvpn/examples/easy-rsa/2.0/* /etc/openvpn/easy-rsa/
14. nano vars
export KEY_COUNTRY="RU"
export KEY_PROVINCE="Leningradskaya"
export KEY_CITY="SaintPetersburg"
export KEY_ORG="Firm"
export KEY_EMAIL=me@domain.ru
15. source ./vars
16. ./clean-all
17. ./build-ca
18. ./build-key-server server
19. ./build-key user
20. ./build-dh
21. openvpn --genkey --secret keys/ta.key
22. ./easyrsa gen-crl
23. Сервер: cp server.crt server.key ca.crt dh1024.pem ta.key /etc/openvpn/
24. Клиент: user.crt, user.key, ca.crt, ta.key
25. ./revoke-full user
26. ./easyrsa init-pki
-----------------------------------------------------------------------------
КОНФИГУРАЦИЯ
-----------------------------------------------------------------------------
27. Сервер: server.conf
-----------------------------------------------------------------------------
port 1194
proto tcp
dev tun
ca ca.crt
cert server.crt
key server.key
dh dh1024.pem
tls-auth ta.key 0
crl-verify crl.pem
cipher DES-EDE3-CBC
server 10.8.0.0 255.255.255.0
ifconfig-pool-persist ipp.txt
keepalive 10 120
comp-lzo
persist-key
persist-tun
push "route 10.8.0.1 255.255.255.0"
push "redirect-gateway def1"
push "dhcp-option DNS 8.8.8.8"
# ПРИМЕР: Допустим клиент
# имеет сертификат с именем "Thelonious",
# а также имеет за собой небольшую подсеть из
# машин с адресами, например 192.168.40.128/255.255.255.248.
# Сначала раскоментируйте эти строки:
;client-config-dir ccd
;route 192.168.40.128 255.255.255.248
# Затем создайте файл ccd/Thelonious со следующей строкой:
#   iroute 192.168.40.128 255.255.255.248
# ПРИМЕР: Допустим вы хотите дать
# Thelonious постоянный VPN IP адрес 10.9.0.1.
# Вначале раскоментируйте следующую строку:
;client-config-dir ccd
;route 10.9.0.0 255.255.255.252
# Затем добавьте следующую строку в ccd/Thelonious:
#   ifconfig-push 10.9.0.1 10.9.0.2
client-to-client
max-clients 100
status openvpn-status.log
log /var/log/openvpn.log
management localhost 7777
verb 3
-----------------------------------------------------------------------------
28. Клиент: client.conf
-----------------------------------------------------------------------------
client
dev tun
proto tcp
remote 10.172.120.217 1194
resolv-retry infinite
nobind
persist-key
persist-tun
ca ca.crt
cert user.crt
key user.key
tls-auth ta.key 1
cipher DES-EDE3-CBC
ns-cert-type server
comp-lzo
log /var/log/openvpn.log
verb 3
-----------------------------------------------------------------------------
29. openssl.cnf
-----------------------------------------------------------------------------
[ ca ]
default_ca = CA_default
[ CA_default ]
dir = /etc/openvpn
crl_dir = $dir
database = $dir/index.txt
new_certs_dir = $dir
certificate = $dir/ca.crt
serial = $dir
crl = $dir/crl.pem
private_key = $dir/server.key
RANDFILE = $dir/.rand
default_days = 3650
default_crl_days = 365
default_md = md5
unique_subject = yes
policy = policy_any
x509_extensions = user_extensions
[ policy_any ]
organizationName = match
organizationalUnitName = optional
commonName = supplied
[ req ]
default_bits = 2048
default_keyfile = privkey.pem
distinguished_name = req_distinguished_name
x509_extensions = CA_extensions
[ req_distinguished_name ]
organizationName = Organization Name (must match CA)
organizationName_default = Company
organizationalUnitName = Location Name
commonName = Common User or Org Name
commonName_max = 64
[ user_extensions ]
basicConstraints = CA:FALSE
[ CA_extensions ]
basicConstraints = CA:TRUE
default_days = 3650
[ server ]
basicConstraints = CA:FALSE
nsCertType = server
-----------------------------------------------------------------------------
МОНИТОРИНГ
-----------------------------------------------------------------------------
30. index.txt и serial – статистика по ключам
31. openvpn-status.log
32. /var/log/openvpn.log
КОМАНДЫ
33. ls -l /dev/net/tun
34. lsmod | grep tun
35. openvpn /etc/openvpn/server.conf
36. sudo openvpn client.conf
37. netstat -ltupn | grep 1194
38. sockstat | grep 1194
39. (server.conf: management localhost 7777) -> telnet localhost 7777 -> status
-----------------------------------------------------------------------------
IPTABLES
-----------------------------------------------------------------------------
40. iptables для приёма входящих запросов и форвардинга во внутреннюю сеть.
# eth0 - внутренний интерфейс 192.168.0.0/24
# tun  - сетка 192.168.1.0/24 для openvpn-клиентов
iptables -A INPUT  -p udp -m udp --dport 11194 -j ACCEPT
iptables -A OUTPUT -p udp -m udp --sport 11194 -j ACCEPT -m conntrack --ctstate ESTABLISHED,RELATED
iptables -A FORWARD -s 192.168.1.0/24 -d 192.168.0.0/24 -i tun+ -o eth0 -p icmp -j ACCEPT
iptables -A FORWARD -s 192.168.0.0/24 -d 192.168.1.0/24 -i eth0 -o tun+ -p icmp -j ACCEPT
iptables -A FORWARD -s 192.168.1.0/24 -d 192.168.0.0/24 -i tun+ -o eth0 -p tcp -m tcp -m multiport --dports 22,3389 -j ACCEPT
iptables -A FORWARD -s 192.168.0.0/24 -d 192.168.1.0/24 -i eth0 -o tun+ -p tcp -m tcp -m multiport --sports 22,3389 -j ACCEPT -m conntrack --ctstate ESTABLISHED,RELATED




-----------------------------------------------------------------------------
ProFTPd
----------------------------------------------------------------------------------
#########
#ProFTPd
#########
----------------------------------------------------------------------------------
Устанавливаем ProFTPD:
#yum install -y proftpd

Добавляем в Автозагрузку:
#chkconfig proftpd on
#service proftpd start
#systemctl enable proftpd
#systemctl start proftpd

Далее редактируем конфиг (/etc/proftpd.conf):
# mcedit /etc/proftpd.conf

изменим Group на nobody
Group nobody

По соображениям безопасности, вы можете также добавить (или разкомментировать)
следующие строки в /etc/proftpd.conf:
DefaultRoot ~
IdentLookups off
ServerIdent on "FTP Server ready."

Чтобы FTP пользователи могли использовать сhmod команды, закомментируем строки
в разделе:
# DenyAll

Также можно сделать, чтоб отображались все файлы от и до, т.к. файлы начинающиеся
на точку, видно не будет:
ListOptions -a

Запускаем:
# proftpd

Добавление пользователя:
# useradd -d /home/site.ru/ -M -s /bin/bash user
Где:
/home/site.ru/ — корневая директория пользователя на фтп
user — Имя пользователя

Редактирование пароля пользователя:
# passwd user

Удаление пользователя:
# userdel user
----------------------------------------------------------------------------------
#################################
#Настройка ProFTPd для хостинга
#################################


Написано достаточно статей, как поднять и настроить LAMP.
Во многих из них есть пара абзацев, в которых кратко описывается установка и
базовая настройка ProFTPd.
Как правило, для организации нормальной работы хостинга этого не хватает.
Возникает вопрос — «как настроить ftp-доступ конкретного пользователя к определенному
виртуальному хосту?».

Виртуальные ftp-пользователи

Для хостинга нецелесообразно заводить пользователей в системе. Гораздо логичнее
завести виртуальных ftp-пользователей.
В первую очередь нужно определиться, где будем хранить их учетные записи.
У ProFTPd есть несколько вариантов, но я рассмотрю лишь два:

    Альтернативный файл пользователей и паролей;
    СУБД MySQL.


Сразу оговорюсь, что у меня установлена система Ubuntu 10.04.
Apache работает от имени www-data, у которого UserId=33, GroupId=33.
Логи ftp-сервера по умолчанию можно посмотреть тут: /var/log/proftpd/
В руководстве я создам пользователя tester, для работы с виртуальным хостом test.ru.

Общая настройка ProFTPd

Открываем конфиг ProFTPd, по-умолчанию он располагается /etc/proftpd/proftpd.conf.
Из соображений безопасности добавляем в него следующие строки:

DefaultRoot ~
ServerIdent on "FTP Server ready."

Так рекомендовано сделать в официальном руководстве пользователя.
Остальное по умолчанию можно оставить, так как есть.

Хранение виртуальных пользователей в текстовом файле

Нам нужно, чтобы ftp пользователь имел возможность редактировать и удалять файлы,
созданные скриптами.
Создаем нового виртуального ftp-пользователя с логином tester, идентификатором 33,
группой 33 и домашним каталогом /var/www/test.ru.

ftpasswd --passwd --file=/etc/proftpd/ftpd.passwd --name=tester --uid=33 --gid=33 --home=/var/www/test.ru --shell=/bin/false

После выполнения команды система попросит ввести дважды пароль пользователя.
В итоге, у нас появится файл /etc/proftpd/ftp.passwd с записью о пользователе.
Кстати, изменить пароль пользователя можно следующей командой:

ftpasswd --passwd --name=tester --change-password

Теперь редактируем /etc/proftpd/proftpd.conf, для подключения виртуального пользователя:

RequireValidShell off
AuthUserFile /etc/proftpd/ftpd.passwd

Перезапускаем ftp:
/etc/init.d/proftpd restart

Хранение виртуальных пользователей в СУБД MySQL

Для хранения виртуальных пользователей в СУБД MySQL необходим пакет proftpd-mod-mysql.
Через PHPMyAdmin или любым другим удобным способом создаем новую базу, к примеру proftpd.
Так же создаем нового пользователя proftpd_user с паролем proftpd_password
с правами на чтение этой базы.
В базе создаем одну таблицу:

CREATE TABLE `proftpd`.`users` (
`username` VARCHAR( 32 ) NOT NULL ,
`password` VARCHAR( 32 ) NOT NULL ,
`uid` INT NOT NULL ,
`gid` INT NOT NULL ,
`homedir` VARCHAR( 255 ) NOT NULL ,
`shell` VARCHAR( 255 ) NOT NULL ,
UNIQUE (`username`)
) ENGINE = MYISAM CHARACTER SET utf8 COLLATE utf8_general_ci;

И добавляем запись о пользователе:

INSERT INTO `proftpd`.`users` (`username`, `password`, `gid`, `homedir`, `shell`) VALUES (
'tester', 'pass', '33', '33', '/var/www/test.ru', '/bin/false' );

На этом настройка MySQL окончена.
Теперь, что касается конфигурации FTP-сервера.
Редактируем файл /etc/proftpd/modules.conf – уберем комментарий со строк

LoadModule mod_sql.c
LoadModule mod_sql_mysql.c

Редактируем файл /etc/proftpd/proftpd.conf.
Дописываем строку
Include /etc/proftpd/sql.conf

А так же уберем комментарий или допишем строку:
AuthOrder mod_sql.c

Файл /etc/proftpd/sql.conf приводим к следующему виду:
<IfModule mod_sql.c>
# Cообщаем, что намерены работать с СУБД MySQL
SQLBackend mysql
SQLEngine on
# Пароли в базе храняться в открытом формате
SQLAuthTypes Plaintext
# Подключаемся к БД proftpd пользователем proftpd_user с паролем proftpd_password
SQLConnectInfo proftpd@localhost proftpd_user proftpd_password
# Выбираем данные из таблицы users
SQLUserInfo users username password uid gid homedir shell
# Аутентифицируем пользователей из этой таблицы
SQLAuthenticate users*
# По умолчанию минимальный UserID пользователя и GroupID =999
SQLMinUserUID 33
SQLMinUserGID 33
# На время отладки пишем логи
SQLLogFile /var/log/proftpd/sql.log


Перезапускаем ftp:
/etc/init.d/proftpd restart

Настройка доступа ftp-пользователей к директориям

Изменяем владельца директории /var/www/test.ru
сhown www-data:www-data /var/www/test.ru

Выставляем права доступа к директории, иначе увидим permission denied
chmod 775 /var/www/test.ru

Теперь виртуальные пользователи могут создавать, редактировать и удалять файлы и папки.

Полное описание директив ProFTPd можно найти тут:
http://www.proftpd.org/docs/directives/configuration_full.html
А так же есть хорошая документация на русском:
http://www.bog.pp.ru/work/ProFTPD.html
----------------------------------------------------------------------------------
#########################################
#Установка и настройка ProFTPd Директивы
#########################################

ProFTPd (http://www.proftpd.org/) - популярный ftp демон под *NIX. Имеет гибкие
настройки, стабилен в работе, быстр, достаточно безопасен, компилируется под многие
платформы, имеет полезные расширения для работы с MySQL, LDAP и др.
Установка

На FreeBSD:

Установку производим из портов. Переходим в дерикторию с программой:
cd /usr/ports/ftp/proftpd
/usr/ports/ftp/proftpd/>make install && make clean

В появившемся синем окне, выбираем опции с которыми будет собиратся ftp сервер.
Например, можно собрать с поддержкой БД MySQL с целью хранения в ней пользователей.

После установки, добавляем в автозагрузку:
/usr/local/etc/rc.d/>echo 'proftpd_enable="YES"' >> /etc/rc.conf

На Debian/Ubuntu:
Установка выполняется в одну команду:
sudo apt-get install proftpd

На CentOS/Fedora:
Установка выполняется командой:

sudo yum -y install proftpd
Настройка

Переходим к редактированию основного конфигурационного файла:
vi /usr/local/etc/proftpd.conf (для системы FreeBSD)

vi /etc/proftpd/proftpd.conf (для других систем)

# имя сервера - показывается коннектящимся клиентам
ServerName "Main FTP server"

# тип запуска сервера

# standalone/inetd - сам или через inetd
ServerType standalone

# если клиент коннектится не на имя, а на IP или на виртуальный хост
# не описанный в конфигурационном файле, то при

# установке в `off` он получит отлуп, если же установлено `on` то

# он будет обслужен `сервером по-умолчанию`
DefaultServer on

# e-mail администратора
ServerAdmin admin@example.com

# файл где хранится информация о сессиях
#ScoreboardFile /var/run/proftpd.scoreboard

# порт на котором работает сервер
Port 21

# Маска с которой создаются новые файлы (маска получается
# из этого значения, путём его вычитания из 777 - т.е. в даном случае получится
# маска 755)
Umask 022

# Максимальное число создаваемых процессов (работает только в standalohe режиме)
# необходимо для защиты от атак типа `отказ в обслуживании` да и
# от перегрузки сервера поможет
MaxInstances 30

# Пользователь от которого работает сервер
User ftp

# группа, под которой работает сервер
Group ftp

# куда будут складываться логи
ExtendedLog /var/log/ftp.log
TransferLog /var/log/xferlog
SystemLog /var/log/syslog.log

MaxClients 8 "Достигнут предел на количество клиентов"
MaxClientsPerHost 8 "Достигнут предел на количество клиентов с Вашего хоста"
MaxClientsPerUser 8 "Достигнут предел на количество подключений (%m)"
MaxHostsPerUser 8 "Больше нельзя"

# вывод приветствия после успешного входа
AccessGrantMsg "Добро пожаловать!!!"

# идентификация
ServerIdent on "Мой сервер"

# делаем /home/ftp папку, домашней
DefaultRoot /home/ftp

# запрещаем выходить пользователям за пределы домашней папки (рекомендуется)
DefaultRoot ~
MaxLoginAttempts 5 "Количество попыток входа исчерпано"

# Директории
<Directory ~>
AllowOverwrite on
<Limit Write>
AllowAll
</Limit>
<Limit READ>
AllowAll
</Limit>
</Directory>

# Можно установить ограничения по времени (зависит от требований к ftp)
TimeoutIdle 180
TimeoutLogin 120
TimeoutNoTransfer 36
TimeoutStalled 640
<br /># <Anonymous /home/ftp>

# пользователь от которого происходит доступ анонимно
# User ftp

# группа для анонимных пользователей
# Group ftp

# альясы ананонимоусов (можно будет входить как ftp, а
# не anonymous)
# UserAlias anonymous ftp

# максимально число анонимоусов
# MaxClients <b>10</b> "Извините, максимум %m пользователей - попробуйте подключится позже"
# <Limit WRITE>
# DenyAll
# </Limit>
# </Anonymous>

После чего запускаем proftpd сервер:
FreeBSD
/usr/local/etc/rc.d/>./proftpd.sh start

Starting proftpd.
Linux системы
sudo /etc/init.d/proftpd restart
-----------------------------------------------------------------------------
PureFTP
-----------------------------------------------------------------------------
#########
#PureFTP
#########

#pure-ftp.conf
======================================
ChrootEveryone              yes
CreateHomeDir			yes
MaxClientsNumber            50
Daemonize                   yes
MaxClientsPerIP             8
VerboseLog                  yes
DisplayDotFiles             yes
AnonymousOnly               no
NoAnonymous                 yes
SyslogFacility              ftp
DontResolve                 yes
MaxIdleTime                 15
PureDB                        /etc/pure-ftpd/pureftpd.pdb
LimitRecursion              10000 8
AnonymousCanCreateDirs      no
MaxLoad                     4
 PassivePortRange          30000 50000
AntiWarez                   yes
Umask                       133:022
MinUID                      1000
UseFtpUsers no
AllowUserFXP                no
AllowAnonymousFXP           no
ProhibitDotFilesWrite       no
ProhibitDotFilesRead        no
AutoRename                  no
AnonymousCantUpload         yes
AltLog                     clf:/var/log/pureftpd.log
#PIDFile                     /var/run/pure-ftpd.pid
MaxDiskUsage               99
CustomerProof              yes
# TLS                      1
# TLSCipherSuite           HIGH
# Certificate file, for TLS
# CertFile                 /etc/ssl/private/pure-ftpd.pem
# IPV4Only                 yes
# IPV6Only                 yes
======================================
#users
groupadd ftpgroup
useradd -g ftpgroup -d /dev/null -s /etc ftpuser

Теперь можно добавить виртуального пользователя:
pure-pw useradd remote -u ftpuser -g ftpgroup -d /home/pubftp/remote -N 10

Где remote — имя пользователя для доступа к FTP,
а /home/pubftp/remote — персональная директория,\
с которой он будет работать. -N 10 задает квоту в 10МБ
(ограничение на использование дискового пространства).
Эту директорию не нужно создавать вручную, т.к. она появится автоматически 
(параметр задается при конфигурировании, об этом чуть позже)
 при первом подключении и обмене данными с сервером.

Так же после первого выполнения этой команды создается файл,
который будет хранить данные для доступа пользователей.
======================================
#help to add access for different folders
ChrootEveryone              yes
!!! local user must have UID>1000
groupadd ftpgroup
useradd -g ftpgroup -d /dev/null -s /etc ftpuser
/home/siteuser
1.add local user
--------------------------------------
useradd -d /home/siteuser -s /bin/bash siteuser
useradd -d /home/devuser -s /bin/bash devuser
--------------------------------------
/etc/passwd
ftpuser:x:1001:1001::/dev/null:/etc
devuser:x:1002:1002::/home/devuser:/bin/bash
siteuser:x:1003:1003::/home/siteuser:/bin/bash

2.add this user to local group
--------------------------------------
groupadd bitrix
usermod -a -G bitrix devuser
usermod -a -G bitrix siteuser
groups bitrix
--------------------------------------
/etc/group
bitrix:x:600:devuser,siteuser
ftpgroup:x:1001

3.add rights go the group on resurce
--------------------------------------
chown -R bitrix:bitrix /home/bitrix/
chmod rwx+g bitrix
--------------------------------------
/home/bitrix/
drwxrwx---   6 bitrix   bitrix   4096 Июл 14 23:10 bitrix
/home/bitrix/www
drwxrwx---  39 bitrix bitrix 12288 Июл 17 12:24 www
/home/bitrix/ext_www
drwxrwxr-x   3 bitrix bitrix  4096 Июл 14 17:17 ext_www

4.add pure-pw useradd
--------------------------------------
pure-pw useradd site -u siteuser -g siteuser -d /home/pubftp/site
pure-pw useradd dev -u devuser -g devuser -d /home/pubftp/dev
pure-pw mkdb
--------------------------------------
/etc/pureftpd/pureftpd.passwd
dev:passwd:1002:1002::/home/pubftp/dev/./::::::::::::
site:passwd:1003:1003::/home//pubftp/site/./::::::::::::

5.config access for the resurce in pureftpd.passwd like HOME_DIR
--------------------------------------
vi /etc/pureftpd/pureftpd.passwd
--------------------------------------
/etc/pureftpd/pureftpd.passwd
dev:passwd:1002:1002::/home/bitrix/ext_www/./::::::::::::
site:passwd:1003:1003::/home/bitrix/www/./::::::::::::
======================================
#commands
yum install pure-ftpd
more /var/log/messages | grep pure-ftpd
tailf /var/log/pureftpd.log
groupadd ftpgroup
useradd -g ftpgroup -d /dev/null -s /etc ftpuser
pure-pw useradd remote -u ftpuser -g ftpgroup -d /home/pubftp/remote -N 10
pure-pw mkdb
pure-pw passwd remote
pure-pw list
pure-pw show remote
pure-pw userdel remote
#urls
======================================
http://cisu.blogspot.com/2013/01/pure-ftpd-debian.html
http://blogpmenier.dynalias.net/docext/pureftpd/pure-ftpd.conf

-----------------------------------------------------------------------------
VSftpd
-----------------------------------------------------------------------------
/etc/vsftpd/vsftpd.conf
-----------------------------------------------------------------------------
yum install vsftpd
yum install ftp
cp /etc/vsftpd/vsftpd.conf /etc/vsftpd/vsftpd.conf.back
chkconfig --levels 235 vsftpd on
service vsftpd start
-----------------------------------------------------------------------------
vi /etc/sysconfig/iptables
-----------------------------------------------------------------------------
Добавьте следующую строку, перед REJECT строкой, для открытия 21 порта:

-A INPUT -m state --state NEW -m tcp -p tcp --dport 21 -j ACCEPT
-----------------------------------------------------------------------------
Опция 	Описание
anonymous_enable=NO 	Запрещаем анонимный доступ
local_enable=YES 	Разрешаем доступ локальным пользователям
write_enable=YES 	Даем пользователям FTP права на запись
connect_from_port_20=NO 	Отключаем 20 порт, уменьшает привилегии VSftpd
chroot_local_user=YES 	Chroot всех пользователей
local_umask=022 	Устанавливаем маску 022, чтобы быть уверенными в том,
			что для всех файлов (644) и папок (755) которые мы
			закачиваем, устанавливаются соответствующие права
-----------------------------------------------------------------------------
sudo apt-get install vsftpd
netstat -npl
-----------------------------------------------------------------------------
anonymous_enable на NO.

local_enable – разрешает использовать для входа на сервер пользователей
		зарегистрированых в системе.
write_enable – разрешает выполнять пользователям любые FTP команды.
chroot_local_user (по умолчанию значение YES)  – запрещает возможность выхода
		из пределов chroot. т.е пользователи не смогут получить доступ
		к другим файлам сервера. Доступ будет осушествлятся только в
		пред домашних каталогов.
-----------------------------------------------------------------------------
Создаем нового пользователя user для FTP сделать это можно командой:
sudo useradd -d /var/www/path/to/your/dir -s /sbin/nologin user
-----------------------------------------------------------------------------
Далее необходимо задать пароль для пользователя user:
sudo passwd user #меняем пароль пользователя user
-----------------------------------------------------------------------------
После чего создадим домашнею директорию для пользователя user:
sudo mkdir -p /var/www/path/to/your/dir 
-----------------------------------------------------------------------------
Проверяем создалась ли директория:
sudo ls -la /var/www/path/to/your/dir/span>
-----------------------------------------------------------------------------
Для разрешения чтения и записи пользователю user в свой домашний каталог меняем права:
-----------------------------------------------------------------------------
sudo chown -R user /var/www/path/to/your/dir #меняем владельца каталога
sudo chmod 775 /var/www/path/to/your/dir #разрешаем запись в каталог
-----------------------------------------------------------------------------
Создаем группу ‘webusers‘ для FTP пользователей, и добавляем в нее ‘user‘ :
-----------------------------------------------------------------------------
sudo groupadd webusers #создаем группу webusers
sudo usermod -G webusers user #добовляем пользователя user в группу
-----------------------------------------------------------------------------
Перезапускаем наш FTP сервер:
sudo service vsftpd restart
-----------------------------------------------------------------------------
Настройка анонимного доступа к FTP серверу
-----------------------------------------------------------------------------
anonymous_enable=YES #Включаем если была выключена
-----------------------------------------------------------------------------
После установки загрузка файлов анонимно разрешена и происходит в каталог по
умолчанию /srv/ftp в процессе установки создается пользователь ftp с домашним
каталогом /srv/ftp. Если вы его хотите изменить, необходимо просто создать
новый каталог и изменить домашний каталог для пользователя ftp:
-----------------------------------------------------------------------------
sudo mkdir /var/www/path/to/your/dir #создаем папку
sudo usermod -d /var/www/path/to/your/dir ftp # назначаем пользователю user 
-----------------------------------------------------------------------------
При данной конфигурации будет осуществятся анонимный доступ к каталогу
/var/www/path/to/your/dir
После изменений перезапустите vsftpd:
-----------------------------------------------------------------------------
sudo service vsftpd restart
-----------------------------------------------------------------------------
Активный режим может не работать, если не поддерживается на фаерволе со стороны клиента.
Например, для iptables нужно задействовать модуль nf_conntrack_ftp. 
-----------------------------------------------------------------------------
Samba
-----------------------------------------------------------------------------
SAMBA – программа для обращения к сетевым дискам по SMB/CIFS.
-----------------------------------------------------------------------------
СЕРВЕРА
-----------------------------------------------------------------------------
1. Файловый, Печати
2. Порт SMBD:139, 445; NMBD:137, 138
-----------------------------------------------------------------------------
Типы авторизации:
-----------------------------------------------------------------------------
3. ADS - Член Домена(+kerberos), через WINBIND
4. Domain - направляет на авторизацию к PDC, BDC
5. Server - отправляет к другому Samba server иначе применяет режим User.
6. Share - открытый доступ, безпарольный.
7. User - passwd+smbpasswd
8. Unix users+passwd
-----------------------------------------------------------------------------
ФАЙЛЫ
-----------------------------------------------------------------------------
9. smb.conf, smbusers, lmhosts, smbpasswd, smbclient, smbcontrol
smb.conf - конфигурация
secrets.tdb - DB passwords
lmhosts - Разрешением имен NetBios
smbusers - можно установить соответствие windows users к unix user 
-----------------------------------------------------------------------------
КОНФИГУРАЦИЯ
-----------------------------------------------------------------------------
10. Global(Network, Log, Server, Broser control, DNS, Char sets, Printing),
Share(Comment, Path, Browseable, Writable, Valid User, Guest, Printable).
-----------------------------------------------------------------------------
ВЕБ НАСТРОЙКА
-----------------------------------------------------------------------------
# yum -y install samba-swat
11. SWAT(/etc/xinet.d/swat –> disable = no  )
-----------------------------------------------------------------------------
КОМАНДЫ
-----------------------------------------------------------------------------
12. testparm - тест конфигурации
13. useradd bestuser
14. smbpasswd
smbpasswd -W - ПАРОЛЬ АДМИНА
smbpasswd -a bestuser
smbpasswd -a -добавляет пользователя 
smbpasswd -e enable
smbpasswd -x disable
15. smbstatus -p
16. smbclient //192.168.146.132/home -U bestuser
-----------------------------------------------------------------------------
	Пример 1
-----------------------------------------------------------------------------
 Samba в CentOS 7 в качестве standalone-сервера
как для анонимного доступа, так и с требованием аутентификации.
-----------------------------------------------------------------------------
Для начала, нам потребуется ее установить:
yum install samba samba-client samba-common
-----------------------------------------------------------------------------
Анонимный доступ
-----------------------------------------------------------------------------
Файл конфигурации samba находится в /etc/samba/smb.conf
Посмотрим, из чего он состоит.
-----------------------------------------------------------------------------
Первый его раздел — это [global]
Как и намекает его название, он содержит глобальные настройки samba.
Мы не будем здесь разбирать функцию печати, а сосредоточимся на параметрах, 
имеющих отношение к общим папкам. Что мы здесь можем настроить:
-----------------------------------------------------------------------------
workgroup — имя рабочей группы, к котоой принадлежит наш сервер.
server string — описание сервера
netbios name — netbios-имя сервера
interfaces — интерфейсы, через которые мы сможем подключиться (не следует
исключать интерфейс localhost — lo)
hosts allow — хосты, которым будет разрешен доступ
hosts deny — запрещенные хосты
log file — размещение логов
max log size — максимальный размер файла (в KB), после чео будет создан новый
security — метод проверки подлинности пользователей.
В данный момент доступна только опция «user». Использовавшиеся ранее «share» и
«server» более не поддерживаются.
passdb backend — поддерживаются варианты «tdbsam» и «ldapsam»
map to guest — когда кто-либо подключается к общим папкам, то CentOS пытается
его аутентифицировать прозрачно, то есть используя учетные данные, известные
операционной системе, откуда он подключается. Если такой пользователь есть и
пароль совпадает, то подключение произойдет успешно. Если пользователь есть,
но пароль не совпадает, будет выведено диалоговое окно с предложением
аутентифицироваться. Если же пользователь с таким имене операцонной системе
файлового сервера не известен, то она предоставит гостевой доступ. Значение
этого параметра «map to guest = bad user» означает, что доступ будет предоставлен
от имени пользователя nobody.
Если очень нужно, чтобы с гостевым доступом ассоциировался другой аккаунт,
можно добавить, например, следующий параметр:
guest account = root
-----------------------------------------------------------------------------
Секция глобальных настроек, включающая вышеописанные параметры, может выглядеть так:
-----------------------------------------------------------------------------
[global]
workgroup = WORKGROUP
server string = Samba Server %v
netbios name = centos
interfaces = lo eth0 192.168.12.2/24 192.168.13.2/24
hosts allow = 127. 192.168.12. 192.168.13.
log file = /var/log/samba/log.%m
max log size = 50
security = user
passdb backend = tdbsam
map to guest = bad user
-----------------------------------------------------------------------------
Теперь перейдем к настройке общей папки.
Для начала мы ее создадим.
mkdir /ashare
-----------------------------------------------------------------------------
Теперь добавим требуемую конфигурацию в smb.conf
Например, так:
[ashare]
comment = Share with anonymous access
path = /ashare
browsable = yes
writable = yes
read only = no
guest ok = yes
-----------------------------------------------------------------------------
Что мы тут указали:
comment — описание общей папки
browsable — «yes» — означает, что общая папка не будет скрытой и пользователи
смогут увидеть ее среди доступных общих папок.
writable — общая папка папка доступна для записи
read only — writable наоборот
guest ok — разрешен ли гостевой доступ
Кроме того, мы можем указать параметры force user и force group для того, чтобы
принудительно указывать в качестве владельца созданных в папке файлов нужного
пользователя и группу. Это может пригодится при разрешении анонимного доступа
к папке.
-----------------------------------------------------------------------------
Итак, наш файл конфигурации общей папки с возможностью анонимного доступа
вполне может выглядеть следующим образом:
-----------------------------------------------------------------------------
[global]
workgroup = WORKGROUP
server string = Samba Server %v
netbios name = centos
security = user
passdb backend = tdbsam
map to guest = bad user
 
[ashare]
comment = Share with anonymous access
path = /ashare
browsable = yes
writable = yes
guest ok = yes
public = yes
-----------------------------------------------------------------------------
Проверить правильность файла конфигурации можно командой testparm.
-----------------------------------------------------------------------------
Теперь отвлечемся от непостредственно от файла конфигурации.
Скорее всего у нас включен firewall, и его конфигурация по умолчанию не
предусматривает подключения к общим папкам. Нам нужно это поправить.
Сделать мы это может следующим образом:
-----------------------------------------------------------------------------
firewall-cmd --add-service samba
firewall-cmd --add-service samba --permanent
-----------------------------------------------------------------------------
Первая команда меняет текущую конфигурацию, вторая, отличающаяся только
параметром —permanent записывает изменение в постоянную конфигурацию.
-----------------------------------------------------------------------------
Кроме сетевого экрана, скорее всего, против предоставления доступа к папке
будет и SELinux. Для того, чтобы он изменил свое мнение, изменим контекст
безопасности для публикуемой папки:
-----------------------------------------------------------------------------
chcon -t samba_share_t /ashare
-----------------------------------------------------------------------------
Далее включаем службы samba.
systemctl enable smb.sevice
systemctl enable nmb.sevice
systemctl start smb.sevice
systemctl start nmb.sevice
-----------------------------------------------------------------------------
Проверить результат выполнения предшествующих команд можно, запустив
systemctl list-units
-----------------------------------------------------------------------------
Теперь, если мы попробуем зайти в общую папку, то нас, вероятнее всего, пустят.
Однако создать в ней что-нибудь у нас не получится. Связано это с правами
доступа к самой папке.
-----------------------------------------------------------------------------
Если ввести команду:
ls -l /
-----------------------------------------------------------------------------
то в строке, соответствующей нашей папке, мы увидим что-то вроде:
drwxr-xr-x 2 root root 6 Feb 4 12:30 ashare

Первый столбец сообщает нам о следующем:
d — directory, то есть это папка, с этим мы спорить не будем.
rwx — права доступа для владельца папки, а именно — read, write, execute.
Владелец указан в третьей колонке, то есть root.
r-x — права доступа для группы-владельца — read, execute. Группа указывается
в четвертой колонке — root.
r-x — права для всех остальных пользователей, не являющихся владельцем, и не
входящим в группу папки.
-----------------------------------------------------------------------------
Как мы вспоминали ранее, при подключении пользователя, для которого не
существует учетной записи на сервере общих папок, он получет доступ от имени
пользователя nobody. Тут мы можем поступить двумя способами.
Назначить пользователя и группу nobody владельцем и группой для папки /ashare
-----------------------------------------------------------------------------
chown -R nobody:nobody /ashare
-----------------------------------------------------------------------------
Либо задать права доступа для всех пользователей
chmod -R 777 /ashare
-----------------------------------------------------------------------------
Где 7 — это 4 (read) + 2 (write) + 1 (execute).
Каждая 7 соответствует павам доступа владельца, группы-владельца и всех
остальных пользователей, соответственно.
-----------------------------------------------------------------------------
Доступ с аутентификацией
-----------------------------------------------------------------------------
Например, мы решили создать общую папку для пользователей root и some_other_user.
Причем второго пользователя еще нет и нам нужно будет его создать.
-----------------------------------------------------------------------------
Но начнем с создания папки:
mkdir /share
-----------------------------------------------------------------------------
В файл smb.conf добавим раздел для новой общей папки:
----------------------------------------------------------------------------- 
[share]
comment = Share with authenticated access
path = /share
browsable = yes
writable = yes
guest ok = no
valid users = root some_other_user
-----------------------------------------------------------------------------
После внесения изменений в smb.conf снова проверим его правильность командой
testparm.
-----------------------------------------------------------------------------
Как и в первом случае, изменим контекст безопасности для папки:
chcon -t samba_share_t /share
-----------------------------------------------------------------------------
Теперь перейдем к созданию пользователя some_other_user:
useradd some_other_user
-----------------------------------------------------------------------------
Зададим для него some_other_password:
passwd some_other_user
-----------------------------------------------------------------------------
Также нам нужно задать пароль для доступа к общим папкам, это делается
отдельной командой:
smbpasswd -a some_other_user
-----------------------------------------------------------------------------
Параметр -a указывает, что пароль задается для нового пользователя. Без него
команда попыталась бы изменить пароль для уже существующего пользователя.
-----------------------------------------------------------------------------
Теперь пользователь some_other_user может обращаться к папке /share, однако
только для чтения. Давайте в этот раз поступим следующим образом: создадим
группу, добавим туда пользователя some_other_user и уже для группы зададим
права доступа на /share.
-----------------------------------------------------------------------------
Создадим группу share_access
groupadd share_access
-----------------------------------------------------------------------------
Проверить существование группы можно:
cat /etc/group
-----------------------------------------------------------------------------
Проверить существование пользователя:
cat /etc/passwd
-----------------------------------------------------------------------------
Добавим пользователя some_other_user в группу share_access
usermod -a -G share_access some_other_user
-----------------------------------------------------------------------------
Проверить, что добавление удалось:
groups some_other_user
-----------------------------------------------------------------------------
Теперь укажем группу share_access в качестве владельца папки /share
chown -R :share_access /share
-----------------------------------------------------------------------------
И дадим ей право на запись:
chmod -R 775 /share
-----------------------------------------------------------------------------
Теперь, если нам в последующем потребуется предоставить доступ к папке /share
кому-нибудь еще, мы можем добавить этих пользователей в группу share_access.
Однако, кроме этого нам будет нужно добавить их в значение параметра valid
users в файле smb.conf.
-----------------------------------------------------------------------------
С другой стороны, мы можем уже сейчас вместо отдельных пользователей в smb.conf
указать группу. Например так:
valid users = root @share_access
-----------------------------------------------------------------------------
При этом весь файл smb.conf может выглядеть так:
[global]
workgroup = WORKGROUP
server string = Samba Server %v
netbios name = centos
security = user
passdb backend = tdbsam
map to guest = bad user
 
[ashare]
comment = Share with anonymous access
path = /ashare
browsable = yes
writable = yes
guest ok = yes
 
[share]
comment = Share with authenticated access
path = /share
browsable = yes
writable = yes
guest ok = no
valid users = root @share_access
-----------------------------------------------------------------------------
	Пример 2
-----------------------------------------------------------------------------
Быстрая и простая настройка samba
-----------------------------------------------------------------------------
Конфигурации справедливы для 3-й версии самбы. Дальше решаем, что нам нужно:

    доступ по пользователю и паролю,
    доступ по ip адресу,
    доступ всем подряд без ограничений.

В зависимости от этого настройки будут немного разные.
-----------------------------------------------------------------------------
Для доступа по паролю рисуем такой конфиг:
-----------------------------------------------------------------------------
[global]
security = user
passdb backend = tdbsam
workgroup = MYGROUP
server string = Samba

[share]
path = /mnt/shara
valid users = @users
force group = users
create mask = 0660
directory mask = 0771
writable = yes
browseable = yes
-----------------------------------------------------------------------------
Перезапускаем самбу. Дальше добавляем пользователя в систему примерно так:
-----------------------------------------------------------------------------
# useradd share-user -M -G users -s /sbin/nologin
-----------------------------------------------------------------------------
Импортируем этого пользователя в самбу и задаем пароль:
-----------------------------------------------------------------------------
# smbpasswd -a share-user
-----------------------------------------------------------------------------
И пробуем зайти на шару по адресу:
\\ip-сервера\share
-----------------------------------------------------------------------------
Чтоб организовать доступ в зависимости от ip адреса,
делаем такие настройки в smb.conf:
-----------------------------------------------------------------------------
[global]
security = share
workgroup = MYGROUP
server string = Samba
map to guest = bad user

[share]
path = /mnt/files
browsable = yes
writable = yes
guest ok = yes
read only = no
hosts allow = 192.168.0.171
-----------------------------------------------------------------------------
В данном случае полный доступ будет у адреса 192.168.0.171. Чтобы добавить
всю подсеть, то указать нужно следующее:
-----------------------------------------------------------------------------
hosts allow = 192.168.0.
-----------------------------------------------------------------------------
Комбинировать можно разные подсети и адреса, разделяя их пробелами. Делаем
перезапуск самбы и проверяем.
-----------------------------------------------------------------------------
Если у вас установлена samba 4, то эта конфигурация не заработает и вы
получите ошибку:
-----------------------------------------------------------------------------
 WARNING: Ignoring invalid value 'share' for parameter 'security'
-----------------------------------------------------------------------------
Чтобы доступ по ip нормально заработал, вам необходимо внести следующие
изменения в приведенный выше конфиг:
-----------------------------------------------------------------------------
security = user
map to guest = Bad Password
-----------------------------------------------------------------------------
Остальные параметры оставляете те же. После этого доступ по ip будет
работать и на 4-й версии самбы.
-----------------------------------------------------------------------------
	Пример 3
-----------------------------------------------------------------------------
Samba с интеграцией в Active Directory

https://serveradmin.ru/nastroyka-samba-s-integratsiey-v-ad/
-----------------------------------------------------------------------------
    1 Добавляем сервер к домену через realm
    2 Настройка Samba с интеграцией в AD через sssd
    3 Вводим CentOS 7 в домен с помощью winbind
    4 Настройка прав доступа на файлы в Samba
-----------------------------------------------------------------------------
Прежде чем начинать настройку файлового сервера samba, прочитайте полностью
материал, чтобы решить, каким способом будете настраивать. По ходу написания
статьи у меня получились 2 принципиально разных решения. 
-----------------------------------------------------------------------------
Способ добавления linux сервера в домен Windows Server:
-----------------------------------------------------------------------------

    Использовать известное и универсальное средство winbind.
-----------------------------------------------------------------------------
	Вариант с winbind
-----------------------------------------------------------------------------
Добавление CentOS 7 в домен Windows
-----------------------------------------------------------------------------
# yum -y install samba-winbind samba-winbind-clients pam_krb5 krb5-workstation ntp ntpdate
-----------------------------------------------------------------------------
Для продолжения настройки вам необходимо знать следующие вещи — FQDN имя
контроллера домена, его ip адрес и учетную запись с правами на ввод компьютера
в домен.
-----------------------------------------------------------------------------
Первым делом вручную синхронизируем часы компьютера с контроллером домена:

# ntpdate winsrv.xs.local
-----------------------------------------------------------------------------
Добавляем наш контроллер в список серверов для обновления в файле /etc/ntp.conf,
запускаем ntp и добавляем в автозагрузку:
-----------------------------------------------------------------------------
# systemctl enable ntpd
# systemctl start ntpd
-----------------------------------------------------------------------------
Синхронизация времени с контроллером домена не является обязательным действием.
Но в случае расхождения времени более чем на 5 минут, будут возникать проблемы,
которые на первый взгляд будут неочевидными и решать их трудно. Поэтому на
всякий случай процедуру лучше провести. Очень подробно о настройке времени в
CentOS 7 рассказано отдельно. 
-----------------------------------------------------------------------------
Выполняем команду для передачи настроек керберосу:
-----------------------------------------------------------------------------
# authconfig --enablekrb5 --krb5kdc=xs-winsrv.xs.local --krb5adminserver=xs-winsrv.xs.local --krb5realm=XS-WINSRV.XS.LOCAL --enablewinbind --enablewinbindauth --smbsecurity=ads --smbrealm=XS.LOCAL --smbservers=xs-winsrv.xs.local --smbworkgroup=XS --winbindtemplatehomedir=/home/%U --winbindtemplateshell=/bin/bash --enablemkhomedir --enablewinbindusedefaultdomain --update
-----------------------------------------------------------------------------
Команда вся идет в одну строчку. Скопируйте ее сначала в текстовый файл и
подредактируйте под свои параметры. Проверьте, что нигде не пропали и не
 перед параметром. В данном случае:
-----------------------------------------------------------------------------
Информационная таблица 
xs.local 		название домена
10.1.3.4 		ip адрес контроллера домена
xs-winsrv.xs.local 	полное имя контроллера домена
xs-design 		имя сервера centos, который вводим в домен
admin51 		учетная запись администратора домена

    xs — название домена
    winsrv — имя контроллера домена
    winsrv.xs.local — полное имя домена
-----------------------------------------------------------------------------
Вывод после работы команды будет такой:
-----------------------------------------------------------------------------
Job for winbind.service failed. See 'systemctl status winbind.service' and
'journalctl -xn' for details.
getsebool: SELinux is disabled
-----------------------------------------------------------------------------
Это нормально. Обращаю внимание, что SELinux у меня отключен.
-----------------------------------------------------------------------------
Теперь заводим машину в домен:
-----------------------------------------------------------------------------
Enter admin51's password:
Using short domain name -- XS
Joined 'XS-DESIGN' to dns domain 'xs.local'
No DNS domain configured for xs-design. Unable to perform DNS Update.
DNS update failed: NT_STATUS_INVALID_PARAMETER
-----------------------------------------------------------------------------
Вводим пароль, ждем некоторое время. Если ошибки не появилось, значит
компьютер успешно включен в домен.
-----------------------------------------------------------------------------
В принципе, ничего страшного. Нам придется самим создать A запись на DNS
сервере. Я не понимаю, почему иногда она не создается автоматически. Во время
написания статьи, я использовал один сервер, у него не было этой ошибки при
вводе в домен. Когда проверял статью на втором сервере, получил эту ошибку.
Проверяем на контроллере домена в списке компьютеров наш сервер и создаем
руками А запись, соответствующую имени сервера и его IP адресу.
-----------------------------------------------------------------------------
Теперь рисуем конфиг для самбы примерно такой.
-----------------------------------------------------------------------------
# mcedit /etc/samba/smb.conf
-----------------------------------------------------------------------------
[global]
   workgroup = XS
   password server = xs-winsrv.xs.local
   realm = XS.LOCAL
   security = ads
   idmap config * : range = 16777216-33554431
   template homedir = /home/%U
   template shell = /bin/bash
   kerberos method = secrets only
   winbind use default domain = true
   winbind offline logon = false

   passdb backend = tdbsam

   load printers = no
   show add printer wizard = no
   printcap name = /dev/null
   disable spoolss = yes

   domain master = no
   local master = no
   preferred master = no
   os level = 1

   log level = 3
   log file = /var/log/samba/log.%m

[shara]
   path = /mnt/shara
   writeable = yes
   browsable = yes
   valid users = "@XS\Пользователи домена"
   admin users = "@XS\Администраторы домена"
   create mask = 0600
   directory mask = 0700
-----------------------------------------------------------------------------
У меня русский язык на контроллере домена, поэтому и имена групп на русском.
Проблем с этим не возникает. Не забудьте создать директорию /mnt/shara.
-----------------------------------------------------------------------------
Запускаем samba и winbind и добавляем в автозагрузку.
-----------------------------------------------------------------------------
# systemctl start winbind
# systemctl start smb.service
# systemctl enable winbind
# systemctl enable smb.service
-----------------------------------------------------------------------------
Выполняем ряд проверок, чтобы убедиться, что все в порядке, winbind работает
и samba будет получать актуальную информацию о пользователях и группах домена.
-----------------------------------------------------------------------------
Проверяем, все ли у нас корректно работает. Для начала проверим наличие
доверительной учетной записи сервера на КД:

# wbinfo -t 
checking the trust secret for domain XS via RPC calls succeeded
-----------------------------------------------------------------------------
Все в порядке. Теперь проверяем, может ли наш сервер получать списки
пользователей и групп. Первая команда выводит список всех групп домена,
вторая — всех пользователей:

# wbinfo -g
# wbinfo -u
-----------------------------------------------------------------------------
Проверим авторизацию пользователя через winbind:

# wbinfo -a XS\\control%'pass'
plaintext password authentication succeeded
challenge/response password authentication succeeded
-----------------------------------------------------------------------------
В данном случае control — имя пользователя домена, pass — его пароль. Успешная
проверка выглядит так, как у меня.
-----------------------------------------------------------------------------
Теперь запросим билетик кербероса:

# kinit administrator@XS.LOCAL
-----------------------------------------------------------------------------
Дальше вводите пароль. Если ошибки не выскочило, значит все в порядке. Проверим
билет командой:
-----------------------------------------------------------------------------
# klist
Ticket cache: KEYRING:persistent:0:0
Default principal: administrator@XS.LOCAL

Valid starting Expires Service principal
12/04/2015 23:19:33 12/05/2015 09:19:33 krbtgt/XS.LOCAL@XS.LOCAL
renew until 12/11/2015 23:19:29
-----------------------------------------------------------------------------
В завершении проверок посмотрим, корректно ли система сопоставляет доменные
учетные записи локальным.
-----------------------------------------------------------------------------
# id control
uid=16777216(control) gid=16777220(пользователи домена) groups=16777220
(пользователи домена),16777221(gr_z),16777222(gr_sams2),16777223(gr_y),
16777217(BUILTIN\users)
-----------------------------------------------------------------------------
Все в порядке, проверки прошли. Мы полностью подготовили сервер к авторизации
пользователей доменными учетными записями.
-----------------------------------------------------------------------------
Все в порядке. Теперь все готово для корректной работы файлового сервера на
основе Samba с доменными учетными записями. В завершении настроек, сделаем
администратора домена владельцем нашей шары.
-----------------------------------------------------------------------------
# chown admin51:'пользователи домена' /mnt/shara
-----------------------------------------------------------------------------
Проверяем, что получилось.

# ll /mnt
total 0
drwxr-xr-x 2 admin51 пользователи домена 6 Sep 27 17:15 shara
-----------------------------------------------------------------------------
Уберем доступ на чтение у всех остальных, оставим полные права для пользователя
admin51 и на чтение у пользователей домена.

# chmod 0750 /mnt/shara
-----------------------------------------------------------------------------
Идем на любую виндовую машину и пробуем зайти на шару по адресу \\ip-адрес-сервера.
Попадаем на нашу шару.
-----------------------------------------------------------------------------
Если не получилось зайти, проверьте настройки iptables. На время отладки можно
их отключить. Так же убедитесь, что у вас запущена служба smb.service. 
-----------------------------------------------------------------------------
Управлять правами доступа можно через windows acl с любой машины windows, где
учетная запись пользователя домена будет обладать необходимыми правами. Если
по какой-то причине это не получится (а я с такими ситуациями сталкивался
достаточно часто), на помощь придут консольные утилиты getfacl для проверки
прав и setfacl для изменения прав. Документация по этим командам есть в сети
и легко ищется. Я рекомендую всегда использовать эти команды, когда вы
выполняете изменение прав по большому дереву каталогов. Через консоль
выставление прав будет выполнено раз в 5-10 быстрее, чем через windows acl.
 На больших файловых архивах разница может быть в десятки минут или даже часы.
-----------------------------------------------------------------------------
Настройка прав доступа на файлы в Samba
-----------------------------------------------------------------------------
Сделаю небольшое пояснение по правам доступа в файловом сервере samba. Вопрос
этот сложный и объемный. Ему можно посвятить и отдельную статью. Но для
полноты картины по настройке самбы, расскажу самое основное.

Как я уже ранее сказал, изменять права доступа к каталогам на файловом сервере
можно с помощью команды setfacl. Давайте сейчас посмотрим на права доступа,
которые установлены:

# getfacl /mnt/samba

# file: mnt/shara
# owner: admin51
# group: пользователи\040домена
user::rwx
group::r-x
other::---
-----------------------------------------------------------------------------
С такими правами что-то создавать в папке сможет только пользователь admin51,
а пользователи домена смогут только просматривать файлы и каталоги. Сделаем
более прикладной вариант. Добавим права доступа на чтение и запись еще одной
доменной группе — gr_it.
-----------------------------------------------------------------------------
# setfacl -m g:gr_it:rwx /mnt/shara
-----------------------------------------------------------------------------
Обращаю внимание, что иногда при копировании команд setfacl они не отрабатывают,
выдавая не очень понятную ошибку:

setfacl: Option -m: Invalid argument near character 1
-----------------------------------------------------------------------------
Наберите команду с клавиатуры, либо просто удалите и наберите снова ключ -m,
он почему-то при копировании часто дает эту ошибку.
-----------------------------------------------------------------------------
Смотрим, что получилось:

# getfacl /mnt/shara

# file: mnt/shara
# owner: admin51
# group: пользователи\040домена
user::rwx
group::r-x
group:gr_it:rwx
mask::rwx
other::---
-----------------------------------------------------------------------------
То, что надо. Теперь пользователи группы gr_it имеют полные права на шару.
Создадим одним таким пользователем папку test1 на нашей шаре и посмотрим, какие
права она получит.
-----------------------------------------------------------------------------
# getfacl /mnt/shara/test1
-----------------------------------------------------------------------------
# file: mnt/shara/test1
# owner: user1
# group: пользователи\040домена
user::rwx
group::---
other::---
-----------------------------------------------------------------------------
Права на папку имеет только ее создатель и больше никто. Для того, чтобы
наследовались права с вышестоящего каталога, необходимо на этот вышестоящий
каталог добавить дефолтные права доступа. Примерно вот так.
-----------------------------------------------------------------------------
# setfacl -m d:g:gr_it:rwx,d:g:'пользователи домена':rx /mnt/shara
-----------------------------------------------------------------------------
Смотрим, что получилось:

# getfacl /mnt/shara

# file: mnt/shara
# owner: admin51
# group: пользователи\040домена
user::rwx
group::r-x
group:gr_it:rwx
mask::rwx
other::---
default:user::rwx
default:group::r-x
default:group:пользователи\040домена:r-x
default:group:gr_it:rwx
default:mask::rwx
default:other::---
-----------------------------------------------------------------------------
Создадим теперь тем же пользователем еще одну папку test2 и проверим ее права.
-----------------------------------------------------------------------------
# getfacl /mnt/shara/test2

# file: mnt/shara/test2
# owner: user
# group: пользователи\040домена
user::rwx
group::---
group:пользователи\040домена:r-x
group:gr_it:rwx
mask::rwx
other::---
default:user::rwx
default:group::r-x
default:group:пользователи\040домена:r-x
default:group:gr_it:rwx
default:mask::rwx
default:other::---
-----------------------------------------------------------------------------
Применилось наследование с вышестоящих папок. Не забывайте про дефолтные права
и учитывайте их при настройке прав доступа на файловом сервере.
-----------------------------------------------------------------------------
Для удобной и корректной работы с правами доступа я обычно для крупных,
корневых директорий выставляю права аккуратно через setfacl в консоли. Какие-то
мелкие изменения по пользователям и группам в более низших иерархиях директорий
делаю через windows acl с какой-нибудь виндовой машины.
-----------------------------------------------------------------------------
Еще важно знать одну особенность выставления прав доступа в linux. В моей
практике часто требуется дать какому-нибудь пользователю доступ в одну
директорию, которая располагается там, где у пользователя нет вообще никаких
прав. В windows эта проблема решается просто — даются права на конкретную папку,
а пользователю кладется ярлык на эту папку. В итоге он имеет доступ к нужной
директории и больше никуда.

В linux так сделать не получится. Для того, чтобы дать таким образом доступ на
отдельную директорию пользователю, необходимо, чтобы по всем вышестоящим
директориям у него были права на исполнение, то есть X. Их придется выставлять
вручную по всем вышестоящим папкам. Результат будет такой же, как и в винде
— пользователь получит доступ на чтение только в указанную папку, но для этого
придется выполнить больше действий. Если не знаешь этот нюанс, можно потратить
много времени, прежде чем поймешь, в чем проблема.
-----------------------------------------------------------------------------
	Пример 4
-----------------------------------------------------------------------------
Логирование операций с файлами в Samba
-----------------------------------------------------------------------------
https://serveradmin.ru/logirovanie-operatsiy-s-faylami-v-samba/
-----------------------------------------------------------------------------
	Пример 5
-----------------------------------------------------------------------------
Сохранение удаленных файлов Samba в корзине
-----------------------------------------------------------------------------
https://serveradmin.ru/nastroyka-korzinyi-v-samba/
-----------------------------------------------------------------------------
telnet ftp,smtp,imap,pop3
-----------------------------------------------------------------------------
ftp
-----------------------------------------------------------------------------
# ftp localhost
220 (vsFTPd 2.2.2)
Name (localhost:root): adm@al.local
331 Please specify the password.
Password:
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
# ftp> pwd
257 "/"
# ftp>
-----------------------------------------------------------------------------
smtp
-----------------------------------------------------------------------------
telnet yourSMTPserver.com 25
HELO host
-----------------------------------------------------------------------------
альтернатива
EHLO host
или
HELO IP
-----------------------------------------------------------------------------
Обратите внимание, команда HELO вводится с одной буквой L. Если вместо HELO
ввести команду EHLO, то после приветствия, сервер выведет список директив,
которые он поддерживает. 
-----------------------------------------------------------------------------
AUTH LOGIN — способ SMTP-аутентификации, в котором логин и пароль передаются
в виде текста, закодированного по алгоритму Base64. Обратите внимание, что
передавать свои логин и пароль таким образом далеко не безопасно! Итак, нам
нужно для начала закодировать по алгоритму Base64 свой логин на почтовом сервере
и пароль от него. Для этого воспользуемся языком Perl, а конкретнее — его
модулем MIME::Base64.
-----------------------------------------------------------------------------
$ perl -MMIME::Base64 -e 'print encode_base64("user\@server.ru");'
dXNlckBzZXJ2ZXIucnU=
$ perl -MMIME::Base64 -e 'print encode_base64("PASSWORD");'
UEFTU1dPUkQ=
-----------------------------------------------------------------------------
AUTH LOGIN
334 VXNlcm5hbWU6

dXNlckBzZXJ2ZXIucnU=
334 UGFzc3dvcmQ6

UEFTU1dPUkQ=
-----------------------------------------------------------------------------
MAIL From: <you@sender.com>
RCPT To: <your_friend@destination.com>
DATA
From: you@sender.com
To: your_friend@destination.com
Subject: testsubject
testletter
.
quit
-----------------------------------------------------------------------------
exim
imapsync
-----------------------------------------------------------------------------
IMAP
-----------------------------------------------------------------------------
telnet server imap
Если у нас соединение с сервером IMAP шифрованное (по SSL), то команда соединения будет следующей:
$ openssl s_client -crlf -ign_eof -connect mail-srv:993	
# openssl s_client -connect imap.server:993 -quiet

a login user pass
Далее смотрим список ящиков :
a2 LIST «» «*»
a list "" "*"
Запрашиваем у сервера статус папки Inbox
. status INBOX (messages)	
Выбираем папку Inbox
. select inbox
Даем команду серверу показать письмо № 7
. fetch 7 full	
Даем команду серверу показать тело письма № 7
. fetch 7 rfc822.text
a4 FETCH 1 BODY[]
Далее можем просмотреть список входящих писем и увидеть непрочитанные
a3 EXAMINE INBOX
a logout
-----------------------------------------------------------------------------
POP3
-----------------------------------------------------------------------------
telnet mail.belpak.by 110
user mikola
pass vaverka01
-----------------------------------------------------------------------------
Итак, мы вошли в данный почтовый ящик и получили доступ к его содержимому.
Теперь посмотрим общее количество писем в ящике (команда stat) и объем каждого
письма (команда list):
-----------------------------------------------------------------------------
stat
list
.
-----------------------------------------------------------------------------
Просмотр письма команда top X Y, где X - номер письма в вышеприведенном списке,
а Y - количество первых строчек тела письма, которые вы хотите просмотреть.
Если Y=0, будет показана только "шапка" письма.
-----------------------------------------------------------------------------
top 2 3
.
-----------------------------------------------------------------------------
Теперь Вы имеете какие-то представления о происхождении и содержании данного 
письма и можете решать, стоит ли его принимать и обрабатывать. И если Вы
все-таки решили удалить его, не читая, это делается командой dele X, где X,
как Вы уже догадались, - номер сообщения в списке. После этого еще раз можно
проверить текущее состояние ящика командой list и если остальные сообщения у
Вас вопросов не вызывают, рассоединяетесь с сервером по команде quit, после
чего можете работать с почтой традиционным образом:
-----------------------------------------------------------------------------
dele 2
list
retr 1
.
quit

-----------------------------------------------------------------------------

-----------------------------------------------------------------------------

-----------------------------------------------------------------------------

-----------------------------------------------------------------------------

-----------------------------------------------------------------------------

-----------------------------------------------------------------------------

-----------------------------------------------------------------------------

-----------------------------------------------------------------------------

-----------------------------------------------------------------------------

-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
Exim
-----------------------------------------------------------------------------
Установка Dovecot + Exim + Roundcube
-----------------------------------------------------------------------------
https://valerykoretsky.com/blog/mail-server-exim-centos7/
-----------------------------------------------------------------------------
	Установка связки Apache + MySQL + PHP
-----------------------------------------------------------------------------
yum -y install php-imap php-mbstring php-pdo php-mysql php-cli
-----------------------------------------------------------------------------
	Подключение дополнительных репозиториев
-----------------------------------------------------------------------------
rpm -Uvh http://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-8.noarch.rpm
-----------------------------------------------------------------------------
	Создание базы данных vexim
-----------------------------------------------------------------------------
mysql -u root -p
-----------------------------------------------------------------------------
mysql> CREATE DATABASE vexim;  
mysql> GRANT ALL ON vexim.* to vexim@localhost identified by 'password';  
mysql> quit
-----------------------------------------------------------------------------
	Установка Postfixadmin
-----------------------------------------------------------------------------
Скачиваем Postfixadmin и устанавливаем его в папку /var/www/html/postfixadmin
-----------------------------------------------------------------------------
wget http://sourceforge.net/projects/postfixadmin/files/postfixadmin/postfixadmin-3.0/postfixadmin-3.0.tar.gz
tar xpf postfixadmin-3.0.tar.gz
mv postfixadmin-3.0 /var/www/html/postfixadmin
chown -R apache.apache /var/www/html/postfixadmin
rm postfixadmin-3.0.tar.gz
cd /var/www/html/postfixadmin
vi config.inc.php
-----------------------------------------------------------------------------
Редактируем конфигурационный файл config.inc.php:
-----------------------------------------------------------------------------
$CONF['database_type'] = 'mysql';  
$CONF['database_host'] = 'localhost';  
$CONF['database_user'] = 'vexim';  
$CONF['database_password'] = 'password';  
$CONF['database_name'] = 'vexim';  

$CONF['encrypt'] = 'dovecot:CRAM-MD5';  
$CONF['dovecotpw'] = "/usr/bin/doveadm pw";

$CONF['configured'] = true;
-----------------------------------------------------------------------------
	Установка Dovecot
-----------------------------------------------------------------------------
yum -y install dovecot dovecot-mysql
-----------------------------------------------------------------------------
mv /etc/dovecot/dovecot.conf /etc/dovecot/dovecot.conf-orig
vi /etc/dovecot/dovecot.conf
-----------------------------------------------------------------------------
## Dovecot configuration file
  
base_dir = /var/run/dovecot/  
auth_default_realm = site.com 
auth_mechanisms = plain login cram-md5 
protocols = imap pop3  
listen = *  
disable_plaintext_auth = no  
dotlock_use_excl = yes  
first_valid_gid = 5  
first_valid_uid = 25  

mail_location = maildir:/var/vmail/%d/%u  
mail_privileged_group = mail  
passdb {  
  args = /etc/dovecot/dovecot-mysql.conf  
  driver = sql  
}   
service auth {  
  unix_listener auth-client {  
    group = exim  
    mode = 0660  
    user = exim  
  }  
  unix_listener auth-master {  
    group = exim  
    mode = 0600  
    user = exim  
  }  
  user = root  
}  
ssl = no  

userdb {  
  args = /etc/dovecot/dovecot-mysql.conf  
  driver = sql  
}  
verbose_proctitle = yes
  
protocol imap {  
  imap_client_workarounds = delay-newmail tb-extra-mailbox-sep  
}  
protocol pop3 {  
  pop3_client_workarounds = outlook-no-nuls oe-ns-eoh  
  pop3_uidl_format = %08Xu%08Xv  
}  
protocol lda {  
  auth_socket_path = /var/run/dovecot/auth-master  
  postmaster_address = info@site.com
}
-----------------------------------------------------------------------------
Для настройки доступа к базе данных, создаем отдельный конфиг dovecot-mysql.conf
-----------------------------------------------------------------------------
## Dovecot database configuration

driver = mysql  
connect = host=localhost dbname=vexim user=vexim password=password  
default_pass_scheme = CRAM-MD5  
password_query = SELECT `username` as `user`, `password` FROM  `mailbox` WHERE `username` = '%n@%d' AND `active`='1'  
user_query = SELECT 93 AS `uid`, 93 AS `gid` FROM `mailbox` WHERE `username` = '%n@%d' AND `active`='1'
-----------------------------------------------------------------------------
	Установка Exim
-----------------------------------------------------------------------------
yum -y install exim exim-mysql cyrus-sasl
mv /etc/exim/exim.conf /etc/exim/exim.conf-orig
vi /etc/exim/exim.conf
-----------------------------------------------------------------------------
######################################################################
#                    MAIN CONFIGURATION SETTINGS                     #
######################################################################

primary_hostname = mail.site.com
hide mysql_servers = localhost/vexim/vexim/password  

domainlist local_domains = ${lookup mysql{SELECT `domain` \  
                            FROM `domain` WHERE \  
                            `domain`='${quote_mysql:$domain}' AND \  
                            `active`='1'}}  
domainlist relay_to_domains = ${lookup mysql{SELECT `domain` \  
                            FROM `domain` WHERE \  
                            `domain`='${quote_mysql:$domain}' AND \  
                            `active`='1'}}  

hostlist relay_from_hosts = localhost:127.0.0.0/8:192.168.1.0/24
auth_advertise_hosts = *

acl_not_smtp = acl_not_smtp  
acl_smtp_rcpt = acl_check_rcpt  
acl_smtp_data = acl_check_data  

qualify_domain = site.com  
qualify_recipient = site.com
allow_domain_literals = true  
exim_user = exim  
exim_group = exim  
never_users = root  
rfc1413_query_timeout = 0s  

sender_unqualified_hosts = +relay_from_hosts  
recipient_unqualified_hosts = +relay_from_hosts  

ignore_bounce_errors_after = 45m  
timeout_frozen_after = 15d  
helo_accept_junk_hosts = 192.168.1.0/24  
auto_thaw = 1h  
smtp_banner = "$primary_hostname, ESMTP EXIM $version_number"  
smtp_accept_max = 50  
smtp_accept_max_per_connection = 25  
smtp_connect_backlog = 30  
smtp_accept_max_per_host = 20  
split_spool_directory = true  
remote_max_parallel = 15  
return_size_limit = 70k  
message_size_limit = 64M  
helo_allow_chars = _  
smtp_enforce_sync = true  

log_selector = \  
    +all_parents \  
    +connection_reject \  
    +incoming_interface \  
    +lost_incoming_connection \  
    +received_sender \  
    +received_recipients \  
    +smtp_confirmation \  
    +smtp_syntax_error \  
    +smtp_protocol_error \  
    -queue_run  

syslog_timestamp = no  

######################################################################
#                       ACL CONFIGURATION                            #
#         Specifies access control lists for incoming SMTP mail      #
######################################################################

begin acl  

acl_not_smtp:  
        deny message = Sender rate overlimit - $sender_rate / $sender_rate_period  
        ratelimit = 50 / 1h / strict  
        accept  

acl_check_rcpt:  
  deny    message          = "Lookup failed"  
          condition = ${if eq{$host_lookup_failed}{1}}  

  accept  hosts = :  
  deny    message       = "incorrect symbol in address"  
          domains       = +local_domains  
          local_parts   = ^[.] : ^.*[@%!/|]  

  deny    message       = "incorrect symbol in address"  
          domains       = !+local_domains  
          local_parts   = ^[./|] : ^.*[@%!] : ^.*/\\.\\./  

  accept  local_parts   = postmaster  
          domains       = +local_domains  

  deny    message       = "HELO/EHLO required by SMTP RFC"  
          condition     = ${if eq{$sender_helo_name}{}{yes}{no}}  

  accept  authenticated = *   

  deny    condition     = ${if eq{$sender_helo_name}\  
    {$interface_address}{yes}{no}}  
          hosts         = !127.0.0.1 : !localhost : *  
          message       = "My IP in your HELO! Access denied!"  

  deny    condition     = ${if match{$sender_helo_name}\  
    {\N^\d+$\N}{yes}{no}}  
          hosts         = !127.0.0.1 : !localhost : *  
          message       = "Incorrect HELO string"  

  warn  
        set acl_m0 = 30s  
  warn  
        hosts = +relay_from_hosts:4.3.2.1/32:192.168.1.0/24 #disable waits for 'friendly' hosts  
        set acl_m0 = 0s  
  warn  
        logwrite = Delay $acl_m0 for $sender_host_name \  
[$sender_host_address] with HELO=$sender_helo_name. Mail \  
from $sender_address to $local_part@$domain.  
        delay = $acl_m0  

  accept  domains       = +local_domains  
          endpass  
          message       = "No such user"  
          verify        = recipient  

  accept  domains       = +relay_to_domains  
          endpass  
          message       = "i don't know how to relay to this address"  
          verify        = recipient  

  deny    message       = "you in blacklist - $dnslist_domain \n $dnslist_text"  
          dnslists      = opm.blitzed.org : \  
                          cbl.abuseat.org : \  
                          bl.csma.biz   

  accept  hosts         = +relay_from_hosts  

  deny    message       = "Homo hominus lupus est"  

acl_check_data:  

  deny malware = */defer_ok  
  message = "Your message contains viruses: $malware_name"  

  accept  

######################################################################
#                      ROUTERS CONFIGURATION                         #
#               Specifies how addresses are handled                  #
######################################################################
#     THE ORDER IN WHICH THE ROUTERS ARE DEFINED IS IMPORTANT!       #
# An address is passed to each router in turn until it is accepted.  #
######################################################################
 
begin routers  

dnslookup:  
  driver = dnslookup  
  domains = ! +local_domains  
  transport = remote_smtp  
  ignore_target_hosts = 0.0.0.0 : 127.0.0.0/8  
  no_more  

system_aliases:  
    driver      = redirect  
    allow_fail  
    allow_defer  
    data = ${lookup mysql{SELECT `goto` FROM `alias` WHERE \  
            `address`='${quote_mysql:$local_part@$domain}' OR \  
                `address`='${quote_mysql:@$domain}'}}  

dovecot_user:  
  driver = accept  
  condition = ${lookup mysql{SELECT `goto` FROM \  
  `alias` WHERE \  
  `address`='${quote_mysql:$local_part@$domain}' OR \  
  `address`='${quote_mysql:@$domain}'}{yes}{no}}  
  transport = dovecot_delivery  

######################################################################
#                      TRANSPORTS CONFIGURATION                      #
######################################################################
#                       ORDER DOES NOT MATTER                        #
#     Only one appropriate transport is called for each delivery.    #
######################################################################
 
begin transports  

remote_smtp:  
  driver = smtp  

dovecot_delivery:  
  driver = pipe  
  command = /usr/libexec/dovecot/deliver -d $local_part@$domain  
  message_prefix =  
  message_suffix =  
  delivery_date_add  
  envelope_to_add  
  return_path_add  
  log_output  
  user = exim  

address_pipe:  
  driver = pipe  
  return_output  

address_reply:  
  driver = autoreply  

######################################################################
#                      RETRY CONFIGURATION                           #
###################################################################### 

begin retry  

*                    *       F,2h,15m; G,16h,1h,1.5; F,4d,6h  

######################################################################
#                      REWRITE CONFIGURATION                         #
###################################################################### 
 
begin rewrite  

######################################################################
#                   AUTHENTICATION CONFIGURATION                     #
######################################################################  

begin authenticators  

auth_plain:  
     driver = dovecot  
     public_name = PLAIN  
     server_socket = /var/run/dovecot/auth-client  
     server_set_id = $auth1  

auth_login:  
     driver = dovecot  
     public_name = LOGIN  
     server_socket = /var/run/dovecot/auth-client  
     server_set_id = $auth1  

auth_cram_md5:  
     driver = dovecot  
     public_name = CRAM-MD5  
     server_socket = /var/run/dovecot/auth-client  
     server_set_id = $auth1
-----------------------------------------------------------------------------
	Установка ClamAV
-----------------------------------------------------------------------------
yum -y install clamav clamav-update
-----------------------------------------------------------------------------
После установки необходимо обновить базы:
freshclam -v
-----------------------------------------------------------------------------
	Удаление Postfix
-----------------------------------------------------------------------------
alternatives --config mta
systemctl disable postfix
systemctl stop postfix
yum -y remove postfix
-----------------------------------------------------------------------------
	Настройка сервисов и доступов
-----------------------------------------------------------------------------
mv /usr/lib/systemd/system/clamd@.service /usr/lib/systemd/system/clamd.service
systemctl enable dovecot.service
systemctl enable exim.service
systemctl enable clamd.service
systemctl start clamd.service
-----------------------------------------------------------------------------
После включения всех сервисов необходимо произвести настройку прав доступа:
-----------------------------------------------------------------------------
mkdir /var/vmail
chown exim.exim -R /var/vmail
usermod -a -G exim clamav
chmod -Rf g+w /var/spool/exim
chmod -Rf g+s /var/spool/exim
chown exim.exim -R /var/spool/exim
chown clamav.clamav -R /var/run/clamav/
-----------------------------------------------------------------------------
	Настройка Postfixadmin
-----------------------------------------------------------------------------
Переходим по ссылке http://server_ip/postfixadmin/setup.php и следуем
инструкциям по установке. После создания суперадмина установщик выдаст хеш-код
пароля:
-----------------------------------------------------------------------------
$CONF['setup_password'] = '64de76b22a77709bdccae029a9cd8296:83ddcab23411cac728cbd5a092315bac89ca975a';
-----------------------------------------------------------------------------
Его необходимо заменить в файле config.inc.php (в корне каталога postfixadmin)
вместо этой строки:
-----------------------------------------------------------------------------
$CONF['setup_password'] = 'changeme';
-----------------------------------------------------------------------------
Далее необходимо войти в систему под созданными данными, добавить необходимые
домены и почтовые ящики.
-----------------------------------------------------------------------------
	Установка Roundcube
-----------------------------------------------------------------------------
yum -y install roundcubemail
-----------------------------------------------------------------------------
После установки необходимо добавить конфиг в web-сервер, чтобы скрипт
открывался по адресу http://server_ip/roundcubemail/
-----------------------------------------------------------------------------
vi /etc/httpd/conf.d/roundcubemail.conf
-----------------------------------------------------------------------------
#
# Round Cube Webmail is a browser-based multilingual IMAP client
#

Alias /roundcubemail /usr/share/roundcubemail
Alias /webmail /usr/share/roundcubemail

<Directory /usr/share/roundcubemail/>
        Options none
        AllowOverride Limit
        Require all granted
</Directory>

<Directory /usr/share/roundcubemail/installer>
        Options none
        AllowOverride Limit
        Require all granted
</Directory>

# Those directories should not be viewed by Web clients.
<Directory /usr/share/roundcubemail/bin/>
    Order Allow,Deny
    Deny from all
</Directory>
<Directory /usr/share/roundcubemail/plugins/enigma/home/>
    Order Allow,Deny
    Deny from all
</Directory>
-----------------------------------------------------------------------------
После записи необходимо перезагрузить Apache:
-----------------------------------------------------------------------------
systemctl restart httpd.service
-----------------------------------------------------------------------------
Для дальнейшей установки создаем базу данных, для этого подключаемся к MySQL:
-----------------------------------------------------------------------------	
mysql -u root -p
-----------------------------------------------------------------------------
mysql> CREATE DATABASE roundcubedb;
mysql> CREATE USER roundcubeuser@localhost IDENTIFIED BY 'password';
mysql> GRANT ALL PRIVILEGES on roundcubedb.* to roundcubeuser@localhost ;
mysql> FLUSH PRIVILEGES;
mysql> quit
-----------------------------------------------------------------------------
Дальше необходимо открыть установщик http://server_ip/roundcubemail/installer
и следуя инструкциям произвести настройку.
-----------------------------------------------------------------------------
На этом настройка завершена, переходим в Roundcube http://server_ip/roundcubemail/,
входим в систему под ранее созданным (в Postfixadmin) ящиком, производим
настройки и пользуемся.
-----------------------------------------------------------------------------
Чтобы пользоваться сервером в почтовой программе, необходимо использовать
следующие данные для подключения:
Сервер: mail.site.com
POP3 порт: 110
IMAP порт: 143
SMTP порт: 25
Логин/пароль: указаны при создании ящика.

-----------------------------------------------------------------------------
SPF, DKIM, DMARC
-----------------------------------------------------------------------------
Почтовый домен. Настройка SPF, DKIM, DMARC
-----------------------------------------------------------------------------

Данная статья являет продолжением темы по настройке почтового сервера. На этот
раз будет рассмотрен процесс настройки домена для отправки почтовых сообщений,
а именно добавление записей SPF, DKIM и DMARC.
-----------------------------------------------------------------------------
1. Добавление записи SPF
В ДНС TXT запись, кто может отправлять почту с сервера.
-----------------------------------------------------------------------------
SPF – это расширение для протокола отправки почты через SMTP сервер. С его
помощью проверяется легитимность домена отправителя. Владелец домена в TXT-записи
указывает перечень серверов которые могут отправлять почту, с обратным адресом
в этом домене.
-----------------------------------------------------------------------------
Запись SPF имеет следующие опции:
-----------------------------------------------------------------------------
    v=spf1 – указывается на используемую версию SPF;
    + – сообщает серверу, что письма необходимо принимать, является значением
по умолчанию;
    – – сообщает о необходимости отклонить почту;
    ~ – сообщает о необходимости принять письмо с пометкой СПАМ;
    ? – нейтральное отношение к принимаемой почте;
    mx – состоит со всех адресов серверов, указанных в MX-записях домена;
    a – позволяет добавить какое-либо доменное имя;
    ip4 – позволяет добавить в запись SPF один или несколько IPv4 адресов;
    ip6 – позволяет добавить один или несколько IPv6 адресов;
    include – добавляет сервера, которые включены в запись SPF указанного домена;
    ptr – проверяет PTR-запись IP-адреса отправителя на сходство с текущим доменом;
    all – все сервера, которые не были перечислены в текущей записи;
    exp – позволяет задать текст ошибки, в случае её возникновения;
    redirect – указывает серверу-получателю, что необходимо проверять запись
в заданного домена, вместо текущего.
-----------------------------------------------------------------------------
Простая TXT-запись для сайта site.com имеет вид:
site.com. IN TXT "v=spf1 mx ip4:8.8.8.8 ~all"
-----------------------------------------------------------------------------
В ней сообщается серверу, что необходимо принимать почту со всех серверов,
указанных в MX–записи, а также с сервера 8.8.8.8, остальную же почту принимать,
но помечать как СПАМ.
-----------------------------------------------------------------------------
2. Добавление записи DKIM
Подписывает исходящую почту
-----------------------------------------------------------------------------
DKIM – технология позволяющая производить проверку легитимности почтового
отправителя, путем добавления к сообщению специальной цифровой подписи.
-----------------------------------------------------------------------------
Добавление записи DKIM состоит из двух этапов:
-----------------------------------------------------------------------------
    генерация публичного и приватного ключей;
    редактирование DNS.
-----------------------------------------------------------------------------
Для начала, если ранее не делалось, необходимо внести в конфиг Exim
информацию о DKIM:
-----------------------------------------------------------------------------	
vi /etc/exim/exim.conf
-----------------------------------------------------------------------------
Добавляем в раздел “MAIN CONFIGURATION SETTINGS”:
	
DKIM_DOMAIN = ${lc:${domain:$h_from:}}
DKIM_FILE = /usr/local/etc/exim/${lc:${domain:$h_from:}}.key
DKIM_PRIVATE_KEY = ${if exists{DKIM_FILE}{DKIM_FILE}{0}}
-----------------------------------------------------------------------------
Добавляем сразу после:

remote_smtp:  
  driver = smtp
-----------------------------------------------------------------------------
это:

dkim_domain = DKIM_DOMAIN
dkim_selector = mail
dkim_private_key = DKIM_PRIVATE_KEY
-----------------------------------------------------------------------------
Здесь следует заметить, что dkim_selector (в нашем случае имеет
значение mail) будет использоваться при внесении записей в DNS.
-----------------------------------------------------------------------------
Следующим шагом является генерация ключей. Сначала генерируем
приватный ключ (RSA 2048 бит):
-----------------------------------------------------------------------------
openssl genrsa -out /usr/local/etc/exim/site.com.key 2048

Приватный ключ остается на сервере, с ним ничего делать не нужно.
-----------------------------------------------------------------------------
Далее необходимо сгенерировать публичный ключ на основе уже
созданного приватного:
openssl rsa -in /usr/local/etc/exim/site.com.key -pubout
-----------------------------------------------------------------------------
После чего будет получен, примерно, следующий результат,
который и необходимо добавить в DNS:
-----------------------------------------------------------------------------
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxXeojocAWYVt4Z627Rpv
yMFmBt0EIOT8C3gwVKiraKRucZ/oWSbyaXLLnf/JqotTLeOb4zLibMRxVJQJD0f1
Q4hVsiv6N3D8hvhHMQdi26z2FngIVyOyx7/sGkCbybantd0oqzDpSGxJWDZFR3vQ
E0h/LA+SRlg8Uk0wPOeMxB8kIv53EP0PUdf/aT7UP9xA1AWqsyBudf/0VQH4xqiO
AkmLmbQteQj6s0ilGW1+nB3ro5t5cMXCt7Th7Odc/Cg3Lk73Z2psPib0BmXyuP9p
K5KRLzfmyEBKBuRKf/1QQx15Ae2941GnkPAJyLtfJBEdPqnwv8h+EgINTOHBIjg/
jwIDAQAB
-----END PUBLIC KEY-----
-----------------------------------------------------------------------------
Следующим, финальным, шагом является добавление публичного ключа
в запись DKIM:
-----------------------------------------------------------------------------
mail._domainkey.site.com. TXT "v=DKIM1; k=rsa; t=s; p=публичный_ключ"

Стоит отметить, что mail в данной записи, это dkim_selector
который мы указывали в конфиге Exim.
-----------------------------------------------------------------------------
3. Добавление записи DMARC
Действует на входящую почту
-----------------------------------------------------------------------------
DMARC – это техническая спецификация, основной целью которой
является борьба с отправителями, которые подделывают обратные
адреса. 
-----------------------------------------------------------------------------
DMARC задает политику как проверять приходящую почту в этом домене и что делать
если письма не проходят аутентификацию SPF или DKIM.
-----------------------------------------------------------------------------
DMARC добавляется только после того, как были добавлены
записи SPF и DKIM, и сообщает серверу-получателю, что делать
с письмами, которые не прошли проверку легитимности отправителя.
-----------------------------------------------------------------------------
Основные опции:
-----------------------------------------------------------------------------
    v=DMARC1 – версия протокола;
    p – правило для домена (есть 3 варианта:
none – не принимать
никаких действий;
quarantine – отправлять сообщения в спам;
reject  – не принимать сообщения);
    aspf – режим проверки для SPF-записей;
    pct – процент сообщений, которые подлежат фильтрации;
    sp – правило для субдоменов, аналогичны правилу для доменов;
    rua – адрес для отчетов.
-----------------------------------------------------------------------------
Примеры конечных записей:
-----------------------------------------------------------------------------
    отклонять все сообщения, которые не прошли проверку:

_dmarc.site.com. TXT "v=DMARC1; p=reject"

    пропускать все сообщения, но отправлять отчет на почту admin@site.com:

_dmarc.site.com. TXT "v=DMARC1; p=none; rua=mailto:admin@site.com"
-----------------------------------------------------------------------------
Стоить отметить, что для нового домена не рекомендуется сразу
отклонять все сообщения, лучше пропускать все, но включить
отправку отчета, проверить все ли правильно работает и только
после этого включать полный запрет.

На этом настройка DNS-записей домена для отправки почты завершена.

-----------------------------------------------------------------------------
Postfix
-----------------------------------------------------------------------------
	Пример 1
-----------------------------------------------------------------------------
Настройка postfix + dovecot + mysql база + postfixadmin + roundcube + dkim
на CentOS 7
-----------------------------------------------------------------------------
https://serveradmin.ru/nastroyka-postfix-dovecot-centos-7/
-----------------------------------------------------------------------------
Содержание:

    1 Введение
    2 Установка postfixadmin
    3 Настройка postfix
    4 Настройка dovecot
    5 Проверка работы почтового сервера
    6 Установка web интерфейса roundcube
    7 Настройка фильтра почты sieve
    8 Настройка автоответчика
    9 Общие папки по imap
    10 Настройка dkim и spf
    11 Дополнительный функционал почтового сервера postfix
    12 Борьба со спамом средствами postfix
    13 Заключение
-----------------------------------------------------------------------------
Введение

Я буду настраивать почтовый сервер на ОС linux, а точнее на CentOS 7. За основу
будет взят postfix, который присутствует в этой системе из коробки. Инструкция
получится универсальной, можно использовать и для других дистрибутивов. Все
основные конфиги легко переносятся на разные системы, требуя минимальной
правки, в основном путей.

Я напишу статью на самом что ни на есть реальном примере, без какой-либо правки
доменов, ip и прочего, чтобы не ошибиться и показать максимально возможный реальный
пример. У меня есть технический домен zeroxzed.ru. Я буду использовать его в
своей работе. Почтовый сервер будет иметь имя mail.zeroxzed.ru. Всю теорию по
подготовке dns к установке и настройке почтового сервера я рассказывал в
предыдущей статье о почтовом сервере. Не хочу здесь повторяться. Уточню только
список действий, которые вам нужно проделать c ДНС:
-----------------------------------------------------------------------------
    Создаем A запись в DNS — mail.zeroxzed.ru.
    Добавляем или редактируем MX запись, указывая в качестве почтового сервера
mail.zeroxzed.ru.
    Просим провайдера прописать PTR для внешнего ip адреса, который будет
использовать почтовый сервер. В качестве ptr записи просим установить имя
нашего сервера — mail.zeroxzed.ru.
-----------------------------------------------------------------------------
Настройка dns записей для почтового сервера
-----------------------------------------------------------------------------
Я предпочитаю в качестве dns хостинга использовать сервера яндекса, даже если
не прикрепляю его почту к домену. На картинке показан минимально необходимый
набор записей, кроме PTR. Этими записями управляете не вы, а провайдер, который
вам выдает ip. Пока с днс все. Позже мы вернемся к этому вопросу, когда будем
добавлять dkim и spf записи. Но обо всем по порядку.
-----------------------------------------------------------------------------
Подготовим систему centos к установке и настройке почтового сервера postfix.
Если у вас еще нет готовой системы, то рекомендую воспользоваться моими
статьями по установке и настройке centos. Отдельно потратьте время на настройку
iptables. Я не буду касаться этого вопроса в данной статье, чтобы не раздувать
ее второстепенными вещами. Удобнее, когда все по отдельности рассказано и
описано с должной глубиной. Сваливать все в одну кучу не хочется.

По вступлению вроде все, основное рассказал. Приступим к настройке нашего
почтового сервера.
Сразу хочу сделать предупреждение. Настройка почтового сервера достаточно
трудоемкий процесс, требует определенных навыков, знаний и понимания принципов
работы используемых средств. Я не ставлю для себя цель расписать максимально
подробно так, чтобы было понятно даже неподготовленному администратору linux.
Вы должны быть так или иначе подготовлены, либо запаситесь терпением и
разбирайтесь внимательно сами в нюансах. Эта статья на полный копипаст не
подходит, что-то остается за кадром для самостоятельного выполнения. Иначе
нельзя, получится очень большой и громоздкий материал.
Установка postfixadmin
-----------------------------------------------------------------------------
Начнем с установки и настройки панели управления почтовым сервером postfix — postfixadmin.
Без него начинать что-то делать неудобно, так как управлять пользователями,
ящиками, алиасами будет нечем. По своей сути postfixadmin — набор php скриптов
для управления записями в mysql базе данных, которую использует сервер postfix
во время своей работы. Соответственно, для работы postfixadmin нам нужен web
сервер. Подробно о настройке web сервера на centos читайте отдельно. Сейчас же
мы быстро установим все необходимое. Привожу только команды, без комментариев.
-----------------------------------------------------------------------------
Все подробности по приведенной выше ссылке.

# yum install httpd php phpmyadmin mariadb mariadb-server php-imap
-----------------------------------------------------------------------------
Этих пакетов со всеми зависимостями будет достаточно для установки всех
необходимых компонентов веб сервера. Я специально ставлю phpmyadmin, с ним
удобно работать с базой. В нашем случае все пользователи будут храниться в
mysql, иногда может понадобиться туда заглянуть. Подробнее с установкой и
настройкой phpmyadmin можете ознакомиться отдельно.
-----------------------------------------------------------------------------
Запускаем httpd и mariadb и добавляем их в автозагрузку.

# systemctl start httpd
# systemctl enable httpd
# systemctl start mariadb
# systemctl enable mariadb
-----------------------------------------------------------------------------
Задаем пароль root для mysql.

# /usr/bin/mysql_secure_installation
-----------------------------------------------------------------------------
Проверяем работу web сервера. Заходим по ip адресу сервера — http://188.35.19.125/,
а также проверяем работу phpmyadmin — http://188.35.19.125/phpmyadmin/. Его
нужно настроить, об этом рассказано в статье, которую я привел чуть выше.
По-умолчанию в phpmyadmin доступ закрыт. Если все сделали правильно, то увидите
примерно следующее.
-----------------------------------------------------------------------------
Вход в phpmyadmin
-----------------------------------------------------------------------------
Сразу создадим тут пользователя postfix и одноименную базу данных. Запомните
учетные данные, они нам далее понадобятся.
-----------------------------------------------------------------------------
Веб сервер готов, продолжаем настройку почтового сервера. Скачиваем последнюю
версию postfixadmin.
-----------------------------------------------------------------------------
# cd /usr/src
# wget https://downloads.sourceforge.net/project/postfixadmin/postfixadmin/postfixadmin-3.0.2/postfixadmin-3.0.2.tar.gz

Скорее всего во время вашей установки версия postfixadmin изменится и ссылка
может быть неактуальной. Но даже если она будет актуальна, возможно выйдет более
новая версия. Проверьте ее по ссылке https://sourceforge.net/projects/postfixadmin/
и скачайте самую свежую версию.
-----------------------------------------------------------------------------
Распаковываем архив и копируем в директорию веб сервера.

# tar -xvzf postfixadmin-*
# mv /usr/src/postfixadmin-3.0.2 /var/www/html/postfixadmin
-----------------------------------------------------------------------------
Назначаем владельцем пользователя веб сервера:

# chown -R apache. /var/www/html/postfixadmin/
-----------------------------------------------------------------------------
Дальше редактируем конфигурационный файл postfixadmin.

# mcedit /var/www/html/postfixadmin/config.inc.php

Приводим параметры к следующему виду:

$CONF['configured'] = true;
$CONF['default_language'] = 'ru';
$CONF['database_type'] = 'mysqli';
$CONF['database_host'] = 'localhost';
$CONF['database_user'] = 'postfix';
$CONF['database_password'] = '12345678';
$CONF['database_name'] = 'postfix';
$CONF['admin_email'] = 'root@zeroxzed.ru';
$CONF['encrypt'] = 'md5crypt';
$CONF['default_aliases'] = array (
 'abuse' => 'root',
 'hostmaster' => 'root',
 'postmaster' => 'root',
 'webmaster' => 'root'
);
$CONF['domain_path'] = 'YES';
$CONF['domain_in_mailbox'] = 'YES';
-----------------------------------------------------------------------------
Обращаю внимание на выделенный параметр. Он указывает на то, в каком виде хранить
пароли пользователей в базе данных. Конечно, хранить обычным текстом без шифрования
это дурной тон и может быть опасно. Я указал хранение в шифрованном виде. Но если
мы говорим о небольшой компании без публичного доступа к серверу, можно использовать
нешифрованные пароли. Для этого указываем значение параметра cleartext. Я сам так
часто делаю просто из соображений удобства. Объясню, в чем удобство.

К примеру, у пользователя несколько устройств подключены к почте и он забыл свой
пароль. Админ при создании почему-то тоже его никуда не записал, или забыл, или
потерял. Вам придется сбросить пароль и перенастроить все устройства. Если же у
вас пароль хранится в открытом виде, вы просто смотрите в базу и говорите пользователю 
пароль. Пароли в открытом виде удобно просто выгрузить дампом из базы, если
понадобится кому-то все учетки передать. Но тут как посмотреть 🙂 С одной стороны
плюс, с другой минус — кто-то очень просто может спереть все ваши пароли. В общем,
тут от ситуации зависит, решайте сами, как вам удобнее хранить пароли.

У меня распространены ситуации, когда я удаленно администрирую сервера, а на месте
эникеи работают с пользователями. Чаще всего это не очень аккуратные и
ответственные люди, иначе они бы работали с серверами 🙂 Они часто забывают записать
пароль, путают что-то и т.д. В итоге, когда один человек увольняется и приходит
другой, оказывается, что найти пароли на некоторые ящики просто невозможно. Тут
очень выручает возможность посмотреть пароль в базе. Я новому админу либо пароль
говорю, либо весь дамп сразу отдаю, пусть работает.

Если вы сами работаете с сервером и все аккуратно ведете, записываете, например,
в keepass все пароли от почтовых ящиков, то смело шифруйте все пароли, так будет
спокойнее.

Последние 2 параметра domain_path и domain_in_mailbox указывайте по своему
усмотрению. В файле конфигурации в комментариях расписано, за что они отвечают 
и в чем отличие. Мне кажется, удобно хранить директории именно в таком виде, как
я указал. Получится следующий путь до ящика, если у вас архив почты будет жить,
к примеру, в директории /mnt/mail — /mnt/mail/zeroxzed.ru/root@zeroxzed.ru.

С параметрами разобрались. Сохраняем конфиг. Идем по адресу
http://188.35.19.125/postfixadmin/setup.php и начинаем установку postfixadmin.
 Первым делом идет проверка всех необходимых для установки и работы компонентов.
Для продолжения установки у вас должна быть такая картинка.
-----------------------------------------------------------------------------
Установка postfixadmin

Если чего-то не хватает, разбирайтесь по месту. Если делаете по моей инструкции,
то все должно быть в порядке. Указывайте пароль установки и продолжайте. Вы должны
получить строку с хэшем этого пароля.
-----------------------------------------------------------------------------
Добавление пароля установки
-----------------------------------------------------------------------------
Добавляем полученную строку в файл конфигурации postfixadmin.

# mcedit /var/www/html/postfixadmin/config.inc.php

$CONF['setup_password'] = '67e46bdcc7aeb431f7af9a6d02f43352:30672e5a9deacaf505d32807b967caf9fd0c32ef';

Используя этот пароль, можно создать учетную запись администратора панели управления.
Делаем это, учитывая, что пароль должен содержать не менее двух цифр. Если все
сделали правильно, то увидите сообщение.
-----------------------------------------------------------------------------
Добавление администратора postfixadmin

Переходим по ссылке и авторизуемся с помощью учетной записи администратора,
которую только что сделали. Вы должны увидеть основную страницу интерфейса postfixadmin.
-----------------------------------------------------------------------------
Главная страница postfixadmin

Теперь нам нужно добавить домен в панель управления. Идем в раздел Список
доменов -> Новый домен и добавляем свой домен.
-----------------------------------------------------------------------------
Создание нового домена

При создании домена были добавлены стандартные алиасы, получателя для которых
мы указали еще в конфиге — ящик root@zeroxzed.ru. Создание таких алиасов требование
стандартов, но по факту, кроме спама, вы скорее всего ничего не будете получать
по этим адресам. Так что их создание оставляйте на свое усмотрения. Я обычно их
не делаю, так как ящик для этих алиасов все равно не читаю.

Далее создадим почтовый ящик администратора — root@zeroxzed.ru. Для этого идем в
раздел Обзор -> Создать ящик и заполняем поля.
-----------------------------------------------------------------------------
Добавление почтового ящика

Непосредственно ящик на диске создан не будет, так как у нас еще не настроена
почтовая система, но запись в базе данных появится. Это можно проверить через
phpmyadmin.
-----------------------------------------------------------------------------
Проверка нового ящика в mysql базе

Как мы видим, пароль указан в зашифрованном виде. На этом установку и настройку
postfixadmin завершаем. Интерфейс для управления почтовым сервером мы подготовили. 
Теперь можно заняться непосредственно настройкой postfix.
Настройка postfix
-----------------------------------------------------------------------------
Сердце нашего почтового сервера на linux — postfix. В дистрибутиве centos он
уже установлен, можно сразу переходить к настройке. Рисуем следующий конфиг.

# mcedit /etc/postfix/main.cf

soft_bounce = no
queue_directory = /var/spool/postfix
command_directory = /usr/sbin
daemon_directory = /usr/libexec/postfix
data_directory = /var/lib/postfix
mail_owner = postfix

myhostname = mail.zeroxzed.ru
mydomain = zeroxzed.ru
myorigin = $myhostname

inet_interfaces = all
inet_protocols = ipv4

mydestination = localhost.$mydomain, localhost
unknown_local_recipient_reject_code = 550
mynetworks = 127.0.0.0/8

alias_maps = hash:/etc/aliases
alias_database = hash:/etc/aliases

smtpd_banner = $myhostname ESMTP $mail_name

debug_peer_level = 2
# Строки с PATH и ddd должны быть с отступом в виде табуляции от начала строки
debugger_command =
         PATH=/bin:/usr/bin:/usr/local/bin:/usr/X11R6/bin
         ddd $daemon_directory/$process_name $process_id & sleep 5

sendmail_path = /usr/sbin/sendmail.postfix
newaliases_path = /usr/bin/newaliases.postfix
mailq_path = /usr/bin/mailq.postfix
setgid_group = postdrop
html_directory = no
manpage_directory = /usr/share/man
sample_directory = /usr/share/doc/postfix-2.10.1/samples
readme_directory = /usr/share/doc/postfix-2.10.1/README_FILES

relay_domains = mysql:/etc/postfix/mysql/relay_domains.cf
virtual_alias_maps = mysql:/etc/postfix/mysql/virtual_alias_maps.cf,
 mysql:/etc/postfix/mysql/virtual_alias_domain_maps.cf
virtual_mailbox_domains = mysql:/etc/postfix/mysql/virtual_mailbox_domains.cf
virtual_mailbox_maps = mysql:/etc/postfix/mysql/virtual_mailbox_maps.cf

smtpd_discard_ehlo_keywords = etrn, silent-discard
smtpd_forbidden_commands = CONNECT GET POST
broken_sasl_auth_clients = yes
smtpd_delay_reject = yes
smtpd_helo_required = yes
smtp_always_send_ehlo = yes
disable_vrfy_command = yes

smtpd_helo_restrictions = permit_mynetworks,
 permit_sasl_authenticated,
 reject_non_fqdn_helo_hostname,
 reject_invalid_helo_hostname

smtpd_data_restrictions = permit_mynetworks,
 permit_sasl_authenticated,
 reject_unauth_pipelining,
 reject_multi_recipient_bounce,

smtpd_sender_restrictions = permit_mynetworks,
 permit_sasl_authenticated,
 reject_non_fqdn_sender,
 reject_unknown_sender_domain

smtpd_recipient_restrictions = reject_non_fqdn_recipient,
 reject_unknown_recipient_domain,
 reject_multi_recipient_bounce,
 permit_mynetworks,
 permit_sasl_authenticated,
 reject_unauth_destination,

smtp_tls_security_level = may
smtpd_tls_security_level = may
smtpd_tls_loglevel = 1
smtpd_tls_received_header = yes
smtpd_tls_session_cache_timeout = 3600s
smtp_tls_session_cache_database = btree:$data_directory/smtp_tls_session_cache
smtpd_tls_key_file = /etc/postfix/certs/key.pem
smtpd_tls_cert_file = /etc/postfix/certs/cert.pem
tls_random_source = dev:/dev/urandom

# Ограничение максимального размера письма в байтах
message_size_limit = 20000000
smtpd_soft_error_limit = 10
smtpd_hard_error_limit = 15
smtpd_error_sleep_time = 20
anvil_rate_time_unit = 60s
smtpd_client_connection_count_limit = 20
smtpd_client_connection_rate_limit = 30
smtpd_client_message_rate_limit = 30
smtpd_client_event_limit_exceptions = 127.0.0.0/8
smtpd_client_connection_limit_exceptions = 127.0.0.0/8

maximal_queue_lifetime = 1d
bounce_queue_lifetime = 1d

smtpd_sasl_auth_enable = yes
smtpd_sasl_security_options = noanonymous
smtpd_sasl_type = dovecot
smtpd_sasl_path = private/dovecot-auth

# Директория для хранения почты
virtual_mailbox_base = /mnt/mail
virtual_minimum_uid = 1000
virtual_uid_maps = static:1000
virtual_gid_maps = static:1000
virtual_transport = dovecot
dovecot_destination_recipient_limit = 1

sender_bcc_maps = hash:/etc/postfix/sender_bcc_maps
recipient_bcc_maps = hash:/etc/postfix/recipient_bcc_maps

Я выделил жирным имя домена и путь для директории с почтовыми ящиками.
Не забудьте поменять эти параметры на свои. Сохраняем конфиг и
продолжаем настройку. В таком виде сервер еще не готов. Нужно теперь
создать все то, что описано в файле конфигурации. Создаем папку для файло
с конфигурацией подключения к mysql и сами файлы подключения.

# mkdir /etc/postfix/mysql && cd /etc/postfix/mysql
-----------------------------------------------------------------------------
# mcedit relay_domains.cf

hosts = localhost
user = postfix
password = 12345678
dbname = postfix
query = SELECT domain FROM domain WHERE domain='%s' and backupmx = '1'
-----------------------------------------------------------------------------
# mcedit  virtual_alias_domain_maps.cf

hosts = localhost
user = postfix
password = 12345678
dbname = postfix
query = SELECT goto FROM alias,alias_domain WHERE alias_domain.alias_domain = '%d' and alias.address = CONCAT('%u', '@', alias_domain.target_domain) AND alias.active = 1
-----------------------------------------------------------------------------
# mcedit virtual_alias_maps.cf

hosts = localhost
user = postfix
password = 12345678
dbname = postfix
query = SELECT goto FROM alias WHERE address='%s' AND active = '1'
-----------------------------------------------------------------------------
# mcedit virtual_mailbox_domains.cf

hosts = localhost
user = postfix
password = 12345678
dbname = postfix
query = SELECT domain FROM domain WHERE domain='%s' AND backupmx = '0' AND active = '1'
-----------------------------------------------------------------------------
# mcedit virtual_mailbox_maps.cf

hosts = localhost
user = postfix
password = 12345678
dbname = postfix
query = SELECT maildir FROM mailbox WHERE username='%s' AND active = '1'
-----------------------------------------------------------------------------
Редактируем файл /etc/postfix/master.cf. Нам надо добавить строки, касающиеся
настройки Submission для того, чтобы почтовый сервер работал на 587 порту. Смартфоны
очень часто при настройке используют этот порт по-умолчанию, где-то даже без
возможности изменить эту настройку. Приводим секцию, отвечающую за эту работу
к следующему виду.

submission inet n - n - - smtpd
 -o syslog_name=postfix/submission
 -o smtpd_tls_wrappermode=no
 -o smtpd_tls_security_level=encrypt
 -o smtpd_sasl_auth_enable=yes
 -o smtpd_recipient_restrictions=permit_mynetworks,permit_sasl_authenticated,reject
 -o smtpd_relay_restrictions=permit_mynetworks,permit_sasl_authenticated,defer_unauth_destination
 -o milter_macro_daemon_name=ORIGINATING

Обращаю внимание на пробел в начале строки, начиная со второй. Его надо обязательно оставить.
Добавляем еще настройки для того, чтобы наш сервер поддерживал протокол SSL/TLS и слушал порт 465

smtps inet n - n - - smtpd
 -o syslog_name=postfix/smtps
 -o smtpd_tls_wrappermode=yes
 -o smtpd_sasl_auth_enable=yes
 -o smtpd_recipient_restrictions=permit_mynetworks,permit_sasl_authenticated,reject
 -o smtpd_relay_restrictions=permit_mynetworks,permit_sasl_authenticated,defer_unauth_destination
 -o milter_macro_daemon_name=ORIGINATING
-----------------------------------------------------------------------------
В этот же файл добавляем еще одну настройку, которая будет указывать postfix, что доставкой
почты у нас будет заниматься dovecot, который мы настроим следом. Добавляем в master.cf в
самый конец.

dovecot unix - n n - - pipe
 flags=DRhu user=vmail:vmail argv=/usr/libexec/dovecot/deliver -f ${sender} -d ${recipient}
-----------------------------------------------------------------------------
Сгенерируем самоподписанные ssl сертификаты для нашего почтового сервера.
Позже отдельным пунктом я расскажу как использовать полноценные сертификаты.
Они не всем нужны, поэтому показываю быструю настройку postfix на использование
своих сертификатов, которые уже указаны в конфиге postfix.
-----------------------------------------------------------------------------
Создаем директорию и сами сертификаты:

# mkdir /etc/postfix/certs
# openssl req -new -x509 -days 3650 -nodes -out /etc/postfix/certs/cert.pem -keyout /etc/postfix/certs/key.pem
-----------------------------------------------------------------------------
Для генерации вам зададут несколько вопросов по поводу данных о сертификате.
В принципе, можете там писать все, что угодно. Вот мои данные.

Создание ssl сертификата для postfix
-----------------------------------------------------------------------------
Создадим файлы для информации о ящиках, куда будет собираться вся входящая и исходящая почта.

# mcedit /etc/postfix/recipient_bcc_maps

@zeroxzed.ru all_in@zeroxzed.ru
-----------------------------------------------------------------------------
# mcedit /etc/postfix/sender_bcc_maps

@zeroxzed.ru all_out@zeroxzed.ru
-----------------------------------------------------------------------------
Создаем индексированные базы данных из этих файлов. Это нужно делать каждый раз,
после изменения.

# postmap /etc/postfix/recipient_bcc_maps /etc/postfix/sender_bcc_maps
-----------------------------------------------------------------------------
Теперь создайте два почтовых ящика all_in@zeroxzed.ru и all_out@zeroxzed.ru
через postfixadmin.
-----------------------------------------------------------------------------
Немного поясню по этим ящикам — для чего они нужны. Изначально я их делал,
когда пользователи использовали протокол pop3 без сохранения писем на сервере.
Это позволяло организовать бэкап всей переписки. Эти ящики очень быстро заполняются
и занимают огромный объем, поэтому их обязательно надо чистить. Я просто
скриптами регулярно собирал всю почту в архивы с именами в виде дат. Если
нужно было какое-то письмо найти, то просто распаковывал нужный архив.
-----------------------------------------------------------------------------
В случае с imap роль бэкапа отпадает, так как вся почта хранится на сервере.
Но эти ящики все равно бывают полезны, когда пользователь, к примеру, удалил
какое-то важное письмо и потом делает вид, что его и не было. Если это письмо
пришло только сегодня и еще не успело улететь в бэкап, то кроме записи в логах
об этом письме, вы не увидите само содержимое. А с такими ящиками все сразу
будет понятно, и вопросы отпадут. Последнее применение — служба безопасности.
Если у вас есть кто-то, кому положено читать всю переписку, то реализовать этот
функционал можно таким простым способом.
-----------------------------------------------------------------------------
Все основные настройки для postfix мы сделали. Некоторые из них завязаны на
работу с dovecot, который мы еще не настроили. Поэтому больше postfix не трогаем,
не перезапускаем. Идем настраивать dovecot — imap сервер нашей почтовой системы.
-----------------------------------------------------------------------------
Настройка dovecot
-----------------------------------------------------------------------------
Займемся настройкой dovecot — сервер доставки почты пользователю по протоколам
pop3 и imap. Я не вижу причин использовать pop3. Он неудобен по сравнению с imap.
Чаще всего pop3 отключаю вовсе. Но это уже на ваше усмотрение. Приведу пример с
настройкой обоих протоколов. Помимо основного функционала по доставке почты, я
настрою несколько полезных плагинов. Расскажу о них поподробнее:
-----------------------------------------------------------------------------
    Sieve — выполняет фильтрацию почты по заданным правилам в момент локальной
доставки на почтовом сервере. Удобство такого подхода в том, что вы один раз
можете настроить правило сортировки, и оно будет работать во всех клиентах,
которыми вы будете получать почту по imap. Правила создаются, хранятся и
исполняются на самом сервере.
    Acl — позволяет пользователям расшаривать папки в своем почтовом ящике
и предоставлять доступ к этим папкам другим пользователям. Не часто видел,
чтобы этот функционал настраивали и использовали. Думаю, просто по незнанию.
По мне так очень удобный и полезный функционал.
-----------------------------------------------------------------------------
Часто вижу, что люди настраивают плагин quota, который позволяет ограничивать
максимальный размер почтового ящика. Я лично в своей работе его не использую.
Возможно, когда у тебя клиентов сотни и тысячи это имеет значение и надо
обязательно настроить ограничение. Когда же ящиков меньше, нет смысла напрягать
людей постоянной чисткой. Сейчас диски стоят не так дорого. Мне кажется, проще
и дешевле увеличить место на сервере, нежели постоянно беспокоить пользователей
необходимостью чистки ящика. Лучше ограничить максимальный размер письма,
скажем 20-ю мегабайтами. Тогда сильно забить ящик даже при большом желании
быстро не получится. А почта все-таки важный инструмент в работе. Мне кажется,
ее лучше хранить как можно дольше.

Есть еще один полезный плагин expire, который позволяет удалять устаревшие письма
в определенных папках. Например, удалять все письма старше 30-ти дней в корзине и
папке со спамом. Но реально пользоваться им не получается по простой причине.
Разные почтовые клиенты создают различные папки для корзины и спама. Thunderbird
создает папки с латинскими именами trash и spam, outlook с русскими, которые на
почтовом сервере преобразуются в кодировку UTF7, мобильные клиенты тоже используют
разные имена папок. В итоге нет единообразия, плагин полноценно не работает.

Я рассказал об этих плагинах для наводки. Сам их не настраиваю, но если вам
захочется реализовать описанный функционал, можете сами разобраться и настроить.
-----------------------------------------------------------------------------
Небольшую теорию я дал, теперь переходим к практике. Устанавливаем необходимые
для dovecot пакеты.

# yum install dovecot dovecot-mysql dovecot-pigeonhole
-----------------------------------------------------------------------------
Изначально конфиг dovecot разбит на отдельные сегменты и лежат в директории
/etc/dovecot/conf.d. Каждый файл — отдельный функционал. Мне не нравится прыгать
по файлам, поэтому я храню все в едином общем файле конфигурации
/etc/dovecot/dovecot.conf. С ним мы и будем работать. Приводим его к следующему виду.
-----------------------------------------------------------------------------
# mcedit /etc/dovecot/dovecot.conf

listen = * [::]

mail_plugins = mailbox_alias acl

protocols = imap pop3 sieve lmtp

mail_uid = 1000
mail_gid = 1000

first_valid_uid = 1000
last_valid_uid = 1000

log_path = /var/log/dovecot/main.log
info_log_path = /var/log/dovecot/info.log
debug_log_path = /var/log/dovecot/debug.log

ssl_protocols = !SSLv2 !SSLv3
ssl = required
verbose_ssl = no
ssl_cert = </etc/postfix/certs/cert.pem
ssl_key = </etc/postfix/certs/key.pem

ssl_cipher_list = ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:ECDHE-RSA-DES-CBC3-SHA:ECDHE-ECDSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA
ssl_dh_parameters_length = 2048
ssl_prefer_server_ciphers = yes

disable_plaintext_auth = yes

mail_location = maildir:/mnt/mail/%d/%u/

auth_default_realm = zeroxzed.ru

auth_mechanisms = PLAIN LOGIN

service auth {
 unix_listener /var/spool/postfix/private/dovecot-auth {
 user = postfix
 group = postfix
 mode = 0666
 }
unix_listener auth-master {
 user = vmail
 group = vmail
 mode = 0666
 }

unix_listener auth-userdb {
 user = vmail
 group = vmail
 mode = 0660
 }
}

service lmtp {
 unix_listener /var/spool/postfix/private/dovecot-lmtp {
 user = postfix
 group = postfix
 mode = 0600
 }

 inet_listener lmtp {
 address = 127.0.0.1
 port = 24
 }
}

userdb {
 args = /etc/dovecot/dovecot-mysql.conf
 driver = sql
 }

passdb {
 args = /etc/dovecot/dovecot-mysql.conf
 driver = sql
 }

auth_master_user_separator = *
 
plugin {
 auth_socket_path = /var/run/dovecot/auth-master

 acl = vfile
 acl_shared_dict = file:/mnt/mail/shared-folders/shared-mailboxes.db
 sieve = /mnt/mail/sieve/%u.sieve
 mailbox_alias_old = Sent
 mailbox_alias_new = Sent Messages
 mailbox_alias_old2 = Sent
 mailbox_alias_new2 = Sent Items
}

protocol lda {
 mail_plugins = $mail_plugins sieve
 auth_socket_path = /var/run/dovecot/auth-master
 deliver_log_format = mail from %f: msgid=%m %$
 log_path = /var/log/dovecot/lda-errors.log
 info_log_path = /var/log/dovecot/lda-deliver.log
 lda_mailbox_autocreate = yes
 lda_mailbox_autosubscribe = yes
 postmaster_address = root
}

protocol lmtp {
 info_log_path = /var/log/dovecot/lmtp.log
 mail_plugins = quota sieve
 postmaster_address = postmaster
 lmtp_save_to_detail_mailbox = yes
 recipient_delimiter = +
}

protocol imap {
 mail_plugins = $mail_plugins imap_acl
 imap_client_workarounds = tb-extra-mailbox-sep
 mail_max_userip_connections = 30
}

protocol pop3 {
 mail_plugins = $mail_plugins
 pop3_client_workarounds = outlook-no-nuls oe-ns-eoh
 pop3_uidl_format = %08Xu%08Xv
 mail_max_userip_connections = 30
}

service imap-login {
 service_count = 1
 process_limit = 500
 }

service pop3-login {
 service_count = 1
 }

service managesieve-login {
 inet_listener sieve {
 port = 4190
 }
}

namespace {
 type = private
 separator = /
 prefix =
 inbox = yes

 mailbox Sent {
 auto = subscribe
 special_use = \Sent
 }
 mailbox "Sent Messages" {
 auto = no
 special_use = \Sent
 }
 mailbox "Sent Items" {
 auto = no
 special_use = \Sent
 }
 mailbox Drafts {
 auto = subscribe
 special_use = \Drafts
 }
 mailbox Trash {
 auto = subscribe
 special_use = \Trash
 }
 mailbox "Deleted Messages" {
 auto = no
 special_use = \Trash
 }
 mailbox Junk {
 auto = subscribe
 special_use = \Junk
 }
 mailbox Spam {
 auto = no
 special_use = \Junk
 }
 mailbox "Junk E-mail" {
 auto = no
 special_use = \Junk
 }
 mailbox Archive {
 auto = no
 special_use = \Archive
 }
 mailbox Archives {
 auto = no
 special_use = \Archive
 }
}

namespace {
 type = shared
 separator = /
 prefix = Shared/%%u/
 location = maildir:%%h:INDEX=%h/shared/%%u
 subscriptions = yes
 list = children
}
-----------------------------------------------------------------------------
Создаем группу и пользователя с указанными в конфиге uid 1000.

# groupadd  -g 1000 vmail
# useradd -d /mnt/mail/ -g 1000 -u 1000 vmail
# chown vmail. /mnt/mail
-----------------------------------------------------------------------------
Создаем конфигурационные файлы для доступа к mysql базе.

# mcedit /etc/dovecot/dovecot-mysql.conf

driver = mysql
default_pass_scheme = CRYPT
connect = host=127.0.0.1 dbname=postfix user=postfix password=12345678
user_query = SELECT '/mnt/mail/%d/%u' as home, 'maildir:/mnt/mail/%d/%u' as mail, 1000 AS uid, 1000 AS gid, concat('*:bytes=', quota) AS quota_rule FROM mailbox WHERE username = '%u' AND active = '1'
password_query = SELECT username as user, password, '/mnt/mail/%d/%u' as userdb_home, 'maildir:/mnt/mail/%d/%u' as userdb_mail, 1000 as userdb_uid, 1000 as userdb_gid, concat('*:bytes=', quota) AS userdb_quota_rule FROM mailbox WHERE username = '%u' AND active = '1'
-----------------------------------------------------------------------------
Создадим директорию и файлы для логов.

# mkdir /var/log/dovecot
# cd /var/log/dovecot && touch main.log info.log debug.log lda-errors.log lda-deliver.log lmtp.log
# chown -R vmail:dovecot /var/log/dovecot
-----------------------------------------------------------------------------
Создаем пару служебных папок для плагинов sieve и acl.

# mkdir /mnt/mail/sieve && mkdir /mnt/mail/shared-folders
# chown -R vmail. /mnt/mail
-----------------------------------------------------------------------------
И небольшой штрих в завершении настройки.

# chown vmail. /var/run/dovecot/auth-master

Уже не помню, зачем это было нужно, запись осталась в черновиках. Знаю только,
что какая-то ошибка всплывала без этого.

На этом основная настройка почтового сервера на базе postfix и dovecot завершена.
 Можно перезапускать службы и проверять работу системы.

# systemctl restart postfix
# systemctl start dovecot
# systemctl enable dovecot
-----------------------------------------------------------------------------
Проверка работы почтового сервера

Самаый простой и быстрый способ проверить работу почтового сервера — отправить на
него письмо. Я буду отправлять со своего почтового адреса zeroxzed@gmail.com на
адрес root@zeroxzed.ru. Вот что должно быть в логе, если у вас все правильно
настроено и почтовый сервер нормально работает.
-----------------------------------------------------------------------------
# cat /var/log/maillog
-----------------------------------------------------------------------------
Mar 10 21:56:27 mail postfix/smtpd[28075]: connect from mail-yw0-f172.google.com[209.85.161.172]
Mar 10 21:56:28 mail postfix/smtpd[28075]: Anonymous TLS connection established from mail-yw0-f172.google.com[209.85.161.172]: TLSv1.2 with cipher ECDHE-RSA-AES128-GCM-SHA256 (128/128 bits)
Mar 10 21:56:28 mail postfix/smtpd[28075]: D4263420BB7B: client=mail-yw0-f172.google.com[209.85.161.172]
Mar 10 21:56:29 mail postfix/cleanup[28086]: D4263420BB7B: message-id=<CAHWPLcOeqf6uNHRg34+wuppDUGPDLY=fp8s-E=o9fmxYMS48cQ@mail.gmail.com>
Mar 10 21:56:29 mail postfix/qmgr[28042]: D4263420BB7B: from=<zeroxzed@gmail.com>, size=2533, nrcpt=2 (queue active)
Mar 10 21:56:29 mail postfix/pipe[28089]: D4263420BB7B: to=<all_in@zeroxzed.ru>, relay=dovecot, delay=0.39, delays=0.33/0.02/0/0.05, dsn=2.0.0, status=sent (delivered via dovecot service)
Mar 10 21:56:29 mail postfix/pipe[28090]: D4263420BB7B: to=<root@zeroxzed.ru>, relay=dovecot, delay=0.4, delays=0.33/0.03/0/0.04, dsn=2.0.0, status=sent (delivered via dovecot service)
Mar 10 21:56:29 mail postfix/qmgr[28042]: D4263420BB7B: removed
Mar 10 21:56:29 mail postfix/smtpd[28075]: disconnect from mail-yw0-f172.google.com[209.85.161.172]
-----------------------------------------------------------------------------
Пояснять тут нечего, по логу все понятно. Письмо было доставлено в указанный ящик
и в общий ящик для сбора всей входящей почты. В директории /mnt/mail была создана
директория с именем домена zeroxzed.ru, а в ней созданы 3 папки с именами ящиков:
-----------------------------------------------------------------------------
    all_in@zeroxzed.ru
    all_out@zeroxzed.ru
    root@zeroxzed.ru

Директории с почтовыми ящиками создаются в момент получения первого письма в ящик.
Непрочитанное письмо помещается в директорию /new в почтовом ящике. После
прочтения переносится в /cur.
-----------------------------------------------------------------------------
Попробуем теперь подключиться к почтовому ящику по imap, прочитать письмо и
отправить ответ. Настроим любой почтовый клиент для проверки работы настроенного
почтового сервера. Я для этих целей буду использовать Thunderbird. Из всех почтовых
клиентов мне он нравится больше всего. В основном из-за его портированной версии.
Указываем следующие настройки.
-----------------------------------------------------------------------------
Настройка подключения к почтовому серверу

Так как мы используем самоподписанный сертификат ssl, почтовый клиент предупредит
нас о том, что серверу нельзя доверять.

Добавление ssl сертификата в исключения

Нас это не пугает, добавляем сертификат в список доверенных и продолжаем работать.
Позже получим и настроим нормальный сертификат.

Я подключился к почтовому ящику и увидел тестовые письма. Отвечу на одно из них
и посмотрю в логе, как прошла отправка. У меня еще раз выскочило окно с 
предупреждением о небезопасном сертификате. Еще раз добавляю его в исключения.
Это нормально, сертификат проверяется во время получения почты в dovecot, а во
время отправки в postfix. Так что нужны 2 подтверждения. Отправляю письмо еще
раз и смотрю лог.
-----------------------------------------------------------------------------
# cat /var/log/maillog

Mar 10 22:10:12 mail postfix/smtpd[28764]: connect from broadband-75-37-235-139.moscow.gw.ru[75.37.235.139]
Mar 10 22:10:12 mail postfix/smtpd[28764]: Anonymous TLS connection established from broadband-75-37-235-139.moscow.gw.ru[75.37.235.139]: TLSv1.2 with cipher ECDHE-RSA-AES128-GCM-SHA256 (128/128 bits)
Mar 10 22:10:12 mail postfix/smtpd[28764]: B24C2420BB70: client=broadband-75-37-235-139.moscow.gw.ru[75.37.235.139], sasl_method=PLAIN, sasl_username=root@zeroxzed.ru
Mar 10 22:10:12 mail postfix/cleanup[28779]: B24C2420BB70: message-id=<aaac96c3-197e-c6bd-4dfe-85d09bce216a@zeroxzed.ru>
Mar 10 22:10:12 mail postfix/qmgr[28042]: B24C2420BB70: from=<root@zeroxzed.ru>, size=955, nrcpt=2 (queue active)
Mar 10 22:10:12 mail postfix/smtpd[28764]: disconnect from broadband-75-37-235-139.moscow.gw.ru[75.37.235.139]
Mar 10 22:10:12 mail postfix/pipe[28784]: B24C2420BB70: to=<all_out@zeroxzed.ru>, relay=dovecot, delay=0.14, delays=0.07/0.01/0/0.06, dsn=2.0.0, status=sent (delivered via dovecot service)
Mar 10 22:10:13 mail postfix/smtp[28783]: B24C2420BB70: to=<zeroxzed@gmail.com>, relay=gmail-smtp-in.l.google.com[64.233.163.26]:25, delay=0.62, delays=0.07/0.01/0.28/0.26, dsn=2.0.0, status=sent (250 2.0.0 OK 1489173013 13si2106703ljv.3 - gsmtp)
Mar 10 22:10:13 mail postfix/qmgr[28042]: B24C2420BB70: removed
-----------------------------------------------------------------------------
Все в порядке. Видно подключение с моего ip, успешную sasl авторизацию,
формирование письма на сервере, присваивание ему message-id, отправка копии
письма в ящик для сбора исходящей почты и отправка оригинала в ящик получателя.
Все этапы прошли без ошибок.
-----------------------------------------------------------------------------
Расскажу, куда еще надо смотреть для отладки почтовой системы.
Да и не только отладки, во время работы периодически придется разбираться,
куда ушло то или иное письмо, кто и когда подключался к ящику. Разные ситуации
бывают. В файле /var/log/dovecot/lda-deliver.log содержится информация обо всех
пришедших письмах — когда, от кого и в какой ящик было положено.
-----------------------------------------------------------------------------
Mar 10 22:25:29 lda(all_in@zeroxzed.ru): Info: mail from zeroxzed@gmail.com: msgid=<CAHWPLcNG=WMOoWW2Y_Lw4qn9+V4TOrbxZpwtA=O+CSEBaiwuBg@mail.gmail.com> saved mail to INBOX
Mar 10 22:25:29 lda(root@zeroxzed.ru): Info: mail from zeroxzed@gmail.com: msgid=<CAHWPLcNG=WMOoWW2Y_Lw4qn9+V4TOrbxZpwtA=O+CSEBaiwuBg@mail.gmail.com> saved mail to INBOX
Mar 10 22:25:49 lda(all_out@zeroxzed.ru): Info: mail from root@zeroxzed.ru: msgid=<75358e4d-7c8e-24c2-a21f-7ee0df2a4704@zeroxzed.ru> saved mail to INBOX
-----------------------------------------------------------------------------
В /var/log/dovecot/info.log информация о подключениях к почтовым ящикам — кто,
когда, откуда и каким способом авторизовывался на сервере.

Mar 10 22:10:20 imap-login: Info: Login: user=<root@zeroxzed.ru>, method=PLAIN, rip=75.37.235.139, lip=188.35.19.125, mpid=28790, TLS, session=<3tDeHGVKpQBNJeCL>
Mar 10 22:19:39 imap-login: Info: Login: user=<root@zeroxzed.ru>, method=PLAIN, rip=75.37.235.139, lip=188.35.19.125, mpid=29248, TLS, session=<7VY8PmVKbwBNJeCL>
-----------------------------------------------------------------------------
Остальное уже не так полезно. Сами посмотрите, что собирается в остальных лог файлах.

На текущий момент сервер полностью работоспособен. В таком виде им без проблем
можно пользоваться. Но функционал полностью не раскрыт. Использовать плагины
sieve и acl через удаленные почтовые клиенты неудобно. Проще всего их настроить
через web почту roundcube. Установим эту web панель на наш почтовый сервер.
-----------------------------------------------------------------------------
Установка web интерфейса roundcube
-----------------------------------------------------------------------------
Установим и настроим самый популярный web интерфейс для postfix — roundcube. Скачиваем исходники.

# cd /usr/src
# wget https://github.com/roundcube/roundcubemail/releases/download/1.2.3/roundcubemail-1.2.3-complete.tar.gz
-----------------------------------------------------------------------------
Не забудьте проверить в момент установки, какая версия является самой свежей
на текущий момент. Нет необходимости устанавливать устаревшую версию. Рекомендую
ставить самую последнюю на момент настройки.

# tar -xzvf roundcubemail-*
# mv roundcubemail-1.2.3 /var/www/html/webmail
# chown -R apache. /var/www/html/webmail
-----------------------------------------------------------------------------
Переходим в браузер по следующей ссылке для установки roundcube —
http://188.35.19.125/webmail/installer/. Вы увидите несколько незначительных
замечаний. На них можно не обращать внимание, если установщик позволяет нажать
кнопку NEXT. Единственное, рекомендую установить правильный часовой пояс в 
/etc/php.ini и перезапустить после этого httpd.

На следующем этапе нам надо указать настройки подключения к mysql базе.
Предварительно ее следует создать через phpmyadmin. Я создал пользователя roundcube и такую же базу с полными правами пользователя на нее. Эти параметры указал в настройках.
-----------------------------------------------------------------------------
Установка roundcube
-----------------------------------------------------------------------------
Так же на этой странице нужно будет указать несколько параметров:

    smtp_server — пусто (ничего не пишем)
    language — ru_RU
    Выбираем плагины — managesieve, userinfo, acl. Остальные на свое усмотрение.
-----------------------------------------------------------------------------
Жмем CREATE CONFIG. Должны увидеть сообщение:

The config file was saved successfully into RCMAIL_CONFIG_DIR directory of your
Roundcube installation.
-----------------------------------------------------------------------------
Жмем CONTINUE. Открывается страница с проверкой настроек. Тут проверять неудобно,
можно этого не делать. Зайдем в почтовый ящик и там все проверим. Если что,
конфиг потом все равно можно вручную отредактировать. Папку /var/www/html/webmail/installer
удаляем. Заходим в почтовый ящик через roundcube — http://188.35.19.125/webmail/
Набирать нужно полное имя ящика и пароль. Если все сделали правильно, должны
попасть в свой почтовый ящик.
-----------------------------------------------------------------------------
Вход в почтовый ящик через roundcube
-----------------------------------------------------------------------------
Ну вот и все. Можно пользоваться web интерфейсом для почтового сервера. У меня
есть статья по настройке мобильной версии roundcube. Рекомендую ее настроить,
если есть необходимость. Тема качественная и добротная. Пользоваться удобно.

Дальше рассмотрим настройку и использование плагинов acl и sieve с помощью roundcube.
Настройка фильтра почты sieve

Sieve очень удобная штука, но вот хорошего интерфейса для управления через
почтовый клиент я не знаю. Существует плагин для thunderbird, который так и
называется sieve. Но лично мне он не понравился вообще, так как предлагает
писать правила определенным кодом. Для этого надо знать синтаксис, тратить
время. Можете сами на него посмотреть — https://github.com/thsmi/sieve.

К счастью, есть удобный способ писать правила фильтрации для sieve через
roundcube. Там это реализовано отдельным плагином managesieve, который мы 
активировали во время установки. Для создания правила фильтрации, зайдите
в свой почтовый ящик через roundcube. Переходите в раздел Настройки -> Фильтры
и создавайте новое правило.
-----------------------------------------------------------------------------
Настройка фильтра почты в roundcube
-----------------------------------------------------------------------------
После этого письма будут обрабатываться правилом сразу после поступления в
почтовый сервер, в независимости от вашего подключения к ящику. В папке
/mnt/mail/sieve появилась запись с настроенным правилом. Можете познакомиться
с синтаксисом написания правил. Он не сложный.
-----------------------------------------------------------------------------
Настройка автоответчика
-----------------------------------------------------------------------------
В roundcube есть замечательная возможность настроить автоответчик в почтовом
ящике. Это актуально, к примеру, если вы уходите в отпуск. Вы можете сами
настроить автоответчик, который будет отправлять письмо с указанной вами
информацией всем, от кого будут приходить письма в ваш ящик. Возможность
эта реализована на базе того же плагина managesieve. По-умолчанию она отключена.
Активировать ее нужно вручную.
-----------------------------------------------------------------------------
Для того, чтобы модуль автоответчика заработал, отредактируйте конфигурационный
файл плагина. Для этого открываем его в моем случае по следующему адресу:

# mcedit /var/www/html/webmail/plugins/managesieve/config.inc.php

Изменяем там параметр:

$config['managesieve_vacation'] = 1;

После этого достаточно просто обновить веб интерфейс roundcube, и появятся новые
настройки по адресу Настройки -> Отпуск
-----------------------------------------------------------------------------
Настройка автоответчика

На вкладке Дополнительные настройки есть возможность настроить различные полезные
действия, в том числе пересылку входящей почты вашему заместителю.
Общие папки по imap

Рассмотрим настройку необычного и полезного функционала в виде общих папок. С
их помощью один пользователь почтового ящика может предоставить другому
пользователю доступ к папке внутри своего почтового ящика. Где и как
использовать этот функционал, каждый может придумать сам, в зависимости от
своих потребностей. Мне кажется это удобным в том случае, когда создан
какой-то общий ящик, на который только поступает информация и нет необходимости
писать ответ от его имени. То есть по сути работает как обычный почтовый алиас.
 Но в случае с алиасом и несколькими почтовыми ящиками, письмо падает в каждый
ящик. Если таких писем и получателей много, то идет большое дублирование одного
и того же письма в рамках почтового сервера. Если сделать ящик и расшарить на
нем папку, подключить ее всем пользователям, то дублирования почты не будет.
Каждый сможет прочитать письмо, без необходимости его доставки в каждый
конкретный ящик.

Настроим общую папку imap. Хотя настраивать нам, по сути, нечего. Мы уже
все настроили ранее. Добавили соответствующие настройки в dovecot и
активировали плагин acl в roundcube. Теперь нужно просто сделать папку и
открыть ее для другого пользователя. Для этого идем в раздел Настройки -> Папки.
Создаем там любую папку. В моем случае это папка с названием Общая.
-----------------------------------------------------------------------------
Настройка общей папки imap
-----------------------------------------------------------------------------
Добавляем необходимый доступ либо всем ящикам в домене, либо какому-то конкретному.
Так же можно указать, какого рода это будет доступ:

    чтение
    запись
    удаление

Права доступа на общую папку imap

Заходим в ящик, которому добавили общий доступ и проверяем.

Проверка общей папки

Все в порядке, общая папка imap настроена и подключена. В папке /mnt/mail/shared-folders появился файл с настроенным выше правилом.

На этом настройка пользовательского функционала закончена. В принципе, почтовый сервер полностью готов к работе. Но мы сделаем еще несколько полезных настроек на стороне сервера.
Настройка dkim и spf
-----------------------------------------------------------------------------
Напишу своими словами как я понимаю работу dkim. С помощью dkim вся исходящая
почта сервера подписывается электронной цифровой подписью, связанной с именем
домена. Открытый ключ шифрования с помощью DNS публикуется в txt записи. Таким
образом, удаленный сервер, при получении письма от вас, сравнивает цифровую
подпись с опубликованным в dns открытым ключом вашего домена. Если все в порядке,
то считает, что ваше письмо в самом деле пришло от вас, а не от мошенников.
То есть с помощью этой технологии можно однозначно идентифицировать отправителя.

Некоторые считают, что эта технология помогает бороться со спамом. Не знаю,
насколько это верно. Спамеру не составит большого труда настроить на своем
сервере dkim и отправлять спам, но подписанный электронной цифровой подписью.
Теоретически, dkim помогает защититься от подделки адреса отправителя, когда
письмо якобы от вас шлет совсем другой сервер. Но с этим можно бороться и
другими способами. В общем, я до конца не понимаю, зачем это надо. Прошу
поделиться в комментариях тем, к кого есть бОльший опыт. Я только недавно
стал шагать в ногу со временем и настраивать dkim. Раньше всегда без него
обходился.
Плюс настройки dkim я вижу только в том, что автоматические фильтры определения
спама будут добавлять больше траста письмам с корректной dkim подписью. У вас
будет больше шанса не попасть в спам при прочих равных условиях. В принципе,
ради этого можно немного заморочиться.
-----------------------------------------------------------------------------
Для настройки dkim устанавливаем соответствующий пакет:

# yum install opendkim
-----------------------------------------------------------------------------
Создаем директорию для хранения ключей:

# mkdir -p /etc/postfix/dkim && cd /etc/postfix/dkim
-----------------------------------------------------------------------------
Генерируем ключи для домена:

# opendkim-genkey -D /etc/postfix/dkim/ -d zeroxzed.ru -s mail

zeroxzed.ru 	имя почтового домена
mail 	непосредственно имя сервера
-----------------------------------------------------------------------------
На выходе получаете пару файлов — закрытый (приватный) и открытый ключ.
Закрытый останется на сервере, открытый будет опубликован в dns. Переименуем
их сразу, чтобы не путаться, если у вас будет несколько доменов. Ключи нужно
будет делать для каждого домена.

# mv mail.private mail.zeroxzed.ru.private
# mv mail.txt mail.zeroxzed.ru.txt
-----------------------------------------------------------------------------
Создаем файл с таблицей ключей, в которой будут описаны все домены. В данном
случае только один.

# mcedit keytable

mail._domainkey.zeroxzed.ru zeroxzed.ru:mail:/etc/postfix/dkim/mail.zeroxzed.ru.private
-----------------------------------------------------------------------------
Тут же создаем еще один файл, в котором будет описано, каким ключом подписывать
письма каждого домена. У нас один домен, поэтому только одна запись.

# mcedit signingtable

*@zeroxzed.ru mail._domainkey.zeroxzed.ru
-----------------------------------------------------------------------------
Выставляем права доступа на все файлы:

# chown root:opendkim *
# chmod u=rw,g=r,o= *
-----------------------------------------------------------------------------
Рисуем конфиг службы.

# mcedit /etc/opendkim.conf

AutoRestart Yes
AutoRestartRate 10/1h
PidFile /var/run/opendkim/opendkim.pid
Mode sv
Syslog yes
SyslogSuccess yes
LogWhy yes
UserID opendkim:opendkim
Socket inet:8891@localhost
Umask 022
Canonicalization relaxed/relaxed
Selector default
MinimumKeyBits 1024
KeyFile /etc/postfix/dkim/mail.zeroxzed.ru.private
KeyTable /etc/postfix/dkim/keytable
SigningTable refile:/etc/postfix/dkim/signingtable
-----------------------------------------------------------------------------
Добавляем в конфигурационный файл postfix в самый конец следующие параметры:

# mcedit /etc/postfix/main.cf

smtpd_milters = inet:127.0.0.1:8891
non_smtpd_milters = $smtpd_milters
milter_default_action = accept
milter_protocol = 2
-----------------------------------------------------------------------------
Перезапускаем postfix и dkim, последний добавляем в автозагрузку.

# systemctl restart postfix
# systemctl restart opendkim.service
# systemctl enable opendkim.service
-----------------------------------------------------------------------------
Теперь нам надо добавить открытый ключ в dns. Идем в консоль управления dns
и добавляем новую txt запись. Ее содержание берем из файла /etc/postfix/dkim/mail.zeroxzed.ru.txt

cat /etc/postfix/dkim/mail.zeroxzed.ru.txt

mail._domainkey IN TXT ( "v=DKIM1; k=rsa; "
 "p=MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQClZX2xWRDISlVLF4b4pUiinY5N9WN7VXEHeyPw8smHTamXh35wJoh+j0+MIQDWG/KtdCcETeawTuypXbvtbneXniYR0iiv6kt754T2WXBjz7O/uHL+vK58LhJsm4TGyhUN6ZBit+w22jG92zdeybSZeU/g7hQdkaAAi0I+0nIkUwIDAQAB" ) ; ----- DKIM key mail for zeroxzed.ru

Убираем кавычки, лишние проблемы и вставляем. Должно получиться вот так:
-----------------------------------------------------------------------------
Настройка dkim записи в dns

Проверяю работу. Отправляю письмо на gmail и смотрю лог почтового сервера:

# cat /var/log/maillog

Mar 17 17:40:26 mail postfix/smtpd[22352]: connect from localhost[127.0.0.1]
Mar 17 17:40:26 mail postfix/smtpd[22352]: BB1794195584: client=localhost[127.0.0.1]
Mar 17 17:40:26 mail postfix/cleanup[22364]: BB1794195584: message-id=<baf63dcec016594d49f2d80f815e5d26@zeroxzed.ru>
Mar 17 17:40:26 mail opendkim[21744]: BB1794195584: DKIM-Signature field added (s=mail, d=zeroxzed.ru)
Mar 17 17:40:26 mail postfix/qmgr[21990]: BB1794195584: from=<root@zeroxzed.ru>, size=593, nrcpt=2 (queue active)
Mar 17 17:40:26 mail postfix/pipe[22369]: BB1794195584: to=<all_out@zeroxzed.ru>, relay=dovecot, delay=0.14, delays=0.11/0.02/0/0.02, dsn=2.0.0, status=sent (delivered via dovecot service)
Mar 17 17:40:26 mail postfix/smtpd[22352]: disconnect from localhost[127.0.0.1]
Mar 17 17:40:27 mail postfix/smtp[22370]: BB1794195584: to=<zeroxzed@gmail.com>, relay=gmail-smtp-in.l.google.com[64.233.163.26]:25, delay=0.84, delays=0.11/0.02/0.31/0.4, dsn=2.0.0, status=sent (250 2.0.0 OK 1489761627 185si4568435lfa.398 - gsmtp)

Все в порядке, электронная цифровая подпись установлена. Проверим, как гугл
отреагировал на нашу подпись:
-----------------------------------------------------------------------------
Проверка dkim
-----------------------------------------------------------------------------
Тоже все в порядке. Подпись выполнена корректно, проверку прошла. Дополнительно,
проверить корректность dkim записи в dns можно онлайн сервисом — http://dkimcore.org/c/keycheck.
-----------------------------------------------------------------------------
Настроим еще одно средство для повышения доверия к нашей почте со стороны других
серверов — spf. Расскажу опять своими словами для чего это нужно. Spf запись
добавляется в виде txt записи в dns вашего домена. С помощью этой записи вы
указываете, какие ip адреса имеют право отправлять почту от вашего имени.
Если кто-то из спамеров будет использовать ваше имя домена при рассылке спама,
он не пройдет проверку по spf и скорее всего будет идентифицирован как спам.

Можно указать конкретные ip адреса в записи, а можно сказать, чтобы ip адреса
проверялись по спискам A и MX записей. У нас простой случай и только 1 сервер
с одним ip, поэтому укажем конкретно этот ip адрес. Идем в панель управления
dns и добавляем новую txt запись.
-----------------------------------------------------------------------------
zeroxzed.ru. TXT v=spf1 ip4:188.35.19.125 ~all
-----------------------------------------------------------------------------
Добавление spf записи в dns
-----------------------------------------------------------------------------
Больше ничего делать не надо. Снова отправляем письмо на gmail и смотрим логи.

Проверка spf записи
-----------------------------------------------------------------------------
Обращаю внимание на прошлый скрин, когда мы проверяли dkim и еще не настроили
spf, и этот. Видно, что запись работает, гугл определил наш ip, как доверенный
для отправки писем с этого домена.
-----------------------------------------------------------------------------
Дополнительный функционал почтового сервера postfix
-----------------------------------------------------------------------------
Я рассмотрел и настроил наиболее актуальный с моей точки зрения функционал
почтового сервера. В статье я основывался исключительно на своем опыте работы
с почтой в малых и средних организациях, поэтому не претендую на истину в
последней инстанции. Рекомендую осмысленно подходить к настройке своего сервера
и решать, что нужно именно вам. Будет хорошо, если кто-то укажет на мои ошибки
или подскажет какие-то более удобные и эффективные приемы для решения затронутых задач.

В данном виде почтовый сервер представляет собой готовое и законченное решение,
но есть еще несколько вещей, которые ему бы не помешали. Я их сейчас перечислю,
а затем постараюсь постепенно писать статьи на указанные темы и ставить на них
ссылки в этой теме. Вот список того, что по моему мнению нужно еще настроить
на почтовом сервере:
-----------------------------------------------------------------------------
    Защиту от подбора паролей с помощью fail2ban.
    Мониторинг почтового сервера postfix с помощью zabbix.
    Сбор статистики с помощью pflogsumm или чего-то подобного.
    Просмотр и анализ логов с помощью webmin.
    Использование бесплатных сертификатов let’s encrypt.
    Регулярную очистку служебных почтовых ящиков.
    Бэкап всей почтовой базы.
-----------------------------------------------------------------------------
Расскажу еще почему я не настраиваю некоторые популярные программы, которые
использую на почтовых серверах:

    Clamav — известный антивирус. Считаю, что сейчас он не актуален, так как
вирусов, от которых он способен защитить, я уже давно не видел. Сейчас вирусная
эпидемия шифровальщиков. От них он не защищает.
    Spamassasin — популярный бесплатный антиспам фильтр. Скажу честно, работал
с ним очень мало и могу быть не объективен. Насколько я видел его настройку и
работу — он требует к себе некоторого внимания, калибровки, особенно на начальном
этапе. Мне обычно не хочется этим заниматься.
    Graylist — эффективное средство борьбы со спамом. Я уже подробно его рассматривал,
когда писал про iredmail, так что не буду повторяться. Скажу лишь, что режет спам
очень эффективно и бесплатно, но есть существенные неудобства, которые по моему
мнению не перекрывают плюсы. Поэтому я не использую.

В качестве антиспама я предпочитаю коммерческое решение — Kaspersky Anti-Spam.
Я знаю этот продукт уже лет 8. Он действительно отлично фильтрует спам. Ложных
срабатываний вообще не припоминаю, 95% спама фильтрует, может больше. С ним вопрос
спама отпадает вообще. Стоит он недорого, можно купить лицензию на меньшее
количество ящиков, чем реально используется в системе. Этот вопрос никак не
отслеживается и на качество работы не влияет. Но нужно понимать, что это уже
нарушение лицензионного соглашения. Но можно всякие хитрости придумать, чтобы
и фильтровать и не нарушать.
Борьба со спамом средствами postfix
-----------------------------------------------------------------------------
Сначала хотел сразу все настройки postfix разместить в соответствующем разделе
в едином конфиге, но потом передумал и решил все же вынести этот вопрос на
отдельное рассмотрение. Возможно, не каждому захочется сразу в эту тему
углубляться. Все, что рассказано выше, позволит настроить полноценный почтовый
сервер, который будет успешно принимать почту и доставлять ее пользователям. Но
в таком виде он будет принимать слишком много спама, но зато не будет проблем с
тем, что от кого-то что-то не придет. Как ни крути, но все средства борьбы со
спамом так или иначе несут накладные расходы в виде ложных срабатываний с той
или иной вероятностью. Если вы решите не заморачиваться и купить Kaspersky
Anti-Spam, можете этот раздел не читать. Он сам реализует все те проверки, что
мы будем делать. Если же хотите своими силами бороться со спамом средствами postfix,
то давайте дальше разбираться.
-----------------------------------------------------------------------------
Я буду использовать штатные возможности postfix, позволяющие отсеять спам по
тем или иным параметрам еще до получения письма. Это очень эффективный способ
с точки зрения производительности. Благодаря этому, правильно настроенный на
отсев спама postfix часто ставят перед exchange, чтобы снизить на него нагрузку.
Сразу дам ссылки на официальную документацию с описанием параметров, которые я
буду использовать:
-----------------------------------------------------------------------------
    smtpd_helo_restrictions
    smtpd_sender_restrictions
    smtpd_recipient_restrictions
    smtpd_data_restrictions
    smtpd_client_restrictions
-----------------------------------------------------------------------------
Есть еще парочка — smtpd_etrn_restrictions и smtpd_end_of_data_restrictions,
но я ими не пользуюсь.
-----------------------------------------------------------------------------
Обращаю внимание на то, что нужно очень аккуратно работать с настройками, о
которых пойдет речь. Нужно четко понимать как, зачем и что вы делаете. Неверные
настройки могут нарушить нормальное хождение почты. Нужно уметь анализировать
лог файл почтового сервера и понимать, что там происходит.
-----------------------------------------------------------------------------
Долго думал, как лучше всего представить информацию по этому разделу. В итоге
решил просто написать часть конфига, которая отвечает за restrictions с комментариями.
Более подробную информацию по каждой настройке вы можете найти в официальной
документации postfix, ссылки я привел выше, либо в гугле. Данные настройки
это моя многолетняя калькуляция различных параметров, собранных из черновиков
и рабочих серверов. Не везде все было настроено именно в таком виде, так как
ситуации бывают разные. Сейчас я постарался все собрать в одном месте и аккуратно 
описать. Те проверки в борьбе со спамом, что вам не нужны, просто закомментируйте.
В конце я еще пройдусь по некоторым из них и поделюсь своим опытом.
-----------------------------------------------------------------------------
#Описание списков исключений
smtpd_restriction_classes = white_client_ip,
                            black_client_ip,
                            block_dsl,
                            white_client,
                            white_helo,
                            black_client,
                            mx_access
-----------------------------------------------------------------------------
# IP адреса, которые нужно пропускать всегда
white_client_ip		= check_client_access hash:/etc/postfix/lists/white_client_ip

# IP адреса, которые нужно блокировать всегда
black_client_ip		= check_client_access hash:/etc/postfix/lists/black_client_ip

# E-mail, которые нужно пропускать всегда
white_client		= check_sender_access hash:/etc/postfix/lists/white_client

# E-mail, которые нужно блокировать всегда
black_client		= check_sender_access hash:/etc/postfix/lists/black_client

# Неправильные значения HELO, которые мы тем не менее принимаем
white_helo = check_sender_access hash:/etc/postfix/lists/white_helo
# Правила для блокировки различных динамических ip.
block_dsl 		= check_client_access regexp:/etc/postfix/lists/block_dsl

# Список приватных сетей, которые не могут быть использованы в качестве IP для MX записей
mx_access		= check_sender_mx_access cidr:/etc/postfix/lists/mx_access

# Проверки на основе данных, переданных в HELO/EHLO hostname
smtpd_helo_restrictions =	permit_mynetworks,
		permit_sasl_authenticated,
		white_client_ip,
                white_helo,
		black_client_ip,
		block_dsl,
		# Отказываем серверам, у которых в HELO несуществующий или не FQDN адрес 
		reject_invalid_helo_hostname,
		reject_non_fqdn_helo_hostname,
		# Запрещаем приём писем от серверов, представляющихся адресом, для которого не существует A или MX записи.
		reject_unknown_helo_hostname

# Проверки клиентского компьютера или другого почтового сервера, который соединяется с сервером postfix для отправки письма
smtpd_client_restrictions = 	permit_mynetworks,
		permit_sasl_authenticated,
		# Отвергает запрос, когда клиент отправляет команды SMTP раньше времени, еще не зная, поддерживает ли Postfix конвейерную обработку команд ESMTP
		reject_unauth_pipelining,
		# Блокируем клиентов с адресами from, домены которых не имеют A/MX записей
		reject_unknown_address,
		reject_unknown_client_hostname

# Проверки исходящей или пересылаемой через нас почты на основе данных MAIL FROM
smtpd_sender_restrictions =	permit_mynetworks,
		permit_sasl_authenticated,
		white_client,
		black_client,
		# Запрет отправки писем, когда адрес MAIL FROM не совпадает с логином пользователя
		reject_authenticated_sender_login_mismatch,
		# Отклоняем письма от несуществующих доменов
		reject_unknown_sender_domain,
		# Отклоняем письма от доменов в не FQDN формате
		reject_non_fqdn_sender,
		# Отклонение писем с несуществующим адресом отправителя
		reject_unlisted_sender,
		reject_unauth_destination,
		# Отклонять сообщения от отправителей, ящики которых не существуют, использовать аккуратно
		#reject_unverified_sender,
		mx_access

# Правила приема почты нашим сервером на основе данных RCPT TO
smtpd_recipient_restrictions =  permit_mynetworks,
		permit_sasl_authenticated,
		# Отклоняет всю почту, что адресована не для наших доменов
		reject_unauth_destination,
		# Отклонение писем с несуществующим адресом получателя
		reject_unlisted_recipient,
		# Отклоняет сообщения на несуществующие домены
		reject_unknown_recipient_domain,
		# Отклоняет сообщения если получатель не в формате FQDN
		reject_non_fqdn_recipient,
		# Отклоняем прием от отправителя с пустым адресом письма, предназначенным нескольким получателям.
		reject_multi_recipient_bounce

У меня во всех ограничениях первыми правилами стоят разрешения для mynetworks
и авторизовавшихся пользователей. Важно понимать, что это значит и для чего
сделано. Ограничения читаются последовательно в порядке их перечисления. Таким
образом, мы своих пользователей пускаем мимо ограничений, а для всех остальных
выполняются проверки.

Теперь важные комментарии по указанным параметрам. Если бы все почтовые
сервера всех системных администраторов были настроены по правилам, то эти
комментарии не были бы нужны. Пройдемся по некоторым ограничениям, которые
нужно включать осторожно:

    reject_invalid_helo_hostname и reject_unknown_helo_hostname — под эти
правила иногда попадают почтовые серверы клиентов, которые не очень хорошо
настроены. У них бывают неправильные адреса, кривые записи dns, отсутствие
обратных зон и т.д. Их не много, но попадаются. Это не страшно, если вы
регулярно следите за сервером. Отправитель получит сразу сообщение о том,
что его письмо не дошло до вас. Если он как-то сообщит вам о проблеме, вы
легко добавите его в белый список и все будет нормально. Если вам не
хочется следить за сервером, лучше не указывайте эти ограничения. Но 
спам они отсекают не плохо. Сюда попадают все завирусованные компьютеры 
и сервера без нормальных настроек dns (а их чаще всего и нет).
    reject_unverified_sender — специально его закомментировал. Я
 тестировал этот параметр. В принципе, работает нормально, но есть, как 
обычно, нюансы. Поясню, что делает этот параметр. Когда вам кто-то шлет 
письмо, ваш сервер обращается к серверу отправителю и спрашивает его 
стандатрной командой, есть ли на сервере такой отправитель. Если удаленный
 сервер отвечает, что есть, то никаких проблем — письмо принимается. Если 
удаленный сервер не отвечает или говорит, что такого адресата нет — письмо
 отклоняем. Очевидно, что такие проверки создают дополнительную постоянную
 нагрузку. Это нужно учитывать. К тому же, у вас почтовый лог постоянно 
будет забит этими проверками, особенно, если вам приходит много спама. На 
каждое спамовое письмо будет идти проверка, а сервера отправителя скорее 
всего либо нет, либо он неправильный, либо не отвечает и т.д. Все это будет
 постоянно проверяться и фиксироваться. В общем, я не использую.
-----------------------------------------------------------------------------
На время отладки ограничений, рекомендую пользоваться параметром:

soft_bounce = yes
-----------------------------------------------------------------------------
Когда он включен, все ответы сервера с кодами ошибок 5XX, заменяются на 4ХХ.
 То есть постоянная ошибка, которая сразу отклоняет письмо, заменяется на 
временную, которая предлагает повторить отправку позже. Таким образом, 
вы увидите работу всех ограничений, но письма не будут отклонены навсегда.
 Сервер отправителя через некоторое время снова придет к вам с новой попыткой
 доставки почты. Письмо безвозвратно не отклоняется. Вы можете проанализировать
 работу фильтра и решить, ставить его на постоянную работу или с ним что-то не так.
-----------------------------------------------------------------------------
Создадим теперь файлы с белыми и черными списками.

cd /etc/postfix/lists && touch white_client_ip black_client_ip white_client black_client white_helo block_dsl mx_access
-----------------------------------------------------------------------------
Ниже пример содержания этих файлов. Вы можете менять по своему усмотрению.

# cat white_client_ip
195.28.34.162 OK
141.197.4.160 OK

# cat black_client_ip
205.201.130.163 REJECT You IP are blacklisted!
198.2.129.162 REJECT You IP are blacklisted!

# cat white_client
# Принимать всю почту с домена яндекс
yandex.ru OK
# Разрешить конкретный ящик
spammer@mail.ru OK

# cat black_client
# Блокировать всю почту с домена mail.ru
mail.ru REJECT You domain are blacklisted!
# Блокировать конкретный ящик
spam@rambler.ru REJECT You e-mail are blacklisted!

# cat white_helo
# Могут попадаться вот такие адреса, которые не пройдут наши проверки
ka-s-ex01.itk.local     OK
exchange.elcom.local    OK

# cat block_dsl
/^dsl.*\..*\..*/i                               553 AUTO_DSL spam
/dsl.*\..*\..*/i                                553 AUTO_DSL1 spam
/[ax]dsl.*\..*\..*/i                            553 AUTO_XDSL spam
/client.*\..*\..*/i                             553 AUTO_CLIENT spam
/cable.*\..*\..*/i                              553 AUTO_CABLE spam
/pool.*\..*\..*/i                               553 AUTO_POOL spam
/dial.*\..*\..*/i                               553 AUTO_DIAL spam
/ppp.*\..*\..*/i                                553 AUTO_PPP spam
/dslam.*\..*\..*/i                              553 AUTO_DSLAM spam
/node.*\..*\..*/i                               553 AUTO_NODE spam
/([0-9]*-){3}[0-9]*(\..*){2,}/i                 553 SPAM_ip-add-rr-ess_networks
/([0-9]*\.){4}(.*\.){3,}.*/i                    553 SPAM_ip-add-rr-ess_networks
/.*\.pppool\..*/i                               553 SPAM_POOL
/[0-9]*-[0-9]*-[0-9]*-[0-9]*-tami\.tami\.pl/i   553 SPAM_POOL
/pool-[0-9]*-[0-9]*-[0-9]*-[0-9]*\..*/i         553 SPAM_POOL
/.*-[0-9]*-[0-9]*-[0-9]*-[0-9]*\.gtel.net.mx/i  553 SPAM_POOL
/dhcp.*\..*\..*/i                               553 SPAM_DHCP

# cat mx_access
127.0.0.1      DUNNO 
127.0.0.2      550 Domains not registered properly
0.0.0.0/8      REJECT Domain MX in broadcast network 
10.0.0.0/8     REJECT Domain MX in RFC 1918 private network 
127.0.0.0/8    REJECT Domain MX in loopback network 
169.254.0.0/16 REJECT Domain MX in link local network 
172.16.0.0/12  REJECT Domain MX in RFC 1918 private network 
192.0.2.0/24   REJECT Domain MX in TEST-NET network 
192.168.0.0/16 REJECT Domain MX in RFC 1918 private network 
224.0.0.0/4    REJECT Domain MX in class D multicast network 
240.0.0.0/5    REJECT Domain MX in class E reserved network 
248.0.0.0/5    REJECT Domain MX in reserved network
-----------------------------------------------------------------------------
По сути файлы белых и черных списков не отличаются друг от друга. Можно
использовать только один файл и в нем в каждой отдельной строке указывать либо
запрет, либо разрешение. Я разделил просто для удобства восприятия и редактирования.
Возможно вам будет удобнее с одним файлом.

После редактирования файлов обязательно выполняем команду на перестроение базы
данных. Я перестрою сразу все файлы:

cd /etc/postfix/lists && postmap white_client_ip black_client_ip white_client
black_client white_helo block_dsl mx_access

Еще упомяну о таком популярном явлении в спамерских письмах, как подделка адреса
отправителя. Причем не просто подделка на абы кого, а именно на ваше имя домена.
Пользователь получает спам письмо и в почтовом клиенте видит, что оно отправлено
с вашего домена. Только по заголовкам можно определить реального отправителя.
Такой подход позволяет обходить некоторые антиспам системы, которые не фильтруют
письма внутреннего домена. Бороться с подменой адреса отправителя в нашем случае
очень просто. Для этого в black_client добавим следующую запись:

zeroxzed.ru 554 Stop spam from my name

Отправка с нашего домена осуществляется только с SASL авторизацией, а она во
всех ограничениях стоит первой, поэтому письма реальных пользователей без проблем
будут уходить. А всех тех, кто только притворяется нашим доменом, мы будет
отфильтровывать этим правилом.
-----------------------------------------------------------------------------
Приведу в завершении описания методов борьбы со спамом простой пример. Добавим
в black_client почтовый адрес и отправим с него письмо.

# cat black_client
zeroxzed@gmail.com REJECT Your e-mail was banned!

# postmap black_client
-----------------------------------------------------------------------------
Отправляем сообщение и проверяем почтовый лог.

# cat /var/log/maillog

Mar 20 02:21:34 mail postfix/smtpd[10816]: connect from mail-yw0-f177.google.com[209.85.161.177]
Mar 20 02:21:35 mail postfix/smtpd[10816]: Anonymous TLS connection established from mail-yw0-f177.google.com[209.85.161.177]: TLSv1.2 with cipher ECDHE-RSA-AES128-GCM-SHA256 (128/128 bits)
Mar 20 02:21:35 mail postfix/smtpd[10816]: NOQUEUE: reject: RCPT from mail-yw0-f177.google.com[209.85.161.177]: 554 5.7.1 <zeroxzed@gmail.com>: Sender address rejected: Your e-mail was banned!; from=<zeroxzed@gmail.com> to=<root@zeroxzed.ru> proto=ESMTP helo=
Mar 20 02:21:35 mail postfix/smtpd[10816]: disconnect from mail-yw0-f177.google.com[209.85.161.177]

Вот и результат. На этом по борьбе со спамом все.
-----------------------------------------------------------------------------
Заключение

Проверить настроенный почтовый сервер можно с помощью онлайн сервиса
https://www.mail-tester.com. Не факт, что получите максимальный бал, но
все недочеты будут указаны. Критичное нужно исправить (например, если обратная
зона неправильная), некритичное можно пропустить (если dkim, к примеру, не
настраивали).

Кажется все написал, что знал по поводу почтового сервера на linux в небольших
и средних организациях. У некоторых может возникнуть вопрос, а зачем свой
почтовый сервер? Почему бы не воспользоваться средствами корпоративной почты,
которую представляют популярные почтовые сервисы бесплатно? Я планирую написать
по этому поводу отдельную заметку (в итоге написал — выбор почтового сервера).
У меня тоже есть определенный опыт на этот счет. И если некоторое время назад
я считал, что свои почтовые серверы в небольших организациях уже не актуальны,
то сейчас я так не думаю, поэтому и появилась эта статья.

Буду рад замечаниям по делу и советам в комментариях.

-----------------------------------------------------------------------------
	Пример 1.1
-----------------------------------------------------------------------------
Почтовый сервер Postfix на CentOS 7 с виртуальными доменами, системой управления,
веб-доступом и многим другим
-----------------------------------------------------------------------------
https://www.dmosk.ru/instruktions.php?object=postfix-centos
-----------------------------------------------------------------------------
Термины по теме: Postfix, POP3, SMTP, IMAP, MariaDB, CentOS, PostfixAdmin,
Dovecot, Roundcube
-----------------------------------------------------------------------------
В данной инструкции выполнена настройка полноценного почтового сервера.
Список всех особенностей и возможностей:
-----------------------------------------------------------------------------
    Почтовая система на базе Postfix;
    Поддержка виртуальных доменов;
    Хранение почты на сервере;
    Подключение к почтовым ящикам по POP3 и IMAP (Dovecot);
    Поддержка шифрования;
    Хранение части настроек в MariaDB;
    Защита от СПАМа и вирусов;
    Доступ к почте с помощью веб-интерфейса (Roundcube);
    Возможность управление почтовыми ящиками с помощью PostfixAdmin.
-----------------------------------------------------------------------------
Содержание
-----------------------------------------------------------------------------
1. Преднастройка системы
2. Настройка веб-сервера: NGINX + PHP + MariaDB
3. Установка и настройка PostfixAdmin
4. Настройка Postfix
5. Настройка Dovecot
6. Проверка работы сервера
7. Настройка Roundcube Webmail
8. Защита от вирусов
9. Защита со СПАМа
-----------------------------------------------------------------------------
1. Преднастройка системы
-----------------------------------------------------------------------------
Напоминаю, данная инструкция написана под систему Linux CentOS версии 7.
-----------------------------------------------------------------------------
Задаем правильное имя серверу — это важный шаг, так как большинство антиспам
систем выполняют проверки, обращаясь к серверу по имени в ожидании ответа.

vi /etc/hostname

relay.dmosk.ru
-----------------------------------------------------------------------------
* необходимо указать FQDN-имя, которое будет доступно из глобальной сети. В данном примере указано relay.dmosk.ru.
-----------------------------------------------------------------------------
После вводим такую команду:

hostname relay.dmosk.ru
-----------------------------------------------------------------------------
Устанавливаем служебные пакеты (они понадобятся в процессе настройки сервера):

yum install ntp wget

* ntp для возможности синхронизировать время на сервере; wget — клиент для загрузки файлов.

Задаем временную зону (в данном примере московское время):

\cp /usr/share/zoneinfo/Europe/Moscow /etc/localtime
-----------------------------------------------------------------------------
Синхронизируем время:

ntpdate ru.pool.ntp.org
-----------------------------------------------------------------------------
Обновляем систему:

yum update
-----------------------------------------------------------------------------
Заранее открываем порты на брандмауэре:

firewall-cmd --permanent --add-port=25/tcp

firewall-cmd --permanent --add-port=80/tcp

firewall-cmd --permanent --add-port=110/tcp

firewall-cmd --permanent --add-port=143/tcp

firewall-cmd --permanent --add-port=443/tcp

firewall-cmd --permanent --add-port=465/tcp

firewall-cmd --permanent --add-port=587/tcp

firewall-cmd --permanent --add-port=993/tcp

firewall-cmd --permanent --add-port=995/tcp

firewall-cmd --reload
-----------------------------------------------------------------------------
* где мы откроем следующие порты:

    25 — стандартный SMTP через STARTTLS;
    80 — HTTP для порталов Postfixadmin и Roundcube;
    110 — стандартный POP3 через STARTTLS;
    143 — стандартный IMAP через STARTTLS;
    443 — защищенный HTTPS для порталов Postfixadmin и Roundcube;
    465 — защищенный SMTP через SSL/TLS;
    587 — защищенный SMTP через STARTTLS;
    993 — защищенный IMAP через SSL/TLS;
    995 — защищенный POP3 через SSL/TLS.
-----------------------------------------------------------------------------
2. Настройка веб-сервера: NGINX + PHP + MariaDB
-----------------------------------------------------------------------------
Система управления PostfixAdmin работает как веб-приложение, разработанное на
PHP, а информацию хранит в базе данных. В нашем примере будет использоваться
веб-сервер на NGINX, а база данных — MariaDB.
-----------------------------------------------------------------------------
Установка NGINX
-----------------------------------------------------------------------------
Добавляем репозиторий с нужным пакетом:

vi /etc/yum.repos.d/nginx.repo

[nginx]
name=nginx repo
baseurl=http://nginx.org/packages/centos/$releasever/$basearch/
gpgcheck=0
enabled=1
-----------------------------------------------------------------------------
Устанавливаем nginx:

yum install nginx
-----------------------------------------------------------------------------
Разрешаем автозапуск сервиса и запускаем его:

systemctl enable nginx

systemctl start nginx
-----------------------------------------------------------------------------
Проверяем работоспособность веб-сервера, обратившись к нему в браузере по IP-адресу.
Если видим заголовок «Welcome to nginx!», NGINX настроен верно.
-----------------------------------------------------------------------------
Приветствие NGINX — все настроено верно
PHP + PHP-FPM + NGINX
-----------------------------------------------------------------------------
Устанавливаем php и php-fpm:

yum install php

yum install php-fpm
-----------------------------------------------------------------------------
Настраиваем NGINX:

vi /etc/nginx/conf.d/default.conf

server {
    listen       80 default_server;
    set $root_path /usr/share/nginx/html;

    location / {
        root   $root_path;
        index index.php index.hml;
    }

    location ~ \.php$ {
        fastcgi_pass unix:/var/run/php-fpm/php5-fpm.sock;
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $root_path$fastcgi_script_name;
        include fastcgi_params;
        fastcgi_param DOCUMENT_ROOT $root_path;
    }
}

* где /usr/share/nginx/html — каталог для размещения портала управления Postfix.
-----------------------------------------------------------------------------
Настраиваем PHP-FPM:

vi /etc/php-fpm.d/www.conf

listen = /var/run/php-fpm/php5-fpm.sock

* здесь мы поменяли строку 127.0.0.1:9000.
-----------------------------------------------------------------------------
Запускаем сервисы:

systemctl enable php-fpm

systemctl start php-fpm

systemctl restart nginx
-----------------------------------------------------------------------------
* если в процессе перезапуска nginx выскочит ошибка nginx: [emerg] a duplicate
default server, необходимо найти настройку виртуального домена, в которой также
указана опция default_server — опцию нужно убрать. Или можно самостоятельно
настроить другой виртуальный домен.
-----------------------------------------------------------------------------
Для проверки, создаем индексный файл в директории сайта со следующим содержимым:

vi /usr/share/nginx/html/index.php

<?php phpinfo(); ?>
-----------------------------------------------------------------------------
Открываем сайт в браузере по его IP-адресу. На открывшейся странице мы должны
увидеть подробную информацию по php:
phpinfo
-----------------------------------------------------------------------------
MariaDB
-----------------------------------------------------------------------------
Устанавливаем сервер баз данных следующей командой:

yum install mariadb mariadb-server
-----------------------------------------------------------------------------
Включаем автозапуск сервиса и запускаем его:

systemctl enable mariadb

systemctl start mariadb
-----------------------------------------------------------------------------
Задаем пароль для пользователя sql root:

mysqladmin -u root password
-----------------------------------------------------------------------------
3. Установка и настройка PostfixAdmin
-----------------------------------------------------------------------------
Устанавливаем дополнительные компоненты для PHP:

yum install php-mysql php-mbstring php-imap
-----------------------------------------------------------------------------
Для применения установленных пакетов, перезапускаем обработчик скриптов:

systemctl restart php-fpm
-----------------------------------------------------------------------------
Скачиваем PostfixAdmin:

wget https://sourceforge.net/projects/postfixadmin/files/latest/download -O postfixadmin.tar.gz

В директории сайтов nginx создаем каталог для postfixadmin и распаковываем в него архив:

mkdir /usr/share/nginx/html/postfixadmin

tar -C /usr/share/nginx/html/postfixadmin -xvf postfixadmin.tar.gz --strip-components 1
-----------------------------------------------------------------------------
Задаем права на каталог:

chown -R apache:apache /usr/share/nginx/html/postfixadmin

* несмотря на то, что мы используем веб-сервер nginx, php-fpm по умолчанию,
запускается от пользователя apache.
-----------------------------------------------------------------------------
Создаем базу данных postfix и учетную запись в mariadb:

mysql -u root -p

CREATE DATABASE postfix DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;

* где postfix — имя базы.

GRANT ALL ON postfix.* TO 'postfix'@'localhost' IDENTIFIED BY 'postfix123';

* где postfix — имя учетной записи; postfix123 — пароль;
localhost разрешает подключение только с локального сервера.

Выходим из командной оболочки MariaDB:

\q
-----------------------------------------------------------------------------
Открываем конфигурационный файл postfixadmin:

vi /usr/share/nginx/html/postfixadmin/config.inc.php

И редактируем следующее:

$CONF['configured'] = true;
$CONF['default_language'] = 'ru';
$CONF['database_password'] = 'postfix123';
$CONF['emailcheck_resolve_domain']='NO';
-----------------------------------------------------------------------------
Запускаем браузер и вводим адрес http://<IP-адрес сервера>/postfixadmin/setup.php

Начнется процесс проверки конфигурации и установки портала PostfixAdmin.
После ее окончания вводим дважды пароль и генерируем хэш:
-----------------------------------------------------------------------------
Вводим дважды пароль после установки PostfixAdmin
-----------------------------------------------------------------------------
После перезагрузки страницы копируем хэш:
-----------------------------------------------------------------------------
Открываем конфигурационный файл:

vi /usr/share/nginx/html/postfixadmin/config.inc.php

Находим строчку:

$CONF['setup_password'] = 'changeme';

И меняем ее на:

$CONF['setup_password'] = '7a8e14...c26';

* где '7a8e14...c26' — скопированный хэш.
-----------------------------------------------------------------------------
После, на той же странице, где показан хэш, добавляем суперпользователя PostfixAdmin:

Создаем суперпользователя PostfixAdmin

* где Setup password — пароль, который мы ввели на предыдущей странице; Пароль — новый пароль для создаваемой учетной записи.

В итоге мы увидим следующее:
-----------------------------------------------------------------------------
Мы создали суперпользователя для управления Postfix

И переходим в браузере на страницу http://<IP-адрес сервера>/postfixadmin/

Вводим логин и пароль для созданного пользователя.

Готово.
-----------------------------------------------------------------------------
4. Настройка Postfix
-----------------------------------------------------------------------------
По умолчанию, Postfix уже установлен в CentOS 7. Но если встретится сервер без
него, выполним установку простой командой:

yum install postfix
-----------------------------------------------------------------------------
Создаем учетную запись, от которой мы будем работать с каталогом виртуальных
почтовых ящиков:

groupadd -g 1024 vmail
useradd -d /home/mail -g 1024 -u 1024 vmail -m

* сначала мы создаем группу vmail и guid 1024, после — пользователя vmail с
uid 1024 и домашней директорией /home/mail. Обратите внимание, что в некоторых
системах идентификатор группы и пользователя 1024 может быть занят. В таком
случае необходимо создать другой, а в данной инструкции ниже заменить все 1024
на альтернативный.
-----------------------------------------------------------------------------
Теперь открываем на редактирование конфигурационный файл почтового сервера:

vi /etc/postfix/main.cf

И редактируем следующие строки:
-----------------------------------------------------------------------------
myorigin = $mydomain

* данная настройка указывает, какой домен подставлять отправителю, если он не указан в заголовке FROM.

mydestination = $myhostname, localhost.$mydomain, localhost, $mydomain

* указываем, для каких доменов принимаем входящую почту.

local_recipient_maps = unix:passwd.byname $alias_maps

* указываем, откуда брать список локальных пользователей.

mynetworks = 127.0.0.0/8

* разрешаем отправлять сообщения локальному серверу.

alias_maps = hash:/etc/aliases

* указываем, откуда брать список алиасов.

inet_interfaces = all

* необходимо убедиться, что postfix будет слушать на всех необходимых интерфейсах, в данном случае, на всех.
-----------------------------------------------------------------------------
Теперь в конец конфигурационного файла допишем следующее:
-----------------------------------------------------------------------------
virtual_mailbox_base = /home/mail
virtual_alias_maps = proxy:mysql:/etc/postfix/mysql_virtual_alias_maps.cf
virtual_mailbox_domains = proxy:mysql:/etc/postfix/mysql_virtual_domains_maps.cf
virtual_mailbox_maps = proxy:mysql:/etc/postfix/mysql_virtual_mailbox_maps.cf
virtual_minimum_uid = 1024
virtual_uid_maps = static:1024
virtual_gid_maps = static:1024
virtual_transport = dovecot
dovecot_destination_recipient_limit = 1

smtpd_sasl_auth_enable = yes
smtpd_sasl_exceptions_networks = $mynetworks
smtpd_sasl_security_options = noanonymous
broken_sasl_auth_clients = yes
smtpd_sasl_type = dovecot
smtpd_sasl_path = private/auth

smtpd_tls_cert_file = /etc/ssl/mail/public.pem
smtpd_tls_key_file = /etc/ssl/mail/private.key
smtpd_use_tls = yes
smtpd_tls_auth_only = yes
smtpd_helo_required = yes
-----------------------------------------------------------------------------
* где:

    virtual_mailbox_base — базовый путь хранения почтовых ящиков в системе UNIX.
    virtual_alias_maps — формат и путь хранения алиасов для виртуальных пользователей.
    virtual_mailbox_domains — формат и путь хранения доменов виртуальных пользователей.
    virtual_mailbox_maps — формат и путь хранения почтовых ящиков для виртуальных пользователей.
    virtual_minimum_uid — с какого номера присваивать идентификаторы пользователям.
    virtual_uid_maps — идентификатор пользователя, от которого записываются сообщения.
    virtual_gid_maps — идентификатор группы, от которой записываются сообщения.
    virtual_transport — задает доставщика сообщений.
    dovecot_destination_recipient_limit — передача сообщений от Postfix в Dovecot выполняется по заданному количеству (в нашем примере, по 1 шт.).
    smtpd_sasl_auth_enable — разрешает sasl аутентификацию.
    smtpd_sasl_exceptions_networks — исключение сетей от использования шифрования.
    smtpd_sasl_security_options — дополнительные опции настройки sasl.
    broken_sasl_auth_clients — эту опцию прописываем для клиентов MS Outlook.
    smtpd_sasl_type — указывает тип аутентификации.
    smtpd_sasl_path — путь до временных файлов обмена информацией с Dovecot. Указывается либо абсолютный путь, либо относительный queue_directory.
    smtpd_tls_cert_file — полный путь до публичного сертификата.
    smtpd_tls_key_file — полный путь до приватного сертификата.
    smtpd_use_tls — указывает клиентам на наличие поддержки TLS.
    smtpd_tls_auth_only — использовать только TLS.
    smtpd_helo_required — требовать начинать сессию с приветствия.
-----------------------------------------------------------------------------
Создаем файл с настройками обращения к базе с алиасами:

vi /etc/postfix/mysql_virtual_alias_maps.cf

user = postfix
password = postfix123
hosts = localhost
dbname = postfix
query = SELECT goto FROM alias WHERE address='%s' AND active = '1'

* где user и password — логин и пароль для подключения к MySQL; hosts — имя
сервера баз данных (в нашем случае, локальный сервер); dbname — имя базы данных;
query — шаблон запроса к данным.
-----------------------------------------------------------------------------
Создаем файл с инструкцией получения данных по виртуальным доменам:

vi /etc/postfix/mysql_virtual_domains_maps.cf

user = postfix
password = postfix123
hosts = localhost
dbname = postfix
query = SELECT domain FROM domain WHERE domain='%u'
-----------------------------------------------------------------------------
И файл с почтовыми ящиками:

vi /etc/postfix/mysql_virtual_mailbox_maps.cf

user = postfix
password = postfix123
hosts = localhost
dbname = postfix
query = SELECT CONCAT(domain,'/',maildir) FROM mailbox WHERE username='%s' AND active = '1'
-----------------------------------------------------------------------------
Открываем файл master.cf и дописываем в самый конец:

vi /etc/postfix/master.cf

submission     inet  n       -       n       -       -       smtpd
    -o smtpd_tls_security_level=may
    -o smtpd_sasl_auth_enable=yes
    -o smtpd_sasl_type=dovecot
    -o smtpd_sasl_path=/var/spool/postfix/private/auth
    -o smtpd_sasl_security_options=noanonymous
    -o smtpd_sasl_local_domain=$myhostname

smtps      inet n - n - - smtpd
    -o syslog_name=postfix/smtps
    -o smtpd_tls_wrappermode=yes
    -o smtpd_sasl_auth_enable=yes
    -o smtpd_client_restrictions=permit_sasl_authenticated,reject

dovecot    unix  -       n       n       -        -       pipe
    flags=DRhu user=vmail:vmail argv=/usr/libexec/dovecot/deliver -d ${recipient}

* необходимо убедиться, что в содержимом файла нет других раскомментированных опций для submission, smtps и dovecot (по умолчанию, их нет). В данном случае, мы настроили работу postfix на портах 25, 465 и 587.
-----------------------------------------------------------------------------
Перезапустим postfix:

systemctl restart postfix
-----------------------------------------------------------------------------
5. Настройка Dovecot
-----------------------------------------------------------------------------
Устанавливаем Dovecot с компонентом для работы с СУБД:

yum install dovecot dovecot-mysql
-----------------------------------------------------------------------------
Настраиваем способ хранения сообщений:

vi /etc/dovecot/conf.d/10-mail.conf

mail_location = maildir:/home/mail/%d/%u/
first_valid_gid = 1024

* в данном примере сообщения будут храниться в продвинутом формате maildir.
-----------------------------------------------------------------------------
Настраиваем слушателя для аутентификации:

vi /etc/dovecot/conf.d/10-master.conf

service auth {
  unix_listener /var/spool/postfix/private/auth {
    mode = 0666
    user = postfix
    group = postfix
  }
  unix_listener auth-userdb {
    mode = 0600
    user = vmail
    group = vmail
  }
}

* обращаем внимание, что /var/spool/postfix/private/auth — это тот же private/auth,
который был прописан нами в postfix.
-----------------------------------------------------------------------------
Настраиваем аутентификацию в Dovecot:

vi /etc/dovecot/conf.d/10-auth.conf

#!include auth-system.conf.ext
!include auth-sql.conf.ext

* в данном случае мы просто комментируем обычную аутентификацию и снимаем комментарий
для использования sql-аутнтификации.
-----------------------------------------------------------------------------
Настраиваем использование шифрования:

vi /etc/dovecot/conf.d/10-ssl.conf

ssl = required
ssl_cert = </etc/ssl/mail/public.pem
ssl_key = </etc/ssl/mail/private.key

* данная настройка укажет dovecot требовать от клиентов использования шифрования.
-----------------------------------------------------------------------------
Настроим автоматическое создание каталогов при первом подключении пользователя к ящику:

vi /etc/dovecot/conf.d/15-lda.conf

lda_mailbox_autocreate = yes
-----------------------------------------------------------------------------
Настраиваем подключение к нашей базе данных:

vi /etc/dovecot/conf.d/auth-sql.conf.ext

passdb {
  …
  args = /etc/dovecot/sql.conf
}

userdb {
  …
  args = /etc/dovecot/sql.conf
}

* в данном примере мы указали на файл, в котором будут находиться настройки для получения пользователей и паролей из базы данных.
-----------------------------------------------------------------------------
Создаем файл с настройками работы с mysql:

vi /etc/dovecot/sql.conf

driver = mysql
connect = host=localhost dbname=postfix user=postfix password=postfix123
default_pass_scheme = MD5-CRYPT
password_query = SELECT password FROM mailbox WHERE username = '%u'
user_query = SELECT maildir, 1024 AS uid, 1024 AS gid FROM mailbox WHERE username = '%u'
user_query = SELECT CONCAT('/home/mail/',LCASE(`domain`),'/',LCASE(`maildir`)), 1024 AS uid, 1024 AS gid FROM mailbox WHERE username = '%u'
-----------------------------------------------------------------------------
И, напоследок, настраиваем протоколы и интерфейс, на котором будет слушать dovecot:

vi /etc/dovecot/dovecot.conf

protocols = imap imaps pop3 pop3s
listen = *

* по умолчанию, dovecot слушает также на ipv6 (listen = *, ::). Если на сервере не используется 6-я версия протокола TCP/IP, в логах dovecot появятся ошибки:
master: Error: service(imap-login): listen(::, 143) failed: Address family not supported by protocol
master: Error: service(imap-login): listen(::, 993) failed: Address family not supported by protocol
Генерируем сертификаты безопасности
-----------------------------------------------------------------------------
Создаем каталог, в котором разместим сертификаты:

mkdir -p /etc/ssl/mail
-----------------------------------------------------------------------------
И сгенерируем их следующей командой:

openssl req -new -x509 -days 1461 -nodes -out /etc/ssl/mail/public.pem -keyout /etc/ssl/mail/private.key -subj "/C=RU/ST=SPb/L=SPb/O=Global Security/OU=IT Department/CN=relay.dmosk.ru"

* сертификат сгенерирован на 1461 день, ключи subj могут быть произвольными,
CN необходимо указать в соответствии с именем сервера, по которому мы будем
подключаться к почте.
-----------------------------------------------------------------------------
Запускаем dovecot:

systemctl start dovecot
-----------------------------------------------------------------------------
6. Создаем первый почтовый ящик и проверяем работу сервера

В браузере вводим в адресной строке путь до Postfixadmin —
http://<IP-адрес сервера>/postfixadmin/.

Вводим логин и пароль от административной учетной записи, которую мы создали
на шаге 3. Перед нами появится страница управления учетными записями.
-----------------------------------------------------------------------------
Переходим в Список доменов - Новый домен:

Создаем новый домен в Postfixadmin

Заполняем формы и нажимаем по Добавить домен:

Данные домена
-----------------------------------------------------------------------------
Теперь переходим в Обзор - Создать ящик:

Создаем новый почтовый ящик через Postfixadmin
-----------------------------------------------------------------------------
Вводим данные нового пользователя и нажимаем по Создать ящик:

Заполняем данные для создания нового ящика

Теперь можно подключиться к серверу с помощью любой почтовой программы,
например, Mozilla Thunderbird.
-----------------------------------------------------------------------------
Параметры для подключения:
-----------------------------------------------------------------------------
    Сервер: имя сервера или его IP-адрес (не желательно, так как сертификат
выдается по доменному имени).
    IMAP: 143 STARTTLS или 993 SSL/TLS
    POP3: 110 STARTTLS или 995 SSL/TLS
    SMTP: 25 STARTTLS или 465 SSL/TLS или 587 STARTTLS
-----------------------------------------------------------------------------
7. Устанавливаем и настраиваем Roundcube Webmail
-----------------------------------------------------------------------------
На официальном сайте заходим на страницу загрузки Roundcube. Смотрим ссылку на
последнюю стабильную версию продукта:
-----------------------------------------------------------------------------
Скачиваем стабильную версию Roundcube

Используем ссылку, чтобы загрузить архив программы:

wget https://github.com/roundcube/roundcubemail/releases/download/1.1.9/roundcubemail-1.1.9.tar.gz
-----------------------------------------------------------------------------
Создаем каталог, где будут размещаться файлы портала:

mkdir /usr/share/nginx/html/webmail

И распаковываем скачанный архив:

tar -C /usr/share/nginx/html/webmail -xvf roundcubemail-1.1.9.tar.gz --strip-components 1
-----------------------------------------------------------------------------
Копируем шаблон конфига:

cp /usr/share/nginx/html/webmail/config/config.inc.php.sample /usr/share/nginx/html/webmail/config/config.inc.php
-----------------------------------------------------------------------------
И открываем его на редактирование:

vi /usr/share/nginx/html/webmail/config/config.inc.php

$config['db_dsnw'] = 'mysql://roundcube:roundcube123@localhost/roundcubemail';
$config['enable_installer'] = true;

* первую строку мы редактируем, а вторую добавляем. В первой строке
roundcube:roundcube123 — логин и пароль для доступа к базе данных;
localhost — сервер базы данных; roundcubemail — имя базы данных.
-----------------------------------------------------------------------------
Задаем владельца apache на папку портала:

chown -R apache:apache /usr/share/nginx/html/webmail
-----------------------------------------------------------------------------
Создаем в MariaDB базу для roundcubemail:

mysql -uroot -p

> CREATE DATABASE roundcubemail DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;

> GRANT ALL PRIVILEGES ON roundcubemail.* TO roundcube@localhost IDENTIFIED BY 'roundcube123';

> quit
-----------------------------------------------------------------------------
И загружаем в созданную базу данные:

mysql -uroot -p roundcube < /usr/share/nginx/html/webmail/SQL/mysql.initial.sql
-----------------------------------------------------------------------------
Устанавливаем компоненты, необходимые для работы Roundcube:

yum install php-pear php-mcrypt php-intl php-ldap php-pear-Net-SMTP
php-pear-Net-IDNA2 php-pear-Mail-Mime
-----------------------------------------------------------------------------
Настроим php:

vi /etc/php.ini

date.timezone = "Europe/Moscow"
-----------------------------------------------------------------------------
Перезагружаем php-fpm:

systemctl restart php-fpm
-----------------------------------------------------------------------------
Теперь открываем браузер и переходим по адресу http://<IP-адрес сервера>/webmail/installer/.
В самом низу нажимаем по кнопке Next. Если кнопка будет неактивна, проверяем,
что нет ошибок (NOT OK).

Проверяем, что все пункты находятся в состоянии OK.
-----------------------------------------------------------------------------
После удаляем папку с установочными скриптами:

\rm -R /usr/share/nginx/html/webmail/installer

И заходим в браузере по адресу http://<IP-адрес сервера>/webmail/.
-----------------------------------------------------------------------------
8. Защищаемся от вирусов
-----------------------------------------------------------------------------
Устанавливаем антивирус:

yum install clamav clamsmtp clamav-scanner-systemd clamav-update
-----------------------------------------------------------------------------
Настраиваем postfix:

vi /etc/postfix/main.cf

content_filter = scan:[127.0.0.1]:10025
receive_override_options = no_address_mappings

* где content_filter указывает на приложение, которое будет сканировать сообщения; receive_override_options позволяет увидеть оригинальные email адреса писем с вирусами.
-----------------------------------------------------------------------------
Теперь редактируем master.cf:

vi /etc/postfix/master.cf

Дописываем следующее:

scan unix - - n - 16 smtp
  -o smtp_send_xforward_command=yes
  -o smtp_enforce_tls=no

127.0.0.1:10026 inet n - n - 16 smtpd
  -o content_filter=
  -o receive_override_options=no_unknown_recipient_checks,no_header_body_checks
  -o smtpd_helo_restrictions=
  -o smtpd_client_restrictions=
  -o smtpd_sender_restrictions=
  -o smtpd_recipient_restrictions=permit_mynetworks,reject
  -o mynetworks_style=host
  -o smtpd_authorized_xforward_hosts=127.0.0.0/8
-----------------------------------------------------------------------------
Перезапускаем postfix:

systemctl restart postfix
-----------------------------------------------------------------------------
Конфигурируем clamsmtpd:

vi /etc/clamsmtpd.conf

ClamAddress: /var/run/clamd.scan/clamd.sock
TempDirectory: /var/run/clamd.scan

* где ClamAddress указываем на путь к сокетному файлу — он должен совпадать с путем в конфигурационном файле для clam scan; TempDirectory — путь для хранения временных файлов.
-----------------------------------------------------------------------------
Редактируем конфигурационный файл для clam scan:

vi /etc/clamd.d/scan.conf

PidFile /var/run/clamd.scan/clamd.pid
LocalSocket /var/run/clamd.scan/clamd.sock
User clamsmtp

* где PidFile — путь для pid-файла сервиса; LocalSocket — путь до сокетного файла для взаимодействия с clamsmtp; User — пользователь, от которого будет запускаться clamd.
-----------------------------------------------------------------------------
Редактируем владельца на каталог для сокетного файла:

chown clamsmtp:clamscan /var/run/clamd.scan
-----------------------------------------------------------------------------
Теперь разрешаем запуск антивируса и запускаем его:

systemctl enable clamsmtpd

systemctl start clamsmtpd

systemctl enable clamd@scan

systemctl start clamd@scan
-----------------------------------------------------------------------------
Обновление

Открываем конфиг freshclam и ставим комментарий напротив Example:

vi /etc/freshclam.conf

#Example
-----------------------------------------------------------------------------
Разрешаем и запускаем сервис:

systemctl enable clamd@freshclam

systemctl start clamd@freshclam
-----------------------------------------------------------------------------
Запускаем обновление:

freshclam
-----------------------------------------------------------------------------
Для настройки автоматического обновления, редактируем cron:

crontab -e

15 3 * * * /bin/freshclam

* в данном примере, каждый день в 03:15 будет запускаться процесс обновления clamav.
Проверка
-----------------------------------------------------------------------------
Для проверки отправляем сообщение со следующим содержимым:

X5O!P%@AP[4\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*

Письмо не должно дойти.
-----------------------------------------------------------------------------
9. Боремся со СПАМом
Проверка контента с помощью Spamassassin
-----------------------------------------------------------------------------
Устанавливаем spamassassin

yum install spamassassin
-----------------------------------------------------------------------------
Редактируем master.cf:

vi /etc/postfix/master.cf
-----------------------------------------------------------------------------
Для smtp добавляем следующую опцию: 

smtp      inet  n       -       n       -       -       smtpd
    -o content_filter=spamassassin

И добавить следующее:

spamassassin      unix  -       n       n       -       -       pipe
  flags=R user=spamd argv=/usr/bin/spamc -u spamd -e /usr/sbin/sendmail -f $sender $recipient

Обновляем spamassassin:

sa-update --nogpg
-----------------------------------------------------------------------------
Разрешаем его запуск и стартуем сервис:

systemctl enable spamassassin

systemctl start spamassassin

Перезапускаем postfix:

systemctl restart postfix
-----------------------------------------------------------------------------
Для автоматического обновления добавим в cron следующее:

crontab -e

30 3 * * * /bin/sa-update

* обновление будет происходить каждый день в 03:30.
-----------------------------------------------------------------------------
Для проверки работы контентного антиспама, отправляем письмо со следующим содержимым:

XJS*C4JDBQADN1.NSBN3*2IDNEN*GTUBE-STANDARD-ANTI-UBE-TEST-EMAIL*C.34X
Антиспам средствами Postfix
-----------------------------------------------------------------------------
В MTA Postfix встроен свой механизм проверки заголовков входящих сообщений.
Правила размещаются в 6 секций, обработка которых выполняется в следующем порядке:
-----------------------------------------------------------------------------
client -> helo -> sender -> relay -> recipient -> data
-----------------------------------------------------------------------------
И так, для настройки антиспама в конфигурационный файл main.cf добавляем:

vi /etc/postfix/main.cf

smtpd_client_restrictions =
        permit_mynetworks
        permit_sasl_authenticated
        reject_unauth_pipelining
        permit

smtpd_helo_restrictions =
        permit

smtpd_sender_restrictions =
        permit_mynetworks
        permit_sasl_authenticated
        reject_non_fqdn_sender
        reject_unknown_sender_domain
        permit

smtpd_relay_restrictions =
        permit

smtpd_recipient_restrictions =
        permit_mynetworks
        permit_sasl_authenticated
        reject_non_fqdn_recipient
        reject_unauth_destination
        reject_unknown_recipient_domain
        reject_unverified_recipient
        permit

smtpd_data_restrictions =
        permit

smtpd_end_of_data_restrictions =
        permit
-----------------------------------------------------------------------------
* это более или менее мягкие правила. Их можно использовать первое время, пока
тестируем сервер.
-----------------------------------------------------------------------------
Для усиления защиты добавляем:

smtpd_recipient_restrictions =
        ...
        reject_unknown_client_hostname
        reject_invalid_helo_hostname
        reject_non_fqdn_helo_hostname
        reject_unknown_helo_hostname
        reject_rbl_client bl.spamcop.net
        reject_rbl_client cbl.abuseat.org
        reject_rbl_client dul.ru
        reject_rbl_client dnsbl.abuse.ch
        permit

* где:

    reject_unknown_client_hostname — проверяет наличие PRT-записи отправителя
и наличие рабочей А-записи в соответствие PTR.
    reject_invalid_helo_hostname — проверяет синтаксис HELO-приветствия.
    reject_non_fqdn_helo_hostname — требует правильного FQDN-имени во время 
HELO-приветствия.
    reject_unknown_helo_hostname — запрещает представляться именами, для
которых нет А-записи или MX.
    reject_rbl_client — проверяет наличие отправителя в черных списках.
-----------------------------------------------------------------------------
После внесения всех правок, необходима перезагрузка Postfix:

systemctl restart postfix
-----------------------------------------------------------------------------
Сервер настроен — можно пользоваться.
-----------------------------------------------------------------------------
	Пример 2
-----------------------------------------------------------------------------
https://blog.it-svc.com.ua/2017/nastrojka-pochtovogo-servera-centos-7-postfixdovecotmysql/
-----------------------------------------------------------------------------
Настройка почтового сервера: centos 7 postfix+dovecot+MariaDB
-----------------------------------------------------------------------------
Установка нужных пакетов
-----------------------------------------------------------------------------
yum update
Версия postfix с основного репозитория Centos не включает в себя поддержку
MariaDB, вот из за этого postfix нужно установить с репозитория CentOs Plus,
для этого нужно сделать исключения для пакета postfix в [base] и [updates]
для предотвращения от записи и перезаписи пакетов без поддержки MariaDB.
-----------------------------------------------------------------------------
в файле /etc/yum.repos.d/CentOS-Base.repo внесите правки:
-----------------------------------------------------------------------------
[base]
name=CentOS-$releasever - Base
exclude=postfix

#released updates
[updates]
name=CentOS-$releasever - Updates
exclude=postfix
-----------------------------------------------------------------------------
Установим необходимые пакеты
yum --enablerepo=centosplus install postfix
yum install dovecot mariadb-server dovecot-mysql
-----------------------------------------------------------------------------
Подготовим базу для наших почтовых ящиков
Запустим и поставим в автозагрузку mariadb service
systemctl enable mariadb.service
systemctl start mariadb.service
-----------------------------------------------------------------------------
и проведем первоначальную настройку
mysql_secure_installation
Зайдем в шелл mysql
mysql -u root -p
Создадим базу, пользователя и настроем таблицы
CREATE DATABASE mymail;
USE mymail;
GRANT SELECT, INSERT, UPDATE, DELETE ON mymail.* TO 'mailuser'@'localhost' IDENTIFIED BY 'mailUserPasswd';
GRANT SELECT, INSERT, UPDATE, DELETE ON mymail.* TO 'mailuser'@'localhost.localdomain' IDENTIFIED BY 'mailUserPasswd';
FLUSH PRIVILEGES;
-----------------------------------------------------------------------------
    mymail,mailuser,mailUserPasswd — можно сменить на свои
-----------------------------------------------------------------------------
Создадим таблицу для виртуальных доменов
CREATE TABLE domains (domain varchar(50) NOT NULL, PRIMARY KEY (domain) );
Создадим таблицы для форвардинга
CREATE TABLE forwardings (source varchar(80) NOT NULL, destination TEXT NOT NULL, PRIMARY KEY (source) );
Таблица для мейл боксов
CREATE TABLE users (email varchar(80) NOT NULL, password varchar(20) NOT NULL, PRIMARY KEY (email) );
Таблица транспорта
CREATE TABLE transport ( domain varchar(128) NOT NULL default '', transport varchar(128) NOT NULL default '', UNIQUE KEY domain (domain) );
Создадим почтовый домен
INSERT INTO domains (domain) VALUES ('it-svc.com.ua');
и создадим ящик
INSERT INTO users (email, password) VALUES ('info@it-svc.com.ua', ENCRYPT('infoPasswd'));
Можно выйти с mysql шелла
-----------------------------------------------------------------------------
Перейдем к настройке нашего основного транспорта (основных служб и сервисов)
Сперва забиндим mariadb на прослушивание только локального адреса 127.0.0.1
-----------------------------------------------------------------------------
файл /etc/my.cnf
-----------------------------------------------------------------------------
пропишите
bind-address=127.0.0.1
и перезапустите сервис
systemctl restart mariadb.service
-----------------------------------------------------------------------------
настраиваем postfix для работы с mysql
создадим отдельную директорию с нашими sql настройками
-----------------------------------------------------------------------------
mkdir /etc/postfix/sql
-----------------------------------------------------------------------------
создаем настройку для доменов
/etc/postfix/sql/mysql-domains.cf


    user = mailuser
    password = mailUserPasswd
    dbname = mymail
    query = SELECT domain AS virtual FROM domains WHERE domain='%s'
    hosts = 127.0.0.1
-----------------------------------------------------------------------------
Создаем настройку для форвардинга
/etc/postfix/sql/mysql-forwardings.cf


    user = mailuser
    password = mailUserPasswd
    dbname = mymail
    query = SELECT destination FROM forwardings WHERE source='%s'
    hosts = 127.0.0.1
-----------------------------------------------------------------------------
Создаем настройку для ящиков
/etc/postfix/sql/mysql-mailboxes.cf


    user = mailuser
    password = mailUserPasswd
    dbname = mymail
    query = SELECT CONCAT(SUBSTRING_INDEX(email,'@',-1),'/',SUBSTRING_INDEX(email,'@',1),'/') FROM users WHERE email='%s'
    hosts = 127.0.0.1
-----------------------------------------------------------------------------
Создаем настройку сопоставления адресов
/etc/postfix/sql/mysql-email2email.cf


    user = mailuser
    password = mailUserPasswd
    dbname = mymail
    query = SELECT email FROM users WHERE email='%s'
    hosts = 127.0.0.1
-----------------------------------------------------------------------------
Установим права на конфигурационные файлы
chmod o= /etc/postfix/sql/*
chgrp postfix /etc/postfix/sql/*
Создаем пользователя и группу для обработки почты.
groupadd -g 5000 vmail
useradd -g vmail -u 5000 vmail -d /home/vmail -m
-----------------------------------------------------------------------------
Далее запускаем по шагово настройки конфигурации postfix Не забіваем о смене
имени hostname


    ##каждый postconf -e - новая команда###
    postconf -e 'myhostname = mail.it-svc.com.ua'
    postconf -e 'mydestination = localhost, localhost.localdomain'
    postconf -e 'mynetworks = 127.0.0.0/8'
    postconf -e 'inet_interfaces = all'
    postconf -e 'message_size_limit = 30720000'
    postconf -e 'virtual_alias_domains ='
    postconf -e 'virtual_alias_maps = proxy:mysql:/etc/postfix/sql/mysql-forwardings.cf, mysql:/etc/postfix/sql/mysql-email2email.cf'
    postconf -e 'virtual_mailbox_domains = proxy:mysql:/etc/postfix/sql/mysql-domains.cf'
    postconf -e 'virtual_mailbox_maps = proxy:mysql:/etc/postfix/mysql-mailboxes.cf'
    postconf -e 'virtual_mailbox_base = /home/vmail'
    postconf -e 'virtual_uid_maps = static:5000'
    postconf -e 'virtual_gid_maps = static:5000'
    postconf -e 'smtpd_sasl_type = dovecot'
    postconf -e 'smtpd_sasl_path = private/auth'
    postconf -e 'smtpd_sasl_auth_enable = yes'
    postconf -e 'broken_sasl_auth_clients = yes'
    postconf -e 'smtpd_sasl_authenticated_header = yes'
    postconf -e 'smtpd_recipient_restrictions = permit_mynetworks, permit_sasl_authenticated, reject_unauth_destination'
    postconf -e 'smtpd_use_tls = yes'
    postconf -e 'smtpd_tls_cert_file = /etc/pki/dovecot/certs/dovecot.pem'
    postconf -e 'smtpd_tls_key_file = /etc/pki/dovecot/private/dovecot.pem'
    postconf -e 'virtual_create_maildirsize = yes'
    postconf -e 'virtual_maildir_extended = yes'
    postconf -e 'proxy_read_maps = $local_recipient_maps $mydestination $virtual_alias_maps $virtual_alias_domains $virtual_mailbox_maps $virtual_mailbox_domains $relay_recipient_maps $relay_domains $canonical_maps $sender_canonical_maps $recipient_canonical_maps $relocated_maps $transport_maps $mynetworks $virtual_mailbox_limit_maps'
    postconf -e 'virtual_transport = dovecot'
    postconf -e 'dovecot_destination_recipient_limit = 1'
-----------------------------------------------------------------------------
генерацию своих smtpd_tls_cert_file и smtpd_tls_key_file можете посмотреть в статье
-----------------------------------------------------------------------------
http://asmodeus.com.ua/lib/%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0-postfix-tls/
-----------------------------------------------------------------------------
Уведомим postfix о том что обработкой входящих писем будет заниматься dovecot,
для этого в конец файла /etc/postfix/master.cf нужно дописать две строки
dovecot unix - n n - - pipe
flags=DRhu user=vmail:vmail argv=/usr/libexec/dovecot/deliver -f ${sender} -d ${recipient}
и немного сменим настройки связанные с авторизацией на сервере для отправки и
работой по защищенному протоколу
уберите решетки с этих строк
smtp inet n - - - - smtpd
#smtp inet n - - - 1 postscreen
#smtpd pass - - - - - smtpd
#dnsblog unix - - - - 0 dnsblog
#tlsproxy unix - - - - 0 tlsproxy
submission inet n - - - - smtpd
-o syslog_name=postfix/submission
-o smtpd_tls_security_level=encrypt
-o smtpd_sasl_auth_enable=yes
-o smtpd_client_restrictions=permit_sasl_authenticated,reject
-o milter_macro_daemon_name=ORIGINATING
smtps inet n - - - - smtpd
-o syslog_name=postfix/smtps
-o smtpd_tls_wrappermode=yes
-o smtpd_sasl_auth_enable=yes
-o smtpd_client_restrictions=permit_sasl_authenticated,reject
-o milter_macro_daemon_name=ORIGINATING
ставим postfix в автозагрузку и запускаем его
systemctl enable postfix.service
systemctl start postfix.service
-----------------------------------------------------------------------------
Настроим DOVECOT
-----------------------------------------------------------------------------
на всякий случай сохраним его стандартный конфиг
mv /etc/dovecot/dovecot.conf /etc/dovecot/dovecot.conf.old
-----------------------------------------------------------------------------
и создадим новый с следующим содержанием
-----------------------------------------------------------------------------
protocols = imap pop3
log_timestamp = "%Y-%m-%d %H:%M:%S "
mail_location = maildir:/home/vmail/%d/%n/Maildir

ssl_cert = </etc/pki/dovecot/certs/dovecot.pem
ssl_key = </etc/pki/dovecot/private/dovecot.pem

namespace {
type = private
separator = .
prefix = INBOX.
inbox = yes
}

service auth {
unix_listener auth-master {
mode = 0600
user = vmail
}

unix_listener /var/spool/postfix/private/auth {
mode = 0666
user = postfix
group = postfix
}

user = root
}

service auth-worker {
user = root
}

protocol lda {
log_path = /home/vmail/dovecot-deliver.log
auth_socket_path = /var/run/dovecot/auth-master
postmaster_address = postmaster@it-svc.com.ua
}

protocol pop3 {
pop3_uidl_format = %08Xu%08Xv
}

passdb {
driver = sql
args = /etc/dovecot/dovecot-sql.conf
}

userdb {
driver = static
args = uid=5000 gid=5000 home=/home/vmail/%d/%n allow_all_users=yes
}
-----------------------------------------------------------------------------
и создаем файл для работы с mysql
/etc/dovecot/dovecot-sql.conf
-----------------------------------------------------------------------------

    driver = mysql
    connect = host=127.0.0.1 dbname=mymail user=mailuser password=mailUserPasswd
    default_pass_scheme = CRYPT
    password_query = SELECT email as user, password FROM users WHERE email='%u';
-----------------------------------------------------------------------------
установим права владельца
-----------------------------------------------------------------------------
chgrp dovecot /etc/dovecot/dovecot-sql.conf
chmod o= /etc/dovecot/dovecot-sql.conf
ставим dovecot в автозагрузку и запускаем его
systemctl enable dovecot.service
systemctl start dovecot.service
На этом наш почтовый сервер с обязательной авторизацией и работой на защищенных
протоколах готов.
-----------------------------------------------------------------------------
	Пример 3
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
Postfix
-----------------------------------------------------------------------------
/etc/postfix/main.cf
-----------------------------------------------------------------------------
soft_bounce = no
mail_owner = postfix
queue_directory = /var/spool/postfix
command_directory = /usr/sbin
daemon_directory = /usr/libexec/postfix
default_privs = nobody
myhostname = mail-server.company.ru
mydomain = company.ru
myorigin = $mydomain
inet_interfaces = all
mydestination = localhost.$myhostname, localhost
unknown_local_recipient_reject_code = 550
local_recipient_maps = $virtual_mailbox_maps, $virtual_alias_maps
mynetworks = 127.0.0.0/8, 192.168.146.0/24
#relay_domains = $mydomain
alias_maps = hash:/etc/aliases
alias_database = hash:/etc/aliases
mail_spool_directory = /var/spool/mail
smtpd_banner = $myhostname ESMTP
debug_peer_level = 2
debug_peer_list = 127.0.0.1
debugger_command =
PATH=/bin:/usr/bin:/usr/local/bin:/usr/X11R6/bin
xxgdb $daemon_directory/$process_name $process_id & sleep 5
sendmail_path = /usr/sbin/sendmail.postfix
newaliases_path = /usr/bin/newaliases.postfix
mailq_path = /usr/bin/mailq.postfix
setgid_group = postdrop
html_directory = no
manpage_directory = /usr/share/man
sample_directory = /usr/share/doc/postfix-2.3.3/samples
readme_directory = /usr/share/doc/postfix-2.3.3/README_FILES
config_directory = /etc/postfix
virtual_mailbox_domains = mysql:$confi g_directory/sql/vdomains.cf
virtual_mailbox_base = /var/vmail
virtual_mailbox_maps = mysql:$confi g_directory/sql/vmailbox.cf
virtual_alias_maps = mysql:$confi g_directory/sql/valias.cf
virtual_minimum_uid = 1000
virtual_uid_maps = static:1000
virtual_gid_maps = static:12
virtual_transport = dovecot
dovecot_destination_recipient_limit = 1
smtpd_sasl_auth_enable = yes
smtpd_sasl_exceptions_networks = $mynetworks
smtpd_sasl_security_options = noanonymous
broken_sasl_auth_clients = yes
smtpd_sasl_type = dovecot
smtpd_sasl_path = private/auth
smtpd_recipient_restrictions = permit_mynetworks,
permit_sasl_authenticated,
reject_unauth_destination,
reject_non_fqdn_recipient,
reject_unverifi ed_recipient,
reject_rbl_client cbl.abuseat.org,
reject_rbl_client dialups.mail-abuse.org,
contentfi lter = scan:127.0.0.1:10025
receive_override_options = no_address_mappings
-----------------------------------------------------------------------------
/etc/postfix/master.cf
-----------------------------------------------------------------------------
# Postfix master process confi guration fi le.
# service type private unpriv chroot wakeup maxproc command + args
# (yes) (yes) (yes) (never) (100)
# ==========================================================
smtp inet n - n - - smtpd
-o content_fi lter=spamfilter:dummy
pickup fi fo n - n 60 1 pickup
cleanup unix n - n - 0 cleanup
qmgr fi fo n - n 300 1 qmgr
tlsmgr unix - - n 1000? 1 tlsmgr
rewrite unix - - n - - trivial-rewrite
bounce unix - - n - 0 bounce
defer unix - - n - 0 bounce
trace unix - - n - 0 bounce
verify unix - - n - 1 verify
fl ush unix n - n 1000? 0 fl ush
proxymap unix - - n - - proxymap
smtp unix - - n - - smtp
relay unix - - n - - smtp
-o fallback_relay=
showq unix n - n - - showq
error unix - - n - - error
discard unix - - n - - discard
local unix - n n - - local
virtual unix - n n - - virtual
lmtp unix - - n - - lmtp
anvil unix - - n - 1 anvil
scache unix - - n - 1 scache
maildrop unix - n n - - pipe
fl ags=DRhu user=vmail argv=/usr/local/bin/maildrop -d ${recipient}
old-cyrus unix - n n - - pipe
fl ags=R user=cyrus argv=/usr/lib/cyrus-imapd/deliver -e -m ${extension} ${user}
cyrus unix - n n - - pipe
user=cyrus argv=/usr/lib/cyrus-imapd/deliver -e -r ${sender} -m ${extension} ${user}
uucp unix - n n - - pipe
fl ags=Fqhu user=uucp argv=uux -r -n -z -a$sender - $nexthop!rmail ($recipient)
ifmail unix - n n - - pipe
fl ags=F user=ftn argv=/usr/lib/ifmail/ifmail -r $nexthop ($recipient)
bsmtp unix - n n - - pipe
fl ags=Fq. user=foo argv=/usr/local/sbin/bsmtp -f $sender $nexthop $recipient
dovecot unix - n n - - pipe
flags=DRhu user=vmail:mail argv=/usr/libexec/dovecot/deliver -d $(recipient)
scan unix - - n - 16 smtp -o smtp_send_xforward_command=yes
127.0.0.1:10026 inet n - n - 16 smtpd
-o content_fi lter=
-o receive_override_options=no_unknown_recipient_checks,no_header_body_checks
-o smtpd_helo_restrictions=
-o smtpd_client_restrictions=
-o smtpd_sender_restrictions=
-o smtpd_recipient_restrictions=permit_mynetworks,reject
-o mynetworks_style=host
-o smtpd_authorized_xforward_hosts=127.0.0.0/8
spamfilter unix - n n - - pipe
flags=Rq user=spamfi lter argv=/usr/local/bin/spamfi lter -f ${sender} -- ${recipient}
-----------------------------------------------------------------------------
/etc/postfix/sql/valias.cf
-----------------------------------------------------------------------------
user = postfix
password = password
hosts = localhost
dbname = postfix
table = alias
select_fi eld = goto
where_fi eld = address
additional_conditions = and active = '1'
query = SELECT goto FROM alias WHERE address='%s' AND active = '1'
-----------------------------------------------------------------------------
/etc/postfix/sql/vdomains.cf
-----------------------------------------------------------------------------
user = postfix
password = password
hosts = localhost
dbname = postfix
table = domain
select_fi eld = domain
where_fi eld = domain
additional_conditions = and backupmx = '0' and active = '1'
query = SELECT domain FROM domain WHERE domain='%s' AND backupmx='0'
AND active='1'
-----------------------------------------------------------------------------
/etc/postfix/sql/vmailbox.cf
-----------------------------------------------------------------------------
user = postfix
password = password
hosts = localhost
dbname = postfix
table = mailbox
select_fi eld = CONCAT(domain,'/',maildir)
where_fi eld = username
additional_conditions = and active = '1'
query = SELECT CONCAT(domain,'/',maildir) FROM mailbox WHERE username='%s'
AND active = '1'
-----------------------------------------------------------------------------
MySql
-----------------------------------------------------------------------------
# useradd -r -u 1000 -g mail -d /var/vmail -s /sbin/nologin -c “Virtual Mailbox”
vmail
# mkdir /var/vmail
# chmod 770 /var/vmail/
# chown vmail: /var/vmail/
# mkdir /etc/postfix/sql
#  service mysqld start
# /usr/bin/mysql_secure_installation
...
Set root password? [Y/n] y
...
Remove anonymous users? [Y/n] y
...
Disallow root login remotely? [Y/n] y
...
Remove test database and access to it? [Y/n] y
...
Reload privilege tables now? [Y/n] y
...
Thanks for using MySQL!
# mysql –p
mysql> CREATE DATABASE postfix;
mysql> CREATE USER 'postfix'@'localhost' IDENTIFIED BY 'password';
mysql> GRANT ALL PRIVILEGES ON `postfix`.* TO ‘postfix’@’localhost’;
mysql> \q
-----------------------------------------------------------------------------
В файле /etc/my.cnf в секцию [mysqld] добавляем строку 
bind-address=127.0.0.1
# service mysqld restart
-----------------------------------------------------------------------------
Devecot
-----------------------------------------------------------------------------
chkconfig dovecot on
-----------------------------------------------------------------------------
/etc/dovecot.conf
-----------------------------------------------------------------------------
base_dir = /var/run/dovecot/
protocols = imap pop3
protocol imap {
listen = *:143
}
protocol pop3 {
listen = *:110
}
log_timestamp = «%Y-%m-%d %H:%M:%S»
syslog_facility = mail
mail_location = maildir:/var/vmail/%d/%u
mail_debug = yes
first_valid_uid = 1000
maildir_copy_with_hardlinks = yes
protocol imap {
last_valid_uid = 1000
login_executable = /usr/libexec/dovecot/imap-login
mail_executable = /usr/libexec/dovecot/imap
imap_max_line_length = 65536
}
protocol pop3 {
login_executable = /usr/libexec/dovecot/pop3-login
mail_executable = /usr/libexec/dovecot/pop3
pop3_uidl_format = %08Xu%08Xv
}
protocol lda {
postmaster_address = postmaster@company.ru
sendmail_path = /usr/lib/sendmail
auth_socket_path = /var/run/dovecot/auth-master
}
auth_verbose = yes
auth_debug = yes
auth_debug_passwords = yes
auth default {
base_dir = /var/run/dovecot/
mechanisms = plain
passdb pam {
}
passdb sql {
args = /etc/dovecot-sql.conf
}
userdb passwd {
}
userdb sql {
args = /etc/dovecot-sql.conf
}
user = nobody
socket listen {
master {
path = /var/run/dovecot/auth-master
mode = 0660
user = vmail
group = mail
}
client {
path = /var/spool/postfix/private/auth
mode = 0660
user = postfix
group = postfix
}
}
}
dict {
}
plugin {
}
-----------------------------------------------------------------------------
/etc/dovecot-sql.conf
-----------------------------------------------------------------------------
driver = mysql
connect = host=localhost dbname=postfix user=postfix password=password
default_pass_scheme = MD5
user_query = SELECT '/var/vmail/%d/%n' as home, 'maildir:/var/vmail/%d/%n' as mail,
1000 AS uid, 12 AS gid, concat('dirsize:storage=', quota) AS quota FROM mailbox
WHERE username = '%u' AND active = '1'
password_query = SELECT username as user, password, '/var/vmail/%d/%n' asuserdb_
home, 'maildir:/var/vmail/%d/%n' as userdb_mail, 1000 as userdb_uid, 12 asuserdb_gid
FROM mailbox WHERE username = '%u' AND active = '1'
-----------------------------------------------------------------------------
Spamassasing
-----------------------------------------------------------------------------
13. Spamassassin
Работа Spamassassin основана на ряде тестов через которые прогоняется
каждое входящее письмо. Каждый тест имеет свой вес – некое целое или
десятичное число, которое добавляется в общую “копилку”. Число может быть
как положительным так и отрицательным. Если к концу всех тестов письмо
набирает больше заранее определенного лимита баллов (required_hits) то
оно помечается как SPAM и к нему применяются соответствующие меры.
В процессе своей работы Spamassassin обучается и пополняет так называемую
Bayes-базу. Bayesian классификатор пытается определить SPAM используя bayes-базу
наполненную токенами, токен – это последовательность символов или слов которые
часто встречаются в SPAM-письмах. Например, вы скормили команде sa-learn 100
SPAM-писем с повторяющимися словами “увеличение груди”, 101 сообщение которое
придет на почтовый сервер с текстом сообщения “увеличение” и “грудь” с очень
большой долей вероятности будет помечено как SPAM-письмо. Не рекомендуется сразу
удалять SPAM-письма, так как spamassassin тоже иногда ошибается. Лучше помещать
весь SPAM в отдельную папку и раз в неделю разбирать ее содержимое и уже
вручную с помощью sa-learn вносить корректировки в процесс обучения spamassassin.
-----------------------------------------------------------------------------
# yum install spamassassin
# adduser spamfilter -s /sbin/nologin
-----------------------------------------------------------------------------
Создаем файл /usr/local/bin/spamfilter с таким содержанием:
-----------------------------------------------------------------------------
#!/bin/bash
/usr/bin/spamc | /usr/sbin/sendmail.postfix -i «$@»
exit $?
-----------------------------------------------------------------------------
# chown spamfilter /usr/local/bin/spamfilter
-----------------------------------------------------------------------------
/etc/mail/spamassassin/local.cf
-----------------------------------------------------------------------------
required_hits 5
rewrite_header Subject ****SPAM****
report_safe 0
use_bayes 1
bayes_path /etc/mail/spamassassin/bayes
bayes_fi le_mode 0666
bayes_learn_to_journal 1
bayes_min_ham_num 50
bayes_min_spam_num 50
score SUBJ_FULL_OF_8BITS 0.00
score HTML_COMMENT_8BITS 0.01
score HEADER_8BITS 0.00
score TO_NO_USER 0.01
score FORGED_MUA_OUTLOOK 0.5
score X_AUTH_WARNING 0.01
score SUBJ_HAS_UNIQ_ID 9.99
score HTTP_USERNAME_USED 9.99
score FORGED_YAHOO_RCVD 9.99
score FORGED_JUNO_RCVD 16
score UNWANTED_LANGUAGE_BODY 1.02
score MLM 5.55
score RCVD_NUMERIC_HELO 4.95
ok_locales en ru
whitelist_from root@localhost
blacklist_from *@outblaze.com
auto_whitelist_path /etc/mail/spamassassin/auto-whitelist
auto_whitelist_fi le_mode 0666
trusted_networks 192.168.146.0/24
-----------------------------------------------------------------------------
# chkconfi g spamassassin on
-----------------------------------------------------------------------------
Письма бывают двух видов, ham – чистые письма и spam – незатребованная
реклама, вирусы в аттаче и т.д. Свою антиспам систему мы можем
самостоятельно обучать какие письма хорошие а какие нет. Через какое-
то время после того, как spamassassin получить достаточно информации о
типичном содержимом входящих писем, он начнет использовать полученные
знания на практике, используя их при анализе всей входящей почты. По умолчанию
требуется 200 ham-писем и 200 spam. Самостоятельно обучение
происходит командой sa-learn. Если сообщение будет по ошибке распознано
как спам мы просто запускаем команду sa-learn --ham с указанием этого письма,
и наш spamassassin учтет полученный опыт в будущем.
-----------------------------------------------------------------------------
Хорошее письмо
# sa-learn --mbox --ham <письмо>
Spam-письмо
# sa-learn --mbox --spam <письмо>
Команде sa-learn можно указать не только файл но и целый каталог.
-----------------------------------------------------------------------------
Проверка антиспама.
Отправьте письмо какому либо пользователю нашего почтового сервера с
таким содержанием:
XJS*C4JDBQADN1.NSBN3*2IDNEN*GTUBE-STANDARD-ANTI-UBE-TEST-EMAIL*C.34X
Отправить можно прямо из командной строки, например так:
-----------------------------------------------------------------------------
# mail -s “just test” tester@company.ru
вставляем нашу спам-строку, нажимаем [Enter]
Ctrl+D
[Enter]
-----------------------------------------------------------------------------
все функционирует правильно. Отправлять нужно с другого сервера.
Обновить антивирусные базы ClamAV можно командой указанной ниже.
Это специальный набор символов который используется для тестирования
антиспам-фильтра. Если пришедшее письмо определиться как спам, значит
# freshclam
-----------------------------------------------------------------------------
Clamd
-----------------------------------------------------------------------------
clamdscan /var -сканирования
-----------------------------------------------------------------------------
# yum -y install clamd
# chkconfig clamd on
-----------------------------------------------------------------------------
clamdscan 	Позволяет проверять файлы и каталоги на наличие вирусов;
clamconf 	Конфигурационная утилита ClamSV;
clamdtop 	Clam AntiVirus Daemon Monitor.
-----------------------------------------------------------------------------
/etc/clamd.conf
-----------------------------------------------------------------------------
LogFile /var/log/clamav/clamd.log
LogFileMaxSize 0
LogTime yes
LogSyslog yes
PidFile /var/run/clamav/clamd.pid
TemporaryDirectory /var/tmp
DatabaseDirectory /var/clamav
LocalSocket /var/run/clamav/clamd.sock
FixStaleSocket yes
TCPSocket 3310
TCPAddr 127.0.0.1
MaxConnectionQueueLength 30
MaxThreads 50
ReadTimeout 300
User clamav
AllowSupplementaryGroups yes
ScanPE yes
ScanELF yes
DetectBrokenExecutables yes
ScanOLE2 yes
ScanArchive yes
ArchiveBlockEncrypted no
-----------------------------------------------------------------------------
12. Clamsmtp – это SMTP-фильтр, который позволяет взаимодействовать Postfix  ClamAV.
-----------------------------------------------------------------------------
# rpm -Uvh http://www.inet.lt/clamsmtp/clamsmtp-1.10-1.src.rpm
# cd /usr/src/redhat/SPECS
# yum -y install automake autoconf
# rpmbuild -ba clamsmtp.spec
# rpm -Uvh /usr/src/redhat/RPMS/i386/clamsmtp-1.10-1.i386.rpm
# chkconfi g clamsmtpd on
-----------------------------------------------------------------------------
Конфигурационный файл /etc/clamsmtpd.conf
-----------------------------------------------------------------------------
OutAddress: 10026
TimeOut: 180
KeepAlives: 0
XClient: on
Listen: 127.0.0.1:10025
ClamAddress: /var/run/clamav/clamd.sock
Header: X-Virus-Scanned: ClamAV using ClamSMTP
TempDirectory: /tmp
Action: drop
Quarantine: on
User: clamav
-----------------------------------------------------------------------------
Обновить антивирусные базы ClamAV можно командой указанной ниже
-----------------------------------------------------------------------------
# freshclam
-----------------------------------------------------------------------------
===============
L8.UPDATE
===============
-----------------------------------------------------------------------------
kernel
-----------------------------------------------------------------------------
1. Смотрим информацию о дистрибутиве
# cat /etc/os-release
2. Узнаем версию нашего текущего ядра
#  uname -sr
# uname -a
3. официальный сайт ядра
https://www.kernel.org.
4. Подключаем репозиторий к системе:

# sudo rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org
# sudo rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm
5. Посмотрим какая версия ядра доступна
# sudo yum --disablerepo="*" --enablerepo="elrepo-kernel" list available
6. Установим версию ядра из этого репозитория
# sudo yum --enablerepo=elrepo-kernel install kernel-ml
7.Перезагрузка
# reboot
8. Проверка
# uname -sr
-----------------------------------------------------------------------------
GRUB. Чтобы новое ядро загружалось автоматически.
-----------------------------------------------------------------------------
1. etc/defaul/grub и измените значение переменной GRUB_DEFAULT на 0:
 GRUB_DEFAULT=0
по умолчанию будет использоваться первое ядро , которое находится в списке Grub.
2. Чтобы обновить конфигурацию выполните команду:
# sudo grub2-mkconfig -o /boot/grub2/grub.cfg
3.Перезагрузка
# reboot
4. Проверка
# uname -sr
-----------------------------------------------------------------------------
php/mysql
-----------------------------------------------------------------------------
2.11.1.1 Changes Affecting Upgrades to MySQL 5.7
-----------------------------------------------------------------------------
https://dev.mysql.com/doc/refman/5.7/en/upgrading-from-previous-series.html
-----------------------------------------------------------------------------
 Before upgrading to MySQL 5.7, review the changes described in this section
to identify upgrade issues that apply to your current MySQL installation and
applications.
Note

In addition to the changes outlined in this section, review the Release Notes
and other important information outlined in Before You Begin.

Changes marked as either Known issue or Incompatible change are incompatibilities
with earlier versions of MySQL, and may require your attention before you upgrade.
Our aim is to avoid these changes, but occasionally they are necessary to correct
problems that would be worse than an incompatibility between releases. If any
upgrade issue applicable to your installation involves an incompatibility that
requires special handling, follow the instructions given in the incompatibility
description. Sometimes this involves dumping and reloading tables, or use of a
statement such as CHECK TABLE or REPAIR TABLE.

For dump and reload instructions, see Section 2.11.3, “Rebuilding or Repairing
Tables or Indexes”. Any procedure that involves REPAIR TABLE with the USE_FRM 
option must be done before upgrading. Use of this statement with a version of
MySQL different from the one used to create the table (that is, using it after
 upgrading) may damage the table. See Section 13.7.2.5, “REPAIR TABLE Syntax”.

    Configuration Changes

    System Table Changes

    Server Changes

    InnoDB Changes

    SQL Changes

Configuration Changes

    Incompatible change: As of MySQL 5.7.12, the default --early-plugin-load
value is empty. To load the keyring_file plugin, you must use an explicit
--early-plugin-load option with a nonempty value.

    In MySQL 5.7.11, the default --early-plugin-load value was the name of the
keyring_file plugin library file, so that plugin was loaded by default. InnoDB
tablespace encryption requires the keyring_file plugin to be loaded prior to
InnoDB initialization, so this change of default --early-plugin-load value
introduces an incompatibility for upgrades from 5.7.11 to 5.7.12 or higher.
Administrators who have encrypted InnoDB tablespaces must take explicit action
to ensure continued loading of the keyring_file plugin: Start the server with
 an --early-plugin-load option that names the plugin library file. For additional
 information, see Section 6.5.4.1, “Keyring Plugin Installation”.

    Incompatible change: The INFORMATION_SCHEMA has tables that contain system 
and status variable information (see Section 24.10, “The INFORMATION_SCHEMA 
GLOBAL_VARIABLES and SESSION_VARIABLES Tables”, and Section 24.9, “The 
INFORMATION_SCHEMA GLOBAL_STATUS and SESSION_STATUS Tables”). As of MySQL 5.7.6,
 the Performance Schema also contains system and status variable tables 
(see Section 25.11.13, “Performance Schema System Variable Tables”, and 
Section 25.11.14, “Performance Schema Status Variable Tables”). The Performance 
Schema tables are intended to replace the INFORMATION_SCHEMA tables, which 
are deprecated as of MySQL 5.7.6 and will be removed in a future MySQL release.

    For advice on migrating away from the INFORMATION_SCHEMA tables to
 the Performance Schema tables, see Section 25.19, “Migrating to Performance
 Schema System and Status Variable Tables”. To assist in the migration, you 
can use the show_compatibility_56 system variable, which affects how system 
and status variable information is provided by the INFORMATION_SCHEMA and
 Performance Schema tables, and also by the SHOW VARIABLES and SHOW STATUS 
statements. show_compatibility_56 is enabled by default in 5.7.6 and 5.7.7, 
and disabled by default in MySQL 5.7.8.

    For details about the effects of show_compatibility_56, see Section 5.1.5,
 “Server System Variables” For better understanding, it is strongly recommended
 that you read also these sections:

        Section 25.11.13, “Performance Schema System Variable Tables”

        Section 25.11.14, “Performance Schema Status Variable Tables”

        Section 25.11.15.10, “Status Variable Summary Tables” 

    Incompatible change: As of MySQL 5.7.6, for some Linux platforms, when MySQL
 is installed using RPM and Debian packages, server startup and shutdown now is
 managed using systemd rather than mysqld_safe, and mysqld_safe is not installed.
 This may require some adjustment to the manner in which you specify server options.
 For details, see Section 2.5.10, “Managing MySQL Server with systemd”.

    Incompatible change: In MySQL 5.7.5, the executable binary version of mysql_install_db
 is located in the bin installation directory, whereas the Perl version was located
 in the scripts installation directory. For upgrades from an older version of MySQL, 
you may find a version in both directories. To avoid confusion, remove the version in
 the scripts directory. For fresh installations of MySQL 5.7.5 or later, mysql_install_db
 is only found in the bin directory, and the scripts directory is no longer present.
 Applications that expect to find mysql_install_db in the scripts directory should 
be updated to look in the bin directory instead.

    The location of mysql_install_db becomes less material as of MySQL 5.7.6 because 
as of that version it is deprecated in favor of mysqld --initialize 
(or mysqld --initialize-insecure). See Section 2.10.1.1, “Initializing the Data
 Directory Manually Using mysqld”

    Incompatible change: In MySQL 5.7.5, these SQL mode changes were made:

        Strict SQL mode for transactional storage engines (STRICT_TRANS_TABLES) is
 now enabled by default.

        Implementation of the ONLY_FULL_GROUP_BY SQL mode has been made more sophisticated, 
to no longer reject deterministic queries that previously were rejected. In consequence, 
ONLY_FULL_GROUP_BY is now enabled by default, to prohibit nondeterministic queries
 containing expressions not guaranteed to be uniquely determined within a group.

        The changes to the default SQL mode result in a default sql_mode system variable 
value with these modes enabled: ONLY_FULL_GROUP_BY, STRICT_TRANS_TABLES, NO_ENGINE_SUBSTITUTION.

        The ONLY_FULL_GROUP_BY mode is also now included in the modes comprised by the
 ANSI SQL mode. 

    If you find that having ONLY_FULL_GROUP_BY enabled causes queries for existing 
applications to be rejected, either of these actions should restore operation:

        If it is possible to modify an offending query, do so, either so that nondeterministic
 nonaggregated columns are functionally dependent on GROUP BY columns, or by referring to 
nonaggregated columns using ANY_VALUE().

        If it is not possible to modify an offending query (for example, if it is generated 
by a third-party application), set the sql_mode system variable at server startup to not 
enable ONLY_FULL_GROUP_BY. 

    For more information about SQL modes and GROUP BY queries, see Section 5.1.8,
 “Server SQL Modes”, and Section 12.19.3, “MySQL Handling of GROUP BY”. 

System Table Changes

    Incompatible change: The Password column of the mysql.user table was removed in MySQL
 5.7.6. All credentials are stored in the authentication_string column, including those 
formerly stored in the Password column. If performing an in-place upgrade to MySQL 5.7.6 or
later, run mysql_upgrade as directed by the in-place upgrade procedure to migrate the Password 
column contents to the authentication_string column.

    If performing a logical upgrade using a mysqldump dump file from a pre-5.7.6 MySQL 
installation, you must observe these conditions for the mysqldump command used to generate
 the dump file:

        You must include the --add-drop-table option

        You must not include the --flush-privileges option 

    As outlined in the logical upgrade procedure, load the pre-5.7.6 dump file into the
 5.7.6 (or later) server before running mysql_upgrade. 

Server Changes

    Incompatible change: As of MySQL 5.7.5, support for passwords that use the older pre-4.1 
password hashing format is removed, which involves the following changes. Applications that
 use any feature no longer supported must be modified.

        The mysql_old_password authentication plugin that used pre-4.1 password hash values
 is removed. Accounts that use this plugin are disabled at startup and the server writes an 
“unknown plugin” message to the error log. For instructions on upgrading accounts that use 
this plugin, see Section 6.5.1.3, “Migrating Away from Pre-4.1 Password Hashing and the 
mysql_old_password Plugin”.

        For the old_passwords system variable, a value of 1 (produce pre-4.1 hash values) 
is no longer permitted.

        The --secure-auth option to the server and client programs is the default, but is
 now a no-op. It is deprecated and will be removed in a future MySQL release.

        The --skip-secure-auth option to the server and client programs is no longer 
supported and using it produces an error.

        The secure_auth system variable permits only a value of 1; a value of 0 is no 
longer permitted.

        The OLD_PASSWORD() function is removed. 

    Incompatible change: In MySQL 5.6.6, the YEAR(2) data type was deprecated. In MySQL
 5.7.5, support for YEAR(2) is removed. Once you upgrade to MySQL 5.7.5 or higher, any 
remaining YEAR(2) columns must be converted to YEAR(4) to become usable again. For 
conversion strategies, see Section 11.3.4, “YEAR(2) Limitations and Migrating to YEAR(4)”.
 Running mysql_upgrade after upgrading is one of the possible conversion strategies.

    As of MySQL 5.7.7, CHECK TABLE ... FOR UPGRADE reports a table as needing a rebuild
 if it contains old temporal columns in pre-5.6.4 format (TIME, DATETIME, and TIMESTAMP
 columns without support for fractional seconds precision) and the avoid_temporal_upgrade
 system variable is disabled. This helps mysql_upgrade to detect and upgrade tables 
containing old temporal columns. If avoid_temporal_upgrade is enabled, FOR UPGRADE ignores
 the old temporal columns present in the table; consequently, mysql_upgrade does not upgrade them.

    As of MySQL 5.7.7, REPAIR TABLE upgrades a table if it contains old temporal columns
 in pre-5.6.4 format and the avoid_temporal_upgrade system variable is disabled. If 
avoid_temporal_upgrade is enabled, REPAIR TABLE ignores the old temporal columns present 
in the table and does not upgrade them.

    To check for tables that contain such temporal columns and need a rebuild, disable
 avoid_temporal_upgrade before executing CHECK TABLE ... FOR UPGRADE.

    To upgrade tables that contain such temporal columns, disable avoid_temporal_upgrade
 before executing REPAIR TABLE or mysql_upgrade.

    Incompatible change: As of MySQL 5.7.2, the server requires account rows in the 
mysql.user table to have a nonempty plugin column value and disables accounts with an 
empty value. This requires that you upgrade your mysql.user table to fill in all plugin 
values. As of MySQL 5.7.6, use this procedure:

    If you plan to upgrade using the data directory from your existing MySQL installation:

        Stop the old (MySQL 5.6) server

        Upgrade the MySQL binaries in place by replacing the old binaries with the new ones

        Start the MySQL 5.7 server normally (no special options)

        Run mysql_upgrade to upgrade the system tables

        Restart the MySQL 5.7 server 

    If you plan to upgrade by reloading a dump file generated from your existing MySQL
 installation:

        To generate the dump file, run mysqldump with the --add-drop-table option and
 without the --flush-privileges option

        Stop the old (MySQL 5.6) server

        Upgrade the MySQL binaries in place (replace the old binaries with the new ones)

        Start the MySQL 5.7 server normally (no special options)

        Reload the dump file (mysql < dump_file)

        Run mysql_upgrade to upgrade the system tables

        Restart the MySQL 5.7 server 

    Before MySQL 5.7.6, the procedure is more involved:

    If you plan to upgrade using the data directory from your existing MySQL installation:

        Stop the old (MySQL 5.6) server

        Upgrade the MySQL binaries in place (replace the old binaries with the new ones)

        Restart the server with the --skip-grant-tables option to disable privilege checking

        Run mysql_upgrade to upgrade the system tables

        Restart the server normally (without --skip-grant-tables) 

    If you plan to upgrade by reloading a dump file generated from your existing MySQL installation:

        To generate the dump file, run mysqldump without the --flush-privileges option

        Stop the old (MySQL 5.6) server

        Upgrade the MySQL binaries in place (replace the old binaries with the new ones)

        Restart the server with the --skip-grant-tables option to disable privilege checking

        Reload the dump file (mysql < dump_file)

        Run mysql_upgrade to upgrade the system tables

        Restart the server normally (without --skip-grant-tables) 

    mysql_upgrade runs by default as the MySQL root user. For the preceding procedures, 
if the root password is expired when you run mysql_upgrade, you will see a message that
 your password is expired and that mysql_upgrade failed as a result. To correct this, 
reset the root password to unexpire it and run mysql_upgrade again:

    shell> mysql -u root -p
    Enter password: ****  <- enter root password here
    mysql> ALTER USER USER() IDENTIFIED BY 'root-password'; # MySQL 5.7.6 and up
    mysql> SET PASSWORD = PASSWORD('root-password');        # Before MySQL 5.7.6
    mysql> quit

    shell> mysql_upgrade -p
    Enter password: ****  <- enter root password here

    The password-resetting statement normally does not work if the server is started 
with --skip-grant-tables, but the first invocation of mysql_upgrade flushes the privileges,
 so when you run mysql, the statement is accepted.

    If mysql_upgrade itself expires the root password, you will need to reset it password
 again in the same manner.

    After following the preceding instructions, DBAs are advised also to convert accounts
 that use the mysql_old_password authentication plugin to use mysql_native_password instead,
 because support for mysql_old_password has been removed. For account upgrade instructions,
 see Section 6.5.1.3, “Migrating Away from Pre-4.1 Password Hashing and the mysql_old_password Plugin”.

    Incompatible change: It is possible for a column DEFAULT value to be valid for the sql_mode
value at table-creation time but invalid for the sql_mode value when rows are
 inserted or updated. Example:

    SET sql_mode = '';
    CREATE TABLE t (d DATE DEFAULT 0);
    SET sql_mode = 'NO_ZERO_DATE,STRICT_ALL_TABLES';
    INSERT INTO t (d) VALUES(DEFAULT);

    In this case, 0 should be accepted for the CREATE TABLE but rejected for the 
INSERT. However, previously the server did not evaluate DEFAULT values used for
 inserts or updates against the current sql_mode. In the example, the INSERT succeeds 
and inserts '0000-00-00' into the DATE column.

    As of MySQL 5.7.2, the server applies the proper sql_mode checks to generate a

 warning or error at insert or update time.

    A resulting incompatibility for replication if you use statement-based logging 
(binlog_format=STATEMENT) is that if a slave is upgraded, a nonupgraded master will
 execute the preceding example without error, whereas the INSERT will fail on the 
slave and replication will stop.

    To deal with this, stop all new statements on the master and wait until the slaves
 catch up. Then upgrade the slaves followed by the master. Alternatively, if you cannot
 stop new statements, temporarily change to row-based logging on the master (binlog_format=ROW) 
and wait until all slaves have processed all binary logs produced up to the point of this 
change. Then upgrade the slaves followed by the master and change the master back to 
statement-based logging.

    Incompatible change: Several changes were made to the audit log plugin for better
 compatibility with Oracle Audit Vault. For upgrading purpose, the main issue is that 
the default format of the audit log file has changed: Information within <AUDIT_RECORD> 
elements previously written using attributes now is written using subelements.

    Example of old <AUDIT_RECORD> format:

    <AUDIT_RECORD
     TIMESTAMP="2013-04-15T15:27:27"
     NAME="Query"
     CONNECTION_ID="3"
     STATUS="0"
     SQLTEXT="SELECT 1"
    />

    Example of new format:

    <AUDIT_RECORD>
     <TIMESTAMP>2013-04-15T15:27:27 UTC</TIMESTAMP>
     <RECORD_ID>3998_2013-04-15T15:27:27</RECORD_ID>
     <NAME>Query</NAME>
     <CONNECTION_ID>3</CONNECTION_ID>
     <STATUS>0</STATUS>
     <STATUS_CODE>0</STATUS_CODE>
     <USER>root[root] @ localhost [127.0.0.1]</USER>
     <OS_LOGIN></OS_LOGIN>
     <HOST>localhost</HOST>
     <IP>127.0.0.1</IP>
     <COMMAND_CLASS>select</COMMAND_CLASS>
     <SQLTEXT>SELECT 1</SQLTEXT>
    </AUDIT_RECORD>

    If you previously used an older version of the audit log plugin, use this procedure 
to avoid writing new-format log entries to an existing log file that contains old-format entries:

        Stop the server.

        Rename the current audit log file manually. This file will contain only old-format log entries.

        Update the server and restart it. The audit log plugin will create a new log file,
 which will contain only new-format log entries. 

    For information about the audit log plugin, see Section 6.5.5, “MySQL Enterprise Audit”. 

InnoDB Changes

    Incompatible change: To simplify InnoDB tablespace discovery during crash recovery,
 new redo log record types were introduced in MySQL 5.7.5. This enhancement changes the
 redo log format. Before performing an in-place upgrade, perform a clean shutdown using 
an innodb_fast_shutdown setting of 0 or 1. A slow shutdown using innodb_fast_shutdown=0 
is a recommended step in In-Place Upgrade.

    Incompatible change: MySQL 5.7.8 and 5.7.9 undo logs may contain insufficient 
information about spatial columns, which could result in a upgrade failure (Bug #21508582).
 Before performing an in-place upgrade from MySQL 5.7.8 or 5.7.9 to 5.7.10 or higher,
 perform a slow shutdown using innodb_fast_shutdown=0 to clear the undo logs. A slow shutdown 
using innodb_fast_shutdown=0 is a recommended step in In-Place Upgrade.

    Incompatible change: MySQL 5.7.8 undo logs may contain insufficient information about 
virtual columns and virtual column indexes, which could result in a upgrade failure
 (Bug #21869656). Before performing an in-place upgrade from MySQL 5.7.8 to MySQL 5.7.9
 or higher, perform a slow shutdown using innodb_fast_shutdown=0 to clear the undo logs.
 A slow shutdown using innodb_fast_shutdown=0 is a recommended step in In-Place Upgrade.

    Incompatible change: As of MySQL 5.7.9, the redo log header of the first redo log file 
(ib_logfile0) includes a format version identifier and a text string that identifies the
 MySQL version that created the redo log files. This enhancement changes the redo log format,
 requiring that MySQL be shutdown cleanly using an innodb_fast_shutdown setting of 0 or 1 
before performing an in-place upgrade to MySQL 5.7.9 or higher. A slow shutdown using 
innodb_fast_shutdown=0 is a recommended step in In-Place Upgrade.

    In MySQL 5.7.9, DYNAMIC replaces COMPACT as the implicit default row format for InnoDB 

tables. A new configuration option, innodb_default_row_format, specifies the default InnoDB
 row format. Permitted values include DYNAMIC (the default), COMPACT, and REDUNDANT.

    After upgrading to 5.7.9, any new tables that you create will use the row format 
defined by innodb_default_row_format unless you explicitly define a row format (ROW_FORMAT).

    For existing tables that do not explicitly define a ROW_FORMAT option or that use 
ROW_FORMAT=DEFAULT, any operation that rebuilds a table also silently changes the row 
format of the table to the format defined by innodb_default_row_format. Otherwise, 
existing tables retain their current row format setting. For more information, see Section 
14.11.2, “Specifying the Row Format for a Table”. 

SQL Changes

    Incompatible change: The GET_LOCK() function was reimplemented in MySQL 5.7.5 using the
 metadata locking (MDL) subsystem and its capabilities have been extended:

        Previously, GET_LOCK() permitted acquisition of only one named lock at a time, and
 a second GET_LOCK() call released any existing lock. Now GET_LOCK() permits acquisition of
 more than one simultaneous named lock and does not release existing locks.

        Applications that rely on the behavior of GET_LOCK() releasing any previous lock
 must be modified for the new behavior.

        The capability of acquiring multiple locks introduces the possibility of deadlock
 among clients. The MDL subsystem detects deadlock and returns an ER_USER_LOCK_DEADLOCK
 error when this occurs.

        The MDL subsystem imposes a limit of 64 characters on lock names, so this limit 
now also applies to named locks. Previously, no length limit was enforced.

        Locks acquired with GET_LOCK() now appear in the Performance Schema metadata_locks 
table. The OBJECT_TYPE column says USER LEVEL LOCK and the OBJECT_NAME column indicates the lock name.

        A new function, RELEASE_ALL_LOCKS() permits release of all acquired named locks at once. 

    For more information, see Section 12.20, “Miscellaneous Functions”.

    The optimizer now handles derived tables and views in the FROM clause in consistent 
fashion to better avoid unnecessary materialization and to enable use of pushed-down 
conditions that produce more efficient execution plans. However, for statements such 
as DELETE or UPDATE that modify tables, using the merge strategy for a derived table
that previously was materialized can result in an ER_UPDATE_TABLE_USED error:

    mysql> DELETE FROM t1
        -> WHERE id IN (SELECT id
        ->              FROM (SELECT t1.id
        ->                    FROM t1 INNER JOIN t2 USING (id)
        ->                    WHERE t2.status = 0) AS t);
    ERROR 1093 (HY000): You can't specify target table 't1'
    for update in FROM clause

    The error occurs when merging a derived table into the outer query block results 
in a statement that both selects from and modifies a table. (Materialization does not
 cause the problem because, in effect, it converts the derived table to a separate table.)
 To avoid this error, disable the derived_merge flag of the optimizer_switch system 
variable before executing the statement:

    SET optimizer_switch = 'derived_merge=off';

    The derived_merge flag controls whether the optimizer attempts to merge subqueries 
and views in the FROM clause into the outer query block, assuming that no other rule
 prevents merging. By default, the flag is on to enable merging. Setting the flag to 
off prevents merging and avoids the error just described. For more information, see 
Section 8.2.2.3, “Optimizing Derived Tables and View References”.

    Some keywords may be reserved in MySQL 5.7 that were not reserved in MySQL 5.6. 
See Section 9.3, “Keywords and Reserved Words”. This can cause words previously used
 as identifiers to become illegal. To fix affected statements, use identifier quoting.
 See Section 9.2, “Schema Object Names”.

    After upgrading, it is recommended that you test optimizer hints specified in
 application code to ensure that the hints are still required to achieve the desired 

optimization strategy. Optimizer enhancements can sometimes render certain optimizer 
hints unnecessary. In some cases, an unnecessary optimizer hint may even be counterproductive.

    In UNION statements, to apply ORDER BY or LIMIT to an individual SELECT, place the
 clause inside the parentheses that enclose the SELECT:

    (SELECT a FROM t1 WHERE a=10 AND B=1 ORDER BY a LIMIT 10)
    UNION
    (SELECT a FROM t2 WHERE a=11 AND B=2 ORDER BY a LIMIT 10);

    Previous versions of MySQL may permit such statements without parentheses.
 In MySQL 5.7, the requirement for parentheses is enforced. 
-----------------------------------------------------------------------------
	Chapter 3 Upgrading MySQL with the MySQL Yum Repository
-----------------------------------------------------------------------------
https://dev.mysql.com/doc/mysql-repo-excerpt/5.6/en/updating-yum-repo.html
-----------------------------------------------------------------------------
 For supported Yum-based platforms (see Chapter 1, Installing MySQL on Linux
Using the MySQL Yum Repository, for a list), you can perform an in-place upgrade
for MySQL (that is, replacing the old version and then running the new version
off the old data files) with the MySQL Yum repository.
Notes

    Before performing any update to MySQL, follow carefully the instructions
in Upgrading MySQL. Among other instructions discussed there, it is especially
important to back up your database before the update.

    The following instructions assume you have installed MySQL with the MySQL
Yum repository or with an RPM package directly downloaded from MySQL Developer
Zone's MySQL Download page; if that is not the case, following the instructions
in Chapter 2, Replacing a Third-Party Distribution of MySQL Using the MySQL Yum Repository. 

    Selecting a Target Series

    By default, the MySQL Yum repository updates MySQL to the latest version in
the release series you have chosen during installation (see Selecting a Release
Series for details), which means, for example, a 5.6.x installation will NOT be
updated to a 5.7.x release automatically. To update to another release series,
you need to first disable the subrepository for the series that has been selected
(by default, or by yourself) and enable the subrepository for your target series.
To do that, see the general instructions given in Selecting a Release Series. For
upgrading from MySQL 5.6 to 5.7, perform the reverse of the steps illustrated in
Selecting a Release Series, disabling the subrepository for the MySQL 5.6 series
and enabling that for the MySQL 5.7 series.

    As a general rule, to upgrade from one release series to another, go to the
next series rather than skipping a series. For example, if you are currently running
MySQL 5.5 and wish to upgrade to 5.7, upgrade to MySQL 5.6 first before upgrading to 5.7.
    Important
-----------------------------------------------------------------------------
    For important information about upgrading from MySQL 5.6 to 5.7, see Upgrading
from MySQL 5.6 to 5.7.
-----------------------------------------------------------------------------
    Upgrading MySQL

    Upgrade MySQL and its components by the following command, for platforms that
are not dnf-enabled:

    sudo yum update mysql-server
-----------------------------------------------------------------------------
    For platforms that are dnf-enabled:

    sudo dnf upgrade mysql-server
-----------------------------------------------------------------------------
    Alternatively, you can update MySQL by telling Yum to update everything on your
system, which might take considerably more time; for platforms that are not dnf-enabled:

    sudo yum update
-----------------------------------------------------------------------------
    For platforms that are dnf-enabled:

    sudo dnf upgrade
-----------------------------------------------------------------------------
    Restarting MySQL
-----------------------------------------------------------------------------
    The MySQL server always restarts after an update by Yum. Once the server restarts,
run mysql_upgrade to check and possibly resolve any incompatibilities between the old
data and the upgraded software. mysql_upgrade also performs other functions; see
mysql_upgrade — Check and Upgrade MySQL Tables for details. 
-----------------------------------------------------------------------------
You can also update only a specific component. Use the following command to list
all the installed packages for the MySQL components (for dnf-enabled systems, replace
yum in the command with dnf):

sudo yum list installed | grep "^mysql"
-----------------------------------------------------------------------------
After identifying the package name of the component of your choice, for platforms
that are not dnf-enabled, update the package with the following command, replacing
package-name with the name of the package:

sudo yum update package-name
-----------------------------------------------------------------------------
For dnf-enabled platforms:

sudo dnf upgrade package-name
-----------------------------------------------------------------------------
Upgrading the Shared Client Libraries
-----------------------------------------------------------------------------
After updating MySQL using the Yum repository, applications compiled with
older versions of the shared client libraries should continue to work.
-----------------------------------------------------------------------------
If you recompile applications and dynamically link them with the updated
libraries: As typical with new versions of shared libraries where there are
differences or additions in symbol versioning between the newer and older
libraries (for example, between the newer, standard 5.6 shared client libraries
and some older—prior or variant—versions of the shared libraries shipped
natively by the Linux distributions' software repositories, or from some
other sources), any applications compiled using the updated, newer shared
libraries will require those updated libraries on systems where the applications
are deployed. And, as expected, if those libraries are not in place, the
applications requiring the shared libraries will fail. So, be sure to deploy
the packages for the shared libraries from MySQL on those systems. You can do
this by adding the MySQL Yum repository to the systems (see Adding the MySQL
Yum Repository) and install the latest shared libraries using the instructions
given in Installing Additional MySQL Products and Components with Yum. 
-----------------------------------------------------------------------------















-----------------------------------------------------------------------------
Примеры
-----------------------------------------------------------------------------
http://www.sromero.org/wiki/linux/aplicaciones/mysql/mysql57_centos7
-----------------------------------------------------------------------------
https://www.tecmint.com/install-latest-mysql-on-rhel-centos-and-fedora/
-----------------------------------------------------------------------------
alternatives
-----------------------------------------------------------------------------
Как же сделать так, чтобы система использовала эту, нужную нам, версию PHP?
-----------------------------------------------------------------------------
Сначала посмотрим на системную переменную PATH

# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin
-----------------------------------------------------------------------------

В ней перечислен список директорий, в которых ищутся программы по имени. Главный
нюанс — поиск в директориях происходит последовательно и используется первый
найденный результат. Текущий путь до текущего бинарника PHP мы можем увидеть
с помощью команды:

# which php
/usr/bin/php

-----------------------------------------------------------------------------
Как видно из PATH, /usr/local/bin находится в списке раньше, чем /usr/bin.
Значит, если мы поместим ссылку на альтернативную версию PHP “пораньше”, в
/usr/local/bin, то именно она и будет использоваться при вызове команды php
вместо /usr/bin/php. Мы можем создать эту ссылку руками (и всё даже будет работать),
но правильнее использовать специально созданную для этих целей утилиту
update-alternatives (в CentOS это просто alternatives, но есть симлинка
update-alternatives, поэтому дальше будем оперировать именно этой командой,
как универсальной для Debian/Ubuntu/CentOS/и т.д.).
-----------------------------------------------------------------------------
Теперь, давайте зарегистрируем все доступные версии PHP с помощью этой команды:

# update-alternatives --install /usr/local/bin/php php /opt/plesk/php/5.6/bin/php 10
# update-alternatives --install /usr/local/bin/php php /opt/plesk/php/7.0/bin/php 20
# update-alternatives --install /usr/local/bin/php php /usr/bin/php 30

-----------------------------------------------------------------------------
Цифры 10, 20 и 30 — это приоритет. Он работает для автоматического выбора, если
администратор сам не выбрал конкретную версию. Самое большое число определяет
выбор "по умолчанию".
-----------------------------------------------------------------------------
Проверим, что php теперь указывает на созданную командой симлинку:
-----------------------------------------------------------------------------
# update-alternatives --list | grep php
php        auto        /usr/bin/php

# update-alternatives --display php
php - status is auto.
 link currently points to /usr/bin/php
/opt/plesk/php/5.6/bin/php - priority 10
/opt/plesk/php/7.0/bin/php - priority 20
/usr/bin/php - priority 30
Current `best' version is /usr/bin/php.

-----------------------------------------------------------------------------
Давайте разберемся, что же update-alternatives сделала для нас:

# which php
/usr/local/bin/php
# ls -l /usr/local/bin/php
lrwxrwxrwx. 1 root root 21 Jul  2 10:03 /usr/local/bin/php -> /etc/alternatives/php
# ls -l /etc/alternatives/php
lrwxrwxrwx. 1 root root 26 Jul  2 10:03 /etc/alternatives/php -> /usr/bin/php
-----------------------------------------------------------------------------

Как видно, она создала цепочку симлинок и теперь по требованию просто меняет
промежуточную симлинку на нужный нам бинарь.
-----------------------------------------------------------------------------
# php -v
PHP 5.4.16 (cli) (built: May 12 2016 13:45:17)
...

-----------------------------------------------------------------------------
То есть, мы успешно настроили группу PHP в update-alternatives, где по
умолчанию в автоматическом режиме выбран системный PHP. Сейчас у нас есть
возможность переключить команду PHP на любую другую версию..
-----------------------------------------------------------------------------
Давайте переключимся на PHP версии 5.6, которая идет в поставке с Plesk'ом:

# update-alternatives --config php

There are 3 programs which provide 'php'.

  Selection    Command
-----------------------------------------------
   1           /opt/plesk/php/5.6/bin/php
   2           /opt/plesk/php/7.0/bin/php
*+ 3           /usr/bin/php

Enter to keep the current selection[+], or type selection number: 1


Проверяем, что переключение произошло:
-----------------------------------------------------------------------------
# php -v
PHP 5.6.22 (cli) (built: May 27 2016 11:45:28)
…
# update-alternatives --display php
php - status is manual.
 link currently points to /opt/plesk/php/5.6/bin/php
… 
-----------------------------------------------------------------------------

Все отлично работает. Теперь в системе используется нужная нам версия PHP и
я не опасаюсь, что эта настройка слетит при следующих пакетных обновлениях.
-----------------------------------------------------------------------------
С помощью update-alternatives можно выбирать не только версию PHP, но и
многие другие вещи, например разные версии phpunit или редактор по умолчанию
в системе. Подход этот универсален для различных систем. Не изобретая своего
велосипеда, используя существующие инструменты, вы можете быть уверенным,
что не устроили для ваших коллег квеста “Ну почему оно так работает?!”.
Настраивайте свою систему правильно. 
-----------------------------------------------------------------------------
	Дополнение
-----------------------------------------------------------------------------
 А вот бы еще придумать, как для каждого пользователя (или даже в разных
каталогах одного пользователя) иметь свою версию PHP включенной.
-----------------------------------------------------------------------------
 У update-alternatives есть возможность задать альтернативные директории для
конфигов и симлинок. Через /etc/profile.d можно добавить уникальный кастомный
путь в PATH для каждого пользователя. Для простоты использования
update-alternatives --altdir.. --admindir.. можно завернуть в алиас для
пользователя через тот же /etc/profile.d. Таким образом каждый пользователь
сможет менять дефолтную версию PHP для себя. Скорее всего, при создании
пользователя, директории нужно будет создавать отдельно каким-нибудь костылем :)
-----------------------------------------------------------------------------
Структурой домашней директории можно через /etc/skel управлять без костылей.
Самый простой и старый механизм — переопределить $PATH персональной директорией со ссылками:

        echo export PATH=$HOME/bin:'$PATH' >> ~/.profile
        ln -s /opt/plesk/php/5.6/bin/php $HOME/bin/php

Конечно, не так красиво, как вызов update-alternatives с флагами, но, по
большому счету, к этому и сводится в итоге.
-----------------------------------------------------------------------------
	Установка PHP 5.6 + PHP 7.1 на Debian 8 + nginx
-----------------------------------------------------------------------------
https://anton-pribora.ru/articles/nginx/debian-php5_6-and-php7_1/
-----------------------------------------------------------------------------
Установка репозитория deb.sury.org

Чтобы установить репозиторий, нужно от супер-пользователя выполнить следующие действия:

apt-get install apt-transport-https ca-certificates
wget -O /etc/apt/trusted.gpg.d/php.gpg https://packages.sury.org/php/apt.gpg
echo "deb https://packages.sury.org/php/ jessie main" > /etc/apt/sources.list.d/php.list
apt-get update

После этого будут доступны пакеты php5.6-xxx и php7.1-xxx. Стандартные дебиановские
пакеты php5-xxx также будут доступны, но их лучше удалить, чтобы не было конфликтов.
Сделать это можно одной командой:

apt-get purge 'php.*'
-----------------------------------------------------------------------------
Установка новых версий PHP

Выполняем следующие команды установки:

# Установка PHP 5.6
apt-get install php5.6-cli php5.6-curl php5.6-fpm php5.6-gd php5.6-intl
php5.6-json php5.6-mbstring php5.6-mcrypt php5.6-pdo-mysql php5.6-xml php5.6-zip

# Установка PHP 7.1
apt-get install php7.1-cli php7.1-curl php7.1-fpm php7.1-gd php7.1-intl
php7.1-json php7.1-mbstring php7.1-mcrypt php7.1-pdo-mysql php7.1-xml php7.1-zip


-----------------------------------------------------------------------------
Установка NGINX

Выполняем следующую команду:

apt-get install nginx

Теперь отключаем дефолтный конфиг и подключаем папку /www:

unlink /etc/nginx/sites-enabled/default
echo 'include /www*/*/conf/nginx.conf;' > /etc/nginx/sites-enabled/www

Настройка default-хоста

Создаём папки, необходимые для работы:

mkdir -p /www/default/docs /www/default/logs /www/default/conf

Добавляем конфиг /www/default/conf/nginx.conf:

server {
    listen *:80 default_server;
    server_name default;

    root       /www/default/docs;
    access_log /www/default/logs/access.log;
    error_log  /www/default/logs/error.log;
    
    set $phpini "
        error_log=/www/default/logs/php-errors.log
    ";

    index index.php index.html;

    location ~ ^(.*\.php)$ {
        include fastcgi_params;
        fastcgi_pass unix:/run/php/php5.6-fpm.sock;
    
        if ($arg_php7) {
            fastcgi_pass unix:/run/php/php7.1-fpm.sock;
        }
        
        fastcgi_param PHP_VALUE "$phpini";
        fastcgi_param SCRIPT_FILENAME $document_root$1;
    }
}

Перезапускаем nginx:

service nginx reload

Создаём /www/default/docs/index.php:

echo '<?php phpinfo();' > /www/default/docs/index.php

Проверяем результат:

> wget -qO- 'http://localhost/' | grep -oE 'PHP Version [0-9\.]+'
PHP Version 5.6.30
> wget -qO- 'http://localhost/?php7=1' | grep -oE 'PHP Version [0-9\.]+'
PHP Version 7.1.4


-----------------------------------------------------------------------------

-----------------------------------------------------------------------------

-----------------------------------------------------------------------------

-----------------------------------------------------------------------------

-----------------------------------------------------------------------------

 
===============
L9.MONITORING
===============
-----------------------------------------------------------------------------
Nagios (Check_MK)
-----------------------------------------------------------------------------
Supervisord
-----------------------------------------------------------------------------
backup сайта по ssh
-----------------------------------------------------------------------------
Исходные данные для backup
-----------------------------------------------------------------------------
Итак, имеем:

    Linux\UNIX хостинг с доступом по SSH, адрес хоста: ssh.host.example
    Компьютер с Windows, с помощью которого производим администрирование сайта.
    командный интерфейс plink, который поставляется с ssh клиентом PuTTY
    доступ в интернет для связи 1го и 2го.
    имя пользователя на хостинге: user
    пароль: P@sswOrd
    каталог, где размещены файлы сайта: /var/www/host.example

-----------------------------------------------------------------------------
Проблема backup
-----------------------------------------------------------------------------
    Очень часто, размещая сайт на хостинге, хостер предъявляет высокие
требования и лимиты к операциям ввода-вывода на диск. В результате, при
создании резервной копии в ssh консоли хостинга, процесс зашкаливающий по
лимитам хостинга может быть убит и архив получится битый.
    Так же, типичная ситуация, когда у тебя файлы сайта занимают 70-80%
дискового пространства, предоставленного хостингом, и при создании архива
из ssh консоли хостинга - для полного архива не хватает места.
    Дополнительно, хостер может убивать процессы, которые создают большую
нагрузку на CPU. Это тоже приведет к некорректно созданному архиву.
    Для создания архива с Windows машины необходимо проделать кучу действий:
1. подключиться к консоли по ssh,
2. создать архив,
3. подключиться SCP/SFTP клиентом,
4. скопировать файл архива,
5. удалить архив. Тут же мы выполняем все это одной командой.

-----------------------------------------------------------------------------
Решение проблемы backup через plink
-----------------------------------------------------------------------------
В общем, ранее меня эти проблемы не напрягали, т.к. бэкап нужно было делать не
часто, а когда я стал дорабатывать блог, то оперативные архивы стали очень
необходимы и я стал искать решения. Я знал, что подключаясь из Linux - это
делается элементарно, через pipe. Поэтому я стал искать аналогию на Windows.
В конечном счете, необходимо было выполнить команду на удаленном сервере,
которая создаст архив и сложит его в локальную папку на клиенте. Долго искать
не пришлось - мне помог plink. Как говориться, все гениальное - просто: качаем
putty и plink. Выполняем следующие действия, открыв cmd в каталоге с plink.exe:
-----------------------------------------------------------------------------
 c:\PuTTY_folder>plink -pw P@sswOrd user@ssh.host.example tar czf - /var/www/host.example > c:\backup_by_plink\backup_of_my_site.tar.gz
-----------------------------------------------------------------------------
Здесь:

    plink - собственно, сам exe'шник
    -pw P@sswOrd - пароль к учетной записи user
    user@ssh.host.example - имя пользователи и хост, на котором буде выполнены
программа tar czf - /var/www/host.example - собственно, исполняемая программа
(читаем основные команды linux). Указывая "-" мы говорим tar'y выводить архив
на консоль (вернее stdout). 
> - символ командной строки Windows, осуществляющий перенаправление вывода
команды в файл (аналог pipe в Linux)
    c:\backup_by_plink\backup_of_my_site.tar.gz - место сохранения архива.

Т.о. мы решаем все 4 проблемы. При этом, если отключим компрессию (ключ z), то
практически снизим нагрузку на CPU на хостинге.

-----------------------------------------------------------------------------
rsync
-----------------------------------------------------------------------------
https://serveradmin.ru/rsync-nastroyka-bekapa-na-centos-debian-ubuntu/
-----------------------------------------------------------------------------
Возможности
-----------------------------------------------------------------------------
Rsync (Remote Synchronization) — с помошью этой программы происходит
копирование файлов между серверами, пришла на замену rcp.
centos52 — сервер куда будем делать бекап
unixbox — сервер с которого будем делать бекап
На сервере unixbox создадим пользователя rsync от которого будут
запрашиваться файлы для бекапа.
-----------------------------------------------------------------------------
Добавим пользователя rsync и установим ему пароль.
# useradd rsync
# passwd rsync
Добавим его в нужные группы чтобы он мог получить право на чтение если
такого еще нет.
-----------------------------------------------------------------------------
Скопируем каталог /etc с сервера unixbox в наш локальный каталог /var/backup
-----------------------------------------------------------------------------
$ rsync -e ssh -avz --delete-after --force rsync@unixbox:/etc /var/backup/
-----------------------------------------------------------------------------
Вводим пароль и все.
-----------------------------------------------------------------------------
Если хочется процедуру автоматизировать то нужно будет сгенерировать
public ключ на сервере centos52 и положить его в файл authorized_keys
пользователю rsync на сервере unixbox. Давайте сделаем это.
-----------------------------------------------------------------------------
# ssh-keygen -t rsa
# ssh-copy-id -i ~/.ssh/id_rsa.pub rsync@unixbox
-----------------------------------------------------------------------------
Все. Теперь можно поместить выполнение команды в crontab
-----------------------------------------------------------------------------
# crontab -e
* */4 * * * rsync -e ssh -avz --delete-after --force rsync@unixbox:/etc /var/backup
-----------------------------------------------------------------------------
Каждые 4 часа будем копировать каталог /etc с сервера unixbox в локальный
каталог /var/backup
-----------------------------------------------------------------------------
Пояснения
-----------------------------------------------------------------------------
Внимание: если после /etc нет “/” то будет скопирован сам каталог и его
содержимое. Если “/” есть, то будет скопировано только содержимое этого
каталога.
-----------------------------------------------------------------------------
-e ssh – этим ключем мы показываем что будем использовать ssh, то есть наш
трафик будет шифроваться;
-----------------------------------------------------------------------------
-a – работа в режиме архивирования, сохраняются права доступа и
информация о владельцах;
-----------------------------------------------------------------------------
-v – выводить больше информативной информации;
-----------------------------------------------------------------------------
-z – архивировать передаваемые данные;
-----------------------------------------------------------------------------
--delete-after – удалять файлы которые отсутствуют в источнике после того
как закончится передача файлов по сети. Мы хотим иметь полную копию
контента с удаленного сервера. Можете включать эту опцию периодически.
Вдруг кто-нибудь случайно удалит файл на удаленном сервере и во время
-----------------------------------------------------------------------------
rsyncd
-----------------------------------------------------------------------------
Также есть сервис – rsyncd который работает на порту 873 TCP. При
запущенном сервисе строка доступа может выглядеть так:
-----------------------------------------------------------------------------
rsync://[USER@]HOST[:PORT]/SRC [DEST]
-----------------------------------------------------------------------------
то есть в начале будет добавлено rsync:// а остальное также как и в примере
выше. Аутентификация в rsyncd основана на 128 bit MD4, что очень не
надежно в наше время. К тому же данные передаются в открытом виде, что
явно не в пользу этого сервиса, когда есть такие средства как rsync+ssh и scp.
Поэтому подробно рассматривать его не вижу смысла.
ближайшей синхронизации мы удалим его тоже;
-----------------------------------------------------------------------------
--force – не удалять директорию пока в ней есть файлы.
-----------------------------------------------------------------------------
Скрипт в помощь
-----------------------------------------------------------------------------
Этого материала достаточно чтобы начать пользоваться rsync в создание
своих файловых зеркал/резервных копий. Ниже я дам пример скрипта,
который может помочь когда нужно копировать набор каталогов с
#!/bin/bash
#backup.sh
LIST=/var/backup/backup.list
cat ${LIST} | while read res; do
rsync -e ssh -avz --delete-after --force rsync@unixbox:$res /var/backup
done
Файл /var/backup/backup.list должен содержать список каталог для
копирования. Примерно так:
/etc
/var/www/cms
/usr/local/etc
/var/billing
-----------------------------------------------------------------------------
Пример
-----------------------------------------------------------------------------
# rsync -ravh --exclude 'dbconn.php' --exclude '.settings.php' root@88.99.47.51:/home/bitrix/www/ /home/bitrix/www/
-----------------------------------------------------------------------------
Veeam
-----------------------------------------------------------------------------
Бэкап и перенос linux (centos, debian, ubuntu) сервера с помощью Veeam Agent for Linux
-----------------------------------------------------------------------------
https://serveradmin.ru/backup-i-perenos-linux-servera/
-----------------------------------------------------------------------------
Мониторинг Сети
-----------------------------------------------------------------------------
            ethtool interface - отобразить физическую статистику интерфейса interface;
-----------------------------------------------------------------------------
            ping host – пропинговать host и вывести результат
-----------------------------------------------------------------------------
            whois domain – получить информацию whois для domain
-----------------------------------------------------------------------------
            traceroute host - трассировка маршрута до определенного хоста
-----------------------------------------------------------------------------
            ifconfig eth0 - отображение/настройка параметров сетевого интерфейса etho (либо
 			другого, если без указания интерфейса - отобразит конфигурацию всех
 		интерфейсов)
                inet ip.add.re.s - задание ip адреса интерфейса (TCP/IP)
                mask xxx.xxx.xxx.xxx - задание маски подсети интерфейса
                broadkast xxx.xxx.xxx.xxx - задание широковещательного адреса интерфейса
                up - запустить интерфейс
                down - остановить интерфейс
                -a - отображение всех железных интерфейсов (в том числе и не поднятых и
 			поднятых)
-----------------------------------------------------------------------------
            route - отображение таблицу маршрутизации
                -n - не резолвить имена в адреса
                add destination gw gateway metric metric - добавить маршрут (add) для
 		destination (адрес назначения), IP адрес шлюза (gw) - gateway, с метрикой
 			metric
                    add -net -указание добавить маршрут для сети
                    add - host -указание добавить маршрут для хоста
                del destination - удалить маршрут с назначением destination
-----------------------------------------------------------------------------
            mtr host - отображение статистики трассировки до хоста host (красивее чем
 			трасероут :) )
-----------------------------------------------------------------------------
            netcat host port - просмотр, кто слушает порт
-----------------------------------------------------------------------------
            nc - TCP/IP швейцарсий нож :)
                -h - отобразить помощь
                -l port - прослушивать локальный порт port для входящих соединений.
-----------------------------------------------------------------------------
            netstat -отображение статистики сети
                -r - таблица маршрутизации
                -n - без разрешения IP адресов в имена и сетевых портов в названия
                -a - состояние всех (во всех состояниях) соединений на локальной машине
                -t - статистика по протоколу TCP
                -u - статистика по протоколу UDP
                -i - отобразить статистику сетевых интерфейсов
                -l - просмотр сокетов, слушающих (LISTEN) соединения (ожидающих соединения)
                -p - отобразить имя программы и PID (process ID), с которой взаимодействует
 		сокет
-----------------------------------------------------------------------------
            nmap host - просканировать порты на хосте host
                -p ports - просканировать указанные порты
                -o - определить ОС при сканировании порта
-----------------------------------------------------------------------------
            tcpdump - анализатор заголовков пакетов
                -n - не преобразовывать IP в DNS
                -i interface - указать какой интерфейс слушать
                port nn - указать вывод только nn порта
                -w file - сохранять вывод в файл file
-----------------------------------------------------------------------------
Слушаем весь трафик для MAC-адреса 00:a0:80:00:2f:fe на интерфейсе eth1
# tcpdump -n -i eth1 ≪ether host 00:a0:80:00:2f:fe≫
Слушаем трафик для определенного ip-адреса и порта 
# tcpdump -nn host 192.168.146.130 and port 22
-----------------------------------------------------------------------------
            wget file – скачать file
                -c – продолжить остановленную закачку
-----------------------------------------------------------------------------
            dig domain – получить DNS информацию о domain
                -x 1.2.3.4 – реверсивно искать данные о хосте 1.2.3.4 (то есть найти данные
 		для 4.3.2.1.in-addr.arpa.)
                @ns.server - источником информации о DNS - использовать ns.server
                SOA|MX|A|NS - указать тип получаемой записи
                +short - получение коротких отчетов
                +nocomments - отключить комментарии в отчете
                +trace - включение трассировки поиска запрашиваемого значения
                -f file - запуск построчно команды dig с параметрами, указанными в каждой
 			строке файла file
-----------------------------------------------------------------------------
            named-checkzone zone_name /file/name/zone - проверяет синтаксис файла зоны
 					/file/name/zone
-----------------------------------------------------------------------------
            named-checkconf- проверяет синтаксис файла named.conf
                -z - проверка named.conf с проверкой корректности файлов зон
-----------------------------------------------------------------------------
            nslookup- интерактивные запросы к DNS
                host - отобразить основные (A и MX) записи хоста host
                -debug - включить режим отладки
                -type=SOA|MX|A.... - вывод указанного типа ресурсной записи
                host ns.server - получить информацио о хосте host с DNS сервера ns.server
-----------------------------------------------------------------------------
            host domain - получить DNS информацию о домене domain
                -a - вывести все записи зоны
                -d - отладка
                -t A|MX... - указание типа ресурсной записи
                -v - вывод подробной информации
                host ns.server - узнать информацию о хосте host  с DNS сервера ns.server
-----------------------------------------------------------------------------
PTR
dig -x 2001:67c:25dc:80::53b
----------------------------------------------------------------------------------
dig dolina-67c_25dc_80_53b.dolina.rx-name.net AAAA
----------------------------------------------------------------------------------
dig openstorekiev.com.ua any +trace
----------------------------------------------------------------------------------
Подробно dig
https://www.reg.ru/nettools/dig?domain
----------------------------------------------------------------------------------
Подробности регистрации
https://www.namecheap.com/domains/whois/results.aspx?domain=openstorekiev.com.ua
----------------------------------------------------------------------------------
whois site.com
----------------------------------------------------------------------------------
curl -v site.com
----------------------------------------------------------------------------------
https://2ip.ua/ua/
----------------------------------------------------------------------------------
Трансфер 3 дня на авторизацию.
http://wiki.drs.ua/UAEPP
http://dig.ua/
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------

-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
===============
L10.SCRIPTING
===============
-----------------------------------------------------------------------------
Bash
-----------------------------------------------------------------------------
Python
-----------------------------------------------------------------------------

########
#DevOps
########
======================
D1.CI/CD
======================
-----------------------------------------------------------------------------
Teamcity
-----------------------------------------------------------------------------
Jenkins
-----------------------------------------------------------------------------
======================
D2.Automatisation
======================
-----------------------------------------------------------------------------
Ansible
-----------------------------------------------------------------------------
Chef
-----------------------------------------------------------------------------
======================
D3.Repositariy
======================
-----------------------------------------------------------------------------
Git
----------------------------------------------------------------------------------
    На Unix системах достаточно открыть терминал и перейти в нужную директорию.
----------------------------------------------------------------------------------
Клонирование репозитария
	git clone https://github.com/%user_login%/%repo_name%.git 
Переходим в свежесозданную папку репозитория и настраиваем его:
	git config user.name ivan.ivanov
	git config user.email ivanov@example.com
Статус	
	git status
После изменений
	git add %file_path%
Коммит
	git commit -m "%commit_message%"
История изменений
	git log или git log --name-only
Загрузка локальных изменений в удаленный репозиторий
	git push origin master.
Выполнение этой команды может закончиться с ошибкой, если в локально репозитории отсутствуют последние изменения, имеющиеся в удаленном репозитории.
Для решения этой проблемы надо выполнить команду git pull, которая скачает последние изменения из удаленного репозитория и смержит их с вашими локальными правками, после чего можно повторить команду 		git push
----------------------------------------------------------------------------------
cat .git/config
[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
[remote "origin"]
	url = https://github.com/ara7788/Console.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[branch "master"]
	remote = origin
	merge = refs/heads/master
[user]
	name = ara7788
	email = test3007@ya.ru
[credential]
        helper = cache --timeout=3600
[color]
	branch = auto
        diff = auto
        interactive = auto
        status = auto
        ui = auto OR ui = true
----------------------------------------------------------------------------------
[alias]
    cd = checkout
    dir = branch
    mersq = merge --squash
    free = branch -D

----------------------------------------------------------------------------------
А теперь посмотрим что мы сделали:
Без модификаций

git pull --rebase
git branch
git checkout temp
git add -u
git commit
git merge master
git checkout master
git merge --squash temp
git commit
git push
git branch -D temp


С модификациями

git pull --rebase
git dir
git cd temp
git add -u
git commit
git merge master
git cd master
git mersq temp
git commit
git push
git free temp

----------------------------------------------------------------------------------
[commit]
        template = ~/.commit-template
----------------------------------------------------------------------------------
Префиксы для remote

Есть один трюк, который нередко используется разработчиками. Это префиксы для remote. 
Они позволяют сократить длину адреса к удаленному репозиторию.
Можно задать такие для read-only и push. Зачем? Это логично для open-source проектов.
Для уменшения нагрузки на сервер и скорости, лучше pull'ить из anongit (read-only) без использования SSH.
Что стоит у меня для KDE?

[url "http://anongit.kde.org/"]
    insteadOf = kde:
[url "git@git.kde.org:"]
    pushInsteadOf = kde:

Давайте разбираться. Тут мы настроили два URL для pull и push. Задали префикс kde.
Что это нам дает? Посмотрим на примере (в статье не указан префикс gh — для GitHub):
Без модификаций 	С модификациями

git clone http://anongit.kde.org/marble
git clone https://github.com/user/repository

git clone kde:marble
git clone gh:user/repository
----------------------------------------------------------------------------------
Как выписать репозиторий с github
----------------------------------------------------------------------------------
	Создаем новую директорию для проекта project_name, переходим в нее.
	Выполняем команду:

git clone git@github.com:devlabuser/sharp.git ./

	“./” означает, что создать репозиторий нужно в текущей директории.
	Результат: каталог с выписанной веткой master. Теперь можно создавать новые
ветки, или выписывать с github существующие.
---------------------------------------------------------------------------------- 
Как выписать ветку с github
----------------------------------------------------------------------------------
С помощью команды “checkout” можно выписать уже существующую ветку с github:

$ git checkout -b dev origin/dev
$ git checkout -b project_branch origin/project_branch

	
$ git checkout -b dev origin/dev
$ git checkout -b project_branch origin/project_branch

Или так, что намного надежнее:
$ git checkout --track origin/production


Если команда не сработала, нужно попробовать выполнить обновление:
$ git remote update


Если вышеприведенные команды не сработали, выдали ошибку, и времени разбираться с ней нет,
можно попробовать получить нужную ветку следующим способом:

$ git checkout -b project_branch
$ git pull origin project_branch

Т.е. сначала мы создаем новую ветку, а затем вливаем в нее изменения из ветки на github.
---------------------------------------------------------------------------------- 
Как создать новую ветку в локальном репозитории
----------------------------------------------------------------------------------
$ git checkout -b dev	Создаем новую ветку в локальном репозитории
$ git push origin dev	Публикуем ее на github
---------------------------------------------------------------------------------- 
Как переключиться на другую ветку в git
----------------------------------------------------------------------------------
$ git checkout project2_branch
----------------------------------------------------------------------------------
Если вы случайно удалили какой-то файл, можно извлечь его из хранилища:
----------------------------------------------------------------------------------
$ git checkout readme.txt
---------------------------------------------------------------------------------- 
Как посмотреть список веток
----------------------------------------------------------------------------------
Команда “branch” позволяет посмотреть список веток в локальном репозитории.
Текущая ветка будет помечена звездочкой:

$ git branch
* dev
  master
----------------------------------------------------------------------------------
Как сделать commit
----------------------------------------------------------------------------------
	Создаем новую ветку, выполняем в ней нужные изменения.

$ git status			Список всех измененных и добавленных файлов можно просмотреть командой
$ git add <file1> <file2> ...	Подготавливаем коммит, добавляя в него файлы командой
$ git rm <file1> <file2> ...	Или удаляем устаревшие файлы
$ git commit -m 'Комментарий к коммиту'	Выполняем коммит

    Как правило, в репозитории существует две основные ветки – dev и master.
Dev – общая ветка разработчиков и тестировщиков. Именно в нее добавляются все новые разработки перед очередным релизом. Master – ветка для выкладки продукта
на боевые сервера.

    После коммита надо влить в нашу ветку изменения из ветки dev и master:

$ git pull origin dev 
$ git pull origin master

    Теперь наша ветка содержит изменения для проекта, и все последние изменения по другим задачам, которые успела внести команда.
    Переключаемся на ветку dev:

$ git checkout dev

    Вливаем в dev изменения из ветки проекта:

$ git merge project_branch

    Заливаем последнюю версию ветки dev на удаленный сервер:

$ git push origin dev

    push может не пройти, потому что удалённый origin/dev обогнал локальную его копию.

----------------------------------------------------------------------------------
Как решить конфликт бинарных файлов
----------------------------------------------------------------------------------
Допустим, при слиянии с другой веткой git выдал ошибку.
Команда git status возвращает информацию о конфликте:

$ git status

$ git diff root/css/styles.css.gz

Конфликтный файл является бинарным (это могут быть архивные файлы, изображения и т.п.),
и решение конфликта стандартным способом, с помощью редактирования – не возможно.

Чтобы решить такой конфликт, надо просто выбрать – какая версия файла будет использоваться:
ваша или из вливаемой ветки. Чтобы использовать свой вариант файла, вводим команду:

$ git checkout --ours binary.dat
$ git add binary.dat

Если мы выбираем версию из вливаемой ветки:

$ git checkout --theirs binary.dat
$ git add binary.dat

---------------------------------------------------------------------------------- 
Как посмотреть историю изменений
----------------------------------------------------------------------------------
$ git log			просмотр логов
$ git log --pretty=oneline	Вывод данных о каждом коммите в одну строку
$ git log | grep -e "first"	Поиск по ключевому слову в комментариях к коммиту
 
$ git show 99452d955bdb57e7e4f2b09f8ce2fbb6cd56377a	Команда “git show” позволяет 
							просмотреть, какие именно
							изменения произошли в указанном
							коммите

$ git blame README.md		Можно посмотреть построчную информацию о последнем
				коммите, имя автора и хэш коммита

$ git annotate readme.txt	выводит измененные строки и информацию о коммитах,

---------------------------------------------------------------------------------- 
Как сделать откат
----------------------------------------------------------------------------------
$ git log	просмотр логов, показывает дельту (разницу/diff), привнесенную каждым коммитом.

    Копируем идентификатор коммита, до которого происходит откат.
    Откатываемся до последнего успешного коммита (указываем последний коммит):

$ git reset --hard 9a452d955bdb57e7e4f2b09f8ce2fbb6cd56377a

    Можно откатить до последней версии ветки:

$ git reset --hard origin/dev

	После того, как откат сделан, и выполнен очередной локальный коммит, при
	попытке сделать push в удаленный репозиторий, git может начать ругаться, что версия 	вашей ветки младше чем на github и вам надо сделать pull.
	Это лечится принудительным коммитом:

$ git push -f origin master
---------------------------------------------------------------------------------- 
Как выполнить слияние с другой веткой
----------------------------------------------------------------------------------
	git merge выполняет слияние текущей и указанной ветки.
		Изменения добавляются в текущую ветку.

$ git merge origin/ticket_1001_branch

	git pull забирает изменения из ветки на удаленном сервере и проводит
		слияние с активной веткой.

$ git pull origin ticket_1001_branch

	git pull отличается от git merge тем, что merge только выполняет слияние
		веток, а pull прежде чем выполнить слияние – закачивает изменения
		с удаленного сервера.
		
		merge удобно использовать для слияния веток в локальном репозитории,
		pull – слияния веток, когда одна из них лежит на github.

---------------------------------------------------------------------------------- 
Создание нового локального репозитория
----------------------------------------------------------------------------------
$ mkdir project_dir
$ cd project_dir
$ git init

---------------------------------------------------------------------------------- 
git cherry-pick
----------------------------------------------------------------------------------
git cherry-pick помогает применить один-единственный коммит из одной ветки к дереву другой.

$ git checkout master		Для этого нужно выписать ветку, в которую будем вливать коммит
$ git pull origin master	Обновить ее
$ git cherry-pick eb042098a5	Выполнить команду, указать код коммита
$ git push origin master 	После этого обновить ветку на сервере

----------------------------------------------------------------------------------
SVN
-----------------------------------------------------------------------------
yum instll subversion
/etc/sysconfig/svnserver
/var/svn/repos/		репозитарий
/var/svn/repos/conf	конфигурация
/var/svn/repos/db		БД всего
/var/svn/repos/hooks	срабатывают по событию
/var/svn/repos/locks	блокировки

/etc/subversion/conf/passwd - пароль
/var/svn/repo/conf/authz - пользователь

svnserver.conf
passwd
auth
-----------------------------------------------------------------------------
svn co svn://IP_ADDR/"repositariy"	checkout
svn update				Принимаем зменения
svn commit -m "message"			commit
svn info				в какой ветке находимся
svn log | less				история изменений
svn log --diff | less
svn blame -v test.txt			кто какие строчки когда менял
svn diff				незакомиченные изменения
svn diff --summarize			какие файлы были изменены или добавлены
-----------------------------------------------------------------------------
Изменения в рамках ревизиции, аналог git show:
svn log -c 123456			посмотреть комментарий
svn diff -c 123456			посмотреть изменения
svn diff --summarize -c 123456		Посмотреть измененные в ревизии файлы
-----------------------------------------------------------------------------
Изменения по сравнению с текущей ревизией, аналог git diff:
svn diff -r 123456
svn diff --summarize -r 123456
-----------------------------------------------------------------------------
patch -p0 -i myfile.diff		Применение сохраненного в файл дифа, аналог git apply
svn revert --recursive			Отменить последние изменения, аналог git reset --hard HEAD
svn status				Текущее состояние репозитория, измененные файлы и так далее
-----------------------------------------------------------------------------
svn ls https://example.com/project/branches/	Получение списка бранчей
-----------------------------------------------------------------------------
Создание нового бранча или тэга:
-----------------------------------------------------------------------------
svn copy https://example.com/project/trunk/ \
  https://example.com/project/branches/test-branch

svn copy https://example.com/project/trunk/ \
  https://example.com/project/tags/1.0 \
  -m "Release 1.0"
-----------------------------------------------------------------------------
Переключение на бранч:
-----------------------------------------------------------------------------
cd path/to/trunk
cd ..
mkdir branches
cd branches
svn co https://example.com/project/branches/test-branch
cd test-branch
-----------------------------------------------------------------------------
Мерж бранча:
-----------------------------------------------------------------------------
svn merge http://example.ru/project/branches/test-branch

Удаление бранча:
svn delete http://example.ru/project/branches/test-branch \
  -m "Removing test-branch"

Примечание: Примите также во внимание, что если вы сделали checkout самого корня
репозитория, в котором находятся каталоги trunk, branches и tags, то можете
просматривать бранчи обычным ls, удалять обычным svn rm с последующим коммитом,
и так далее. Впрочем, в больших проектах вы вряд ли захотите делать checkout вот
прямо всего репозитория целиком.
-----------------------------------------------------------------------------
svn add text.txt			Добавить файл
svn mv from.txt to.txt			Переименовать файл
svn del file.txt			Удалить файл
-----------------------------------------------------------------------------
Lock/unlock, чтобы файл никто не мог менять кроме нас:
-----------------------------------------------------------------------------
svn lock file.txt
svn unlock file.txt
-----------------------------------------------------------------------------
Коммит и сразу пуш, потому что это SVN:
-----------------------------------------------------------------------------
svn commit -m 'Your comment here'
svn list

svnadmin create "repositariy" в "/" of repositariy
svnadmin dump /var/svn/repos/ > /tmp/repos.dumpfile
svnadmin load /var/svn/repos/ < /tmp/repos.dumpfile
-----------------------------------------------------------------------------
http://eax.me/svn-commands/
-----------------------------------------------------------------------------
============================================
D4.Container orchestration and clustering
============================================
-----------------------------------------------------------------------------
Docker
-----------------------------------------------------------------------------
Mesos, Kubernetes, Swarm
-----------------------------------------------------------------------------
OpenVZ
-----------------------------------------------------------------------------
===========
D5.ELK stack 
===========
-----------------------------------------------------------------------------
ElasticSearch
-----------------------------------------------------------------------------
Logstash
-----------------------------------------------------------------------------
Kibana
-----------------------------------------------------------------------------
======================
D6.Atlassian
======================
-----------------------------------------------------------------------------
JIRA
-----------------------------------------------------------------------------
Confluence
-----------------------------------------------------------------------------
Bamboo
-----------------------------------------------------------------------------
Stash(Bitbucket)
-----------------------------------------------------------------------------

######
#AWS	
######



#####################
#Switch and Routing
#####################
=============
SR1.Microtik
=============
-----------------------------------------------------------------------------
https://habrahabr.ru/post/265387/
-----------------------------------------------------------------------------
http://www.technotrade.com.ua/Articles/mikrotik_router_setup.php
-----------------------------------------------------------------------------
Командная строка
-----------------------------------------------------------------------------
Боитесь командной строки, но понимаете, что с ней работать удобнее? Научитесь
работать и в командной строке, и в графическом интерфейсе.
----------------------------------------------------------------------------- 
Подбор модели

Научитесь выбирать оборудование MikroTik по вашим требованиям: установка в
офисе или на улице, будет или не будет VPN, нужен ли Wi-Fi и др.
----------------------------------------------------------------------------- 
Стабильная телефония

Вы научитесь настраивать приоритезацию трафика так, что IP-телефония больше
не будет "крякать".
----------------------------------------------------------------------------- 
Управление трафиком

Кто-то качает торрент, а остальные без интернета? Настройте трафик гибко, в
зависимости от количества пользователей и приоритета их задач.
----------------------------------------------------------------------------- 
Брандмауэр

Защититесь от атак, настройте файервол по схемам «нормально открытый» или
«нормально закрытый».
----------------------------------------------------------------------------- 
Настройка VPN

Трафик будет не ходить, а бегать ;) Научитесь настраивать VPN разными способами.
----------------------------------------------------------------------------- 
Резервный интернет

Регулярно "отваливается" интернет? Настройте автоматическое переключение
с основного канала на резервный и обратно.
----------------------------------------------------------------------------- 
Беспроводные сети

Потерялись в настройках Wi-Fi? Научитесь настраивать сети в диапазона 2,4 и 5 ГГц.
Делайте гостевые сети. Ставьте ограничение скорости wi-fi сети.
-----------------------------------------------------------------------------


=============
SR2.Cisco
=============
-----------------------------------------------------------------------------
terminal
restore_password
update/restore os
-----------------------------------------------------------------------------
cdp
-----------------------------------------------------------------------------
port security
-----------------------------------------------------------------------------
ether channale
lasp
-----------------------------------------------------------------------------
trunc
vlan
vtp
-----------------------------------------------------------------------------
stp
-----------------------------------------------------------------------------
nat
-----------------------------------------------------------------------------
acl
-----------------------------------------------------------------------------
hsrp
-----------------------------------------------------------------------------
rip
-----------------------------------------------------------------------------
ospf
-----------------------------------------------------------------------------
vpn
-----------------------------------------------------------------------------
https://linkmeup.ru/tag/%D1%81%D0%B5%D1%82%D0%B8%20%D0%B4%D0%BB%D1%8F%20%D1%81%D0%B0%D0%BC%D1%8B%D1%85%20%D0%BC%D0%B0%D0%BB%D0%B5%D0%BD%D1%8C%D0%BA%D0%B8%D1%85/
-----------------------------------------------------------------------------



============
T1.Asterisk
============ 
-----------------------------------------------------------------------------
Asterisk — SIP АТС для офиса, пошаговая инструкция по настройке с нуля
-----------------------------------------------------------------------------
https://serveradmin.ru/nastroyka-servera-telefonii-asterisk-s-nulya/
-----------------------------------------------------------------------------
Как удалить голосовую почту в asterisk
-----------------------------------------------------------------------------
https://serveradmin.ru/kak-udalit-golosovuyu-pochtu-v-asterisk/
-----------------------------------------------------------------------------
