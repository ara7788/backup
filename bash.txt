
----------------------------------------------------------------------
			############
			#Оглавление#
			############
----------------------------------------------------------------------

########################################################################
    Part 1 — здесь речь идёт о том, как начать создание
bash-скриптов, рассмотрено использование переменных, описаны условные
конструкции, вычисления, сравнения чисел, строк, выяснение сведений о файлах.
########################################################################
----------------------------------------------------------------------
Использование переменных
----------------------------------------------------------------------
    Переменные среды
    Пользовательские переменные
----------------------------------------------------------------------
Подстановка команд
----------------------------------------------------------------------
    С помощью значка обратного апострофа «`»
    С помощью конструкции $()
----------------------------------------------------------------------
Математические операции
----------------------------------------------------------------------
Управляющая конструкция if-then
----------------------------------------------------------------------
Сравнение чисел
----------------------------------------------------------------------
Сравнение строк
----------------------------------------------------------------------
Проверки файлов
----------------------------------------------------------------------
########################################################################
    Part 2, Bash the awesome — тут раскрываются особенности
работы с циклами for и while.
########################################################################
----------------------------------------------------------------------
Циклы for
----------------------------------------------------------------------
Перебор простых значений
----------------------------------------------------------------------
Перебор сложных значений
----------------------------------------------------------------------
Инициализация цикла списком, полученным из результатов работы команды
----------------------------------------------------------------------
Разделители полей
----------------------------------------------------------------------
Internal Field Separator

    Пробел
    Знак табуляции
    Знак перевода строки
----------------------------------------------------------------------
Обход файлов, содержащихся в директории
----------------------------------------------------------------------
Циклы for в стиле C
----------------------------------------------------------------------
Цикл while
----------------------------------------------------------------------
Вложенные циклы
----------------------------------------------------------------------
Обработка содержимого файла
----------------------------------------------------------------------
Управление циклами
----------------------------------------------------------------------
    break
    continue
----------------------------------------------------------------------
Обработка вывода, выполняемого в цикле
----------------------------------------------------------------------
Пример: поиск исполняемых файлов
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 3, Parameters & options — этот материал посвящён
параметрам командной строки и ключам, которые можно передавать скриптам,
работе с данными, которые вводит пользователь, и которые можно читать из
файлов.
########################################################################
----------------------------------------------------------------------
Чтение параметров командной строки
----------------------------------------------------------------------
$0 — имя скрипта.
$1 — первый параметр.
$2 — второй параметр — и так далее, вплоть до переменной $9, в которую
попадает девятый параметр.
${10} — Если скрипту надо больше девяти параметров.
$# — содержит количество параметров, переданных сценарию при вызове.
$* —  содержит все параметры, введённые в командной строке, в виде единого «слова».
$@ — параметры разбиты на отдельные «слова». Эти параметры можно перебирать в циклах. 
$? - переменная с возвращенным командой return результатом. 
----------------------------------------------------------------------
Проверка параметров
----------------------------------------------------------------------
Подсчёт параметров
----------------------------------------------------------------------
Захват всех параметров командной строки
----------------------------------------------------------------------
Команда shift
----------------------------------------------------------------------
Ключи командной строки
----------------------------------------------------------------------
Как различать ключи и параметры
----------------------------------------------------------------------
    Эта последовательность — двойное тире (--).
----------------------------------------------------------------------
Обработка ключей со значениями
----------------------------------------------------------------------
Использование стандартных ключей
----------------------------------------------------------------------
Получение данных от пользователя
----------------------------------------------------------------------
Ввод паролей
----------------------------------------------------------------------
Чтение данных из файла
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 4, Input & Output — здесь речь идёт о дескрипторах
файлов и о работе с ними, о потоках ввода, вывода, ошибок, о перенаправлении
вывода.
########################################################################
----------------------------------------------------------------------
Стандартные дескрипторы файлов
----------------------------------------------------------------------
Перенаправление вывода в скриптах
----------------------------------------------------------------------

    Временное перенаправление, или перенаправление вывода одной строки.
    Постоянное перенаправление, или перенаправление всего вывода в
	скрипте либо в какой-то его части.

----------------------------------------------------------------------
Временное перенаправление вывода
----------------------------------------------------------------------
Постоянное перенаправление вывода
----------------------------------------------------------------------
Перенаправление ввода в скриптах
----------------------------------------------------------------------
Создание собственного перенаправления вывода
----------------------------------------------------------------------
Создание дескрипторов файлов для ввода данных
----------------------------------------------------------------------
Закрытие дескрипторов файлов
----------------------------------------------------------------------
Получение сведений об открытых дескрипторах
----------------------------------------------------------------------
Подавление вывода
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 5, Sighals & Jobs — этот материал посвящён сигналам
Linux, их обработке в скриптах, запуску сценариев по расписанию.
########################################################################
----------------------------------------------------------------------
Сигналы Linux
----------------------------------------------------------------------
Отправка сигналов скриптам
----------------------------------------------------------------------
	Завершение работы процесса
----------------------------------------------------------------------
	Временная остановка процесса
----------------------------------------------------------------------
	Завершить работу приостановленного процесса
----------------------------------------------------------------------
Перехват сигналов
----------------------------------------------------------------------
Перехват сигнала выхода из скрипта
----------------------------------------------------------------------
Модификация перехваченных сигналов и отмена перехвата
----------------------------------------------------------------------
Выполнение сценариев командной строки в фоновом режиме
----------------------------------------------------------------------
$ ./myscipt &
----------------------------------------------------------------------
Выполнение скриптов, не завершающих работу при закрытии терминала
----------------------------------------------------------------------
nohup ./myscript &
----------------------------------------------------------------------
Просмотр заданий
----------------------------------------------------------------------
Перезапуск приостановленных заданий
----------------------------------------------------------------------
Планирование запуска скриптов
----------------------------------------------------------------------
Удаление заданий, ожидающих выполнения
----------------------------------------------------------------------
Запуск скриптов по расписанию
----------------------------------------------------------------------
Запуск скриптов при входе в систему и при запуске оболочки
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 6, Functions — тут можно узнать о создании и
использовании функций в скриптах, о разработке библиотек.
########################################################################
----------------------------------------------------------------------
Объявление функций
----------------------------------------------------------------------
Использование функций
----------------------------------------------------------------------
Использование команды return
----------------------------------------------------------------------
Запись вывода функции в переменную
----------------------------------------------------------------------
Аргументы функций
----------------------------------------------------------------------
Работа с переменными в функциях
----------------------------------------------------------------------
Существуют два вида переменных:

    Глобальные переменные.
    Локальные переменные.

----------------------------------------------------------------------
Глобальные переменные
----------------------------------------------------------------------
Локальные переменные
----------------------------------------------------------------------
Передача функциям массивов в качестве аргументов
----------------------------------------------------------------------
Рекурсивные функции
----------------------------------------------------------------------
Создание и использование библиотек
----------------------------------------------------------------------
Вызов bash-функций из командной строки
----------------------------------------------------------------------
Массивы
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 7, Using sed — эта статья посвящена работе с 
потоковым текстовым редактором sed.
########################################################################
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 8, Using awk — данный материал посвящён
программированию на языке обработки данных awk.
########################################################################
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 9, Regular Expressions — тут можно почитать об
использовании регулярных выражений в bash-скриптах.
########################################################################
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 10, Practical Examples — здесь приведены приёмы
работы с сообщениями, которые можно отправлять пользователям, а так же
методика мониторинга диска.
########################################################################
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 11, Expect Command — этот материал посвящён
средству Expect, с помощью которого можно автоматизировать взаимодействие
с интерактивными утилитами. В частности,
здесь идёт речь об expect-скриптах и об их взаимодействии с bash-скриптами
и другими программами.
########################################################################
----------------------------------------------------------------------
########################################################################
Advanced Bash-Scripting Guide
Искусство программирования на языке сценариев командной оболочки
http://rus-linux.net/MyLDP/BOOKS/abs-guide/flat/abs-book.html
########################################################################
----------------------------------------------------------------------
			#########
			#Учебник#
			#########
----------------------------------------------------------------------

########################################################################
    Part 1 — здесь речь идёт о том, как начать создание
bash-скриптов, рассмотрено использование переменных, описаны условные
конструкции, вычисления, сравнения чисел, строк, выяснение сведений о файлах.
########################################################################
----------------------------------------------------------------------
Скрипт
----------------------------------------------------------------------
#!/bin/bash
# our comment is here
echo "The current directory is:"
pwd
echo "The user logged in is:"
whoami
----------------------------------------------------------------------
chmod +x ./myscript
----------------------------------------------------------------------
./myscript
----------------------------------------------------------------------
Использование переменных
----------------------------------------------------------------------
    Переменные среды
	https://likegeeks.com/linux-environment-variables/
----------------------------------------------------------------------
#!/bin/bash
# display user home
echo "Home for the current user is: $HOME"
echo "I have \$1 in my pocket"
----------------------------------------------------------------------
    Пользовательские переменные
----------------------------------------------------------------------
#!/bin/bash
# testing variables
grade=5
person="Oleg"
echo "$person is a good boy, he is in grade $grade"
----------------------------------------------------------------------
Подстановка команд
----------------------------------------------------------------------
Сделать это можно двумя способами.

    С помощью значка обратного апострофа «`»
    С помощью конструкции $()
----------------------------------------------------------------------
mydir=`pwd`
mydir=$(pwd)

#!/bin/bash
mydir=$(pwd)
echo $mydir
----------------------------------------------------------------------
Математические операции
----------------------------------------------------------------------
$((a+b))

#!/bin/bash
var1=$(( 5 + 5 ))
echo $var1
var2=$(( $var1 * 2 ))
echo $var2
----------------------------------------------------------------------
Управляющая конструкция if-then
----------------------------------------------------------------------
if команда
then
команды
fi
----------------------------------------------------------------------
#!/bin/bash
if pwd
then
echo "It works"
fi
----------------------------------------------------------------------
#!/bin/bash
user=likegeeks
if grep $user /etc/passwd
then
echo "The user $user Exists"
fi
----------------------------------------------------------------------
if команда
then
команды
else
команды
fi
----------------------------------------------------------------------
#!/bin/bash
user=anotherUser
if grep $user /etc/passwd
then
echo "The user $user Exists"
else
echo "The user $user doesn’t exist"
fi
----------------------------------------------------------------------
if команда1
then
команды
elif команда2
then
команды
fi
----------------------------------------------------------------------
#!/bin/bash
user=anotherUser
if grep $user /etc/passwd
then
echo "The user $user Exists"
elif ls /home
then
echo "The user doesn’t exist but anyway there is a directory under /home"
fi
----------------------------------------------------------------------
Сравнение чисел
----------------------------------------------------------------------
n1 -eq n2Возвращает истинное значение, если n1 равно n2.
n1 -ge n2 Возвращает истинное значение, если n1больше или равно n2.
n1 -gt n2Возвращает истинное значение, если n1 больше n2.
n1 -le n2Возвращает истинное значение, если n1меньше или равно n2.
n1 -lt n2Возвращает истинное значение, если n1 меньше n2.
n1 -ne n2Возвращает истинное значение, если n1не равно n2.
----------------------------------------------------------------------
#!/bin/bash
val1=6
if [ $val1 -gt 5 ]
then
echo "The test value $val1 is greater than 5"
else
echo "The test value $val1 is not greater than 5"
fi
----------------------------------------------------------------------
Сравнение строк
----------------------------------------------------------------------
str1 = str2 Проверяет строки на равенство, возвращает истину, если строки идентичны.
str1 != str2Возвращает истину, если строки не идентичны.
str1 < str2Возвращает истину, если str1меньше, чем str2.
str1 > str2 Возвращает истину, если str1больше, чем str2.
-n str1 Возвращает истину, если длина str1больше нуля.
-z str1Возвращает истину, если длина str1равна нулю.
----------------------------------------------------------------------
#!/bin/bash
user ="likegeeks"
if [$user = $USER]
then
echo "The user $user  is the current logged in user"
fi
----------------------------------------------------------------------
Вот одна особенность сравнения строк, о которой стоит упомянуть. А именно,
операторы «>» и «<» необходимо экранировать  помощью обратной косой черты,
иначе скрипт будет работать неправильно, хотя сообщений об ошибках и не
появится. Скрипт интерпретирует знак «>» как команду перенаправления вывода.
----------------------------------------------------------------------
#!/bin/bash
val1=text
val2="another text"
if [ $val1 \> "$val2" ]
then
echo "$val1 is greater than $val2"
else
echo "$val1 is less than $val2"
fi
----------------------------------------------------------------------
Ещё одна особенность операторов «>» и «<» заключается в том, как они
работают с символами в верхнем и нижнем регистрах. Для того, чтобы понять
эту особенность, подготовим текстовый файл с таким содержимым:
----------------------------------------------------------------------
Создадим файл

Likegeeks
likegeeks

дав имя myfile
----------------------------------------------------------------------
sort myfile

Команда sort, по умолчанию, сортирует строки по возрастанию, то есть
строчная буква в нашем примере меньше прописной. 
----------------------------------------------------------------------
likegeeks
Likegeeks
----------------------------------------------------------------------
#!/bin/bash
val1=Likegeeks
val2=likegeeks
if [ $val1 \> $val2 ]
then
echo "$val1 is greater than $val2"
else
echo "$val1 is less than $val2"
fi
----------------------------------------------------------------------
Likegeeks is less than likegeeks
----------------------------------------------------------------------
В командах сравнения прописные буквы меньше строчных. Сравнение строк
здесь выполняется путём сравнения ASCII-кодов символов, порядок сортировки,
таким образом, зависит от кодов символов.

Команда sort, в свою очередь, использует порядок сортировки, заданный в
настройках системного языка.
----------------------------------------------------------------------
Проверки файлов
----------------------------------------------------------------------
-d fileПроверяет, существует ли файл, и является ли он директорией.
-e fileПроверяет, существует ли файл.
-f file Проверяет, существует ли файл, и является ли он файлом.
-r fileПроверяет, существует ли файл, и доступен ли он для чтения.
-s file Проверяет, существует ли файл, и не является ли он пустым.
-w fileПроверяет, существует ли файл, и доступен ли он для записи.
-x fileПроверяет, существует ли файл, и является ли он исполняемым.
file1 -nt file2 Проверяет, новее ли file1, чем file2.
file1 -ot file2Проверяет, старше ли file1, чем file2.
-O file Проверяет, существует ли файл, и является ли его владельцем текущий пользователь.
-G fileПроверяет, существует ли файл, и соответствует ли его идентификатор группы идентификатору группы текущего пользователя.
----------------------------------------------------------------------
#!/bin/bash
mydir=/home/likegeeks
if [ -d $mydir ]
then
echo "The $mydir directory exists"
cd $ mydir
ls
else
echo "The $mydir directory does not exist"
fi

Этот скрипт, для существующей директории, выведет её содержимое.
----------------------------------------------------------------------
########################################################################
    Part 2, Bash the awesome — тут раскрываются особенности
работы с циклами for и while.
########################################################################
----------------------------------------------------------------------
Циклы for
----------------------------------------------------------------------
for var in list
do
команды
done
----------------------------------------------------------------------
Перебор простых значений
----------------------------------------------------------------------
#!/bin/bash
for var in first second third fourth fifth
do
echo The  $var item
done
----------------------------------------------------------------------
Перебор сложных значений
----------------------------------------------------------------------
#!/bin/bash
for var in first "the second" "the third" "I’ll do it"
do
echo "This is: $var"
done
----------------------------------------------------------------------
Инициализация цикла списком, полученным из результатов работы команды
----------------------------------------------------------------------
#!/bin/bash
file="myfile"
for var in $(cat $file)
do
echo " $var"
done
----------------------------------------------------------------------
Разделители полей
----------------------------------------------------------------------
Internal Field Separator

    Пробел
    Знак табуляции
    Знак перевода строки

----------------------------------------------------------------------
IFS=$'\n'
----------------------------------------------------------------------
#!/bin/bash
file="/etc/passwd"
IFS=$'\n'
for var in $(cat $file)
do
echo " $var"
done
----------------------------------------------------------------------
IFS=:
/etc/passwd
----------------------------------------------------------------------
Обход файлов, содержащихся в директории
----------------------------------------------------------------------
#!/bin/bash
for file in /home/likegeeks/*
do
if [ -d "$file" ]
then
echo "$file is a directory"
elif [ -f "$file" ]
then
echo "$file is a file"
fi
done
----------------------------------------------------------------------
Циклы for в стиле C
----------------------------------------------------------------------
for (( начальное значение переменной ; условие окончания цикла; изменение переменной ))
for (( a = 1; a < 10; a++ ))
----------------------------------------------------------------------
#!/bin/bash
for (( i=1; i <= 10; i++ ))
do
echo "number is $i"
done
----------------------------------------------------------------------
Цикл while
----------------------------------------------------------------------
while команда проверки условия
do
другие команды
done
----------------------------------------------------------------------
#!/bin/bash
var1=5
while [ $var1 -gt 0 ]
do
echo $var1
var1=$[ $var1 - 1 ]
done
----------------------------------------------------------------------
Вложенные циклы
----------------------------------------------------------------------
#!/bin/bash
for (( a = 1; a <= 3; a++ ))
do
echo "Start $a:"
for (( b = 1; b <= 3; b++ ))
do
echo " Inner loop: $b"
done
done
----------------------------------------------------------------------
Обработка содержимого файла
----------------------------------------------------------------------
#!/bin/bash
IFS=$'\n'
for entry in $(cat /etc/passwd)
do
echo "Values in $entry –"
IFS=:
for value in $entry
do
echo " $value"
done
done
----------------------------------------------------------------------
Управление циклами
----------------------------------------------------------------------

    break
    continue

----------------------------------------------------------------------
Команда break
----------------------------------------------------------------------
Эта команда позволяет прервать выполнение цикла. Её можно использовать
и для циклов for, и для циклов while:
----------------------------------------------------------------------
#!/bin/bash
for var1 in 1 2 3 4 5 6 7 8 9 10
do
if [ $var1 -eq 5 ]
then
break
fi
echo "Number: $var1"
done
----------------------------------------------------------------------
Команда continue
----------------------------------------------------------------------
Когда в теле цикла встречается эта команда, текущая итерация завершается
досрочно и начинается следующая, при этом выхода из цикла не происходит. 
----------------------------------------------------------------------
#!/bin/bash
for (( var1 = 1; var1 < 15; var1++ ))
do
if [ $var1 -gt 5 ] && [ $var1 -lt 10 ]
then
continue
fi
echo "Iteration number: $var1"
done
----------------------------------------------------------------------
Когда условие внутри цикла выполняется, то есть, когда $var1 больше 5
и меньше 10, оболочка исполняет команду continue. Это приводит к
пропуску оставшихся в теле цикла команд и переходу к следующей итерации.
----------------------------------------------------------------------
Обработка вывода, выполняемого в цикле
----------------------------------------------------------------------
#!/bin/bash
for (( a = 1; a < 10; a++ ))
do
echo "Number is $a"
done > myfile.txt
echo "finished."
----------------------------------------------------------------------
Пример: поиск исполняемых файлов
----------------------------------------------------------------------
#!/bin/bash
IFS=:
for folder in $PATH
do
echo "$folder:"
for file in $folder/*
do
if [ -x $file ]
then
echo " $file"
fi
done
done
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 3, Parameters & options — этот материал посвящён
параметрам командной строки и ключам, которые можно передавать скриптам,
работе с данными, которые вводит пользователь, и которые можно читать из
файлов.
########################################################################
----------------------------------------------------------------------
$ ./myscript 10 20
----------------------------------------------------------------------
Чтение параметров командной строки
----------------------------------------------------------------------
$0 — имя скрипта.
$1 — первый параметр.
$2 — второй параметр — и так далее, вплоть до переменной $9, в которую
попадает девятый параметр.
${10} — Если скрипту надо больше девяти параметров.
$# — содержит количество параметров, переданных сценарию при вызове.
$* —  содержит все параметры, введённые в командной строке, в виде единого «слова».
$@ — параметры разбиты на отдельные «слова». Эти параметры можно перебирать в циклах. 

$? - переменная с возвращенным командой return результатом.
Если вы выполните любую другую команду до извлечения из переменной $? значения,
возвращённого функцией, это значение будет утеряно. Дело в том, что
данная переменная хранит код возврата последней выполненной команды.

Учтите, что максимальное число, которое может вернуть команда
return — 255. Если функция должна возвращать большее число или строку,
понадобится другой подход.
----------------------------------------------------------------------
#!/bin/bash
echo $0
echo $1
echo $2
echo $3
----------------------------------------------------------------------
#!/bin/bash
total=$[ $1 + $2 ]
echo The first parameter is $1.
echo The second parameter is $2.
echo The sum is $total.
----------------------------------------------------------------------
Что если параметр содержит пробелы, а нам надо обрабатывать его как
самостоятельный фрагмент данных? Полагаем, если вы освоили предыдущие
части этого руководства, ответ вы уже знаете. Заключается он в
использовании кавычек.
----------------------------------------------------------------------
Проверка параметров
----------------------------------------------------------------------
#!/bin/bash
if [ -n "$1" ]
then
echo Hello $1.
else
echo "No parameters found. "
fi
----------------------------------------------------------------------
Подсчёт параметров
----------------------------------------------------------------------
#!/bin/bash
echo There were $# parameters passed.
----------------------------------------------------------------------
Эта переменная даёт необычный способ получения последнего из переданных
скрипту параметров, не требующий знания их количества. Вот как это выглядит:
----------------------------------------------------------------------
#!/bin/bash
echo The last parameter was ${!#}
----------------------------------------------------------------------
Захват всех параметров командной строки
----------------------------------------------------------------------
#!/bin/bash
count=1
for param in "$*"
do
echo "\$* Parameter #$count = $param"
count=$(( $count + 1 ))
done
count=1
for param in "$@"
do
echo "\$@ Parameter #$count = $param"
count=$(( $count + 1 ))
done
----------------------------------------------------------------------
Команда shift
----------------------------------------------------------------------
Использовать команду shift в bash-скриптах следует с осторожностью, так
как она, в прямом смысле слова, сдвигает значения позиционных параметров.
----------------------------------------------------------------------
Когда вы используете эту команду, она, по умолчанию, сдвигает значения
позиционных параметров влево. Например, значение переменной $3 становится
значением переменной $2, значение $2 переходит в $1, а то, что было до
этого в $1, теряется. Обратите внимание на то, что при этом значение
переменной $0, содержащей имя скрипта, не меняется.
----------------------------------------------------------------------
#!/bin/bash
count=1
while [ -n "$1" ]
do
echo "Parameter #$count = $1"
count=$(( $count + 1 ))
shift
done
----------------------------------------------------------------------
Скрипт задействует цикл while, проверяя длину значения первого параметра.
Когда длина станет равна нулю, происходит выход из цикла. После проверки
первого параметра и вывода его на экран, вызывается команда shift, которая
сдвигает значения параметров на одну позицию.
----------------------------------------------------------------------
Ключи командной строки
----------------------------------------------------------------------
Ключи командной строки обычно выглядят как буквы, перед которыми
ставится тире. Они служат для управления сценариями. 
----------------------------------------------------------------------
#!/bin/bash
echo
while [ -n "$1" ]
do
case "$1" in
-a) echo "Found the -a option" ;;
-b) echo "Found the -b option" ;;
-c) echo "Found the -c option" ;;
*) echo "$1 is not an option" ;;
esac
shift
done
----------------------------------------------------------------------
$ ./myscript –a –b –c –d
----------------------------------------------------------------------
Как различать ключи и параметры
----------------------------------------------------------------------
Стандартный способ это сделать заключается в применении специальной
последовательности символов, которая сообщает скрипту о том, когда
заканчиваются ключи и начинаются обычные параметры.
----------------------------------------------------------------------
Эта последовательность — двойное тире (--).

Оболочка использует её для указания позиции, на которой заканчивается
список ключей. После того, как скрипт обнаружит признак окончания
ключей, то, что осталось, можно, не опасаясь ошибок, обрабатывать как
параметры, а не как ключи. 
----------------------------------------------------------------------
#!/bin/bash
while [ -n "$1" ]
do
case "$1" in
-a) echo "Found the -a option" ;;
-b) echo "Found the -b option";;
-c) echo "Found the -c option" ;;
--) shift
break ;;
*) echo "$1 is not an option";;
esac
shift
done
count=1
for param in $@
do
echo "Parameter #$count: $param"
count=$(( $count + 1 ))
done
----------------------------------------------------------------------
$ ./myscript –a –b –c –d -- 5 10 15
----------------------------------------------------------------------
Обработка ключей со значениями
----------------------------------------------------------------------
./myscript -a test1 -b -c test2
----------------------------------------------------------------------
#!/bin/bash
while [ -n "$1" ]
do
case "$1" in
-a) echo "Found the -a option";;
-b) param="$2"
echo "Found the -b option, with parameter value $param"
shift ;;
-c) echo "Found the -c option";;
--) shift
break ;;
*) echo "$1 is not an option";;
esac
shift
done
count=1
for param in "$@"
do
echo "Parameter #$count: $param"
count=$(( $count + 1 ))
done
----------------------------------------------------------------------
В данном примере в конструкции case обрабатываются три ключа. Ключ -b
требует наличия дополнительного параметра. Так как обрабатываемый ключ
находится в переменной $1, соответствующий ему параметр будет
находиться в $2 (тут используется команда shift, поэтому, по мере
обработки, всё, что передано сценарию, сдвигается влево). Когда с этим
мы разобрались, осталось лишь извлечь значение переменной $2 и у нас
будет параметр нужного ключа. Конечно, тут понадобится ещё одна команда
shift для того, чтобы следующий ключ попал в $1
----------------------------------------------------------------------
Использование стандартных ключей
----------------------------------------------------------------------
Однако, в мире Linux значения некоторых ключей стали чем-то вроде
стандарта, которого полезно придерживаться. Вот список этих ключей:
----------------------------------------------------------------------
-a Вывести все объекты.
-c Произвести подсчёт.
-d Указать директорию.
-e Развернуть объект.
-f Указать файл, из которого нужно прочитать данные.
-h Вывести справку по команде.
-i Игнорировать регистр символов.
-l Выполнить полноформатный вывод данных.
-n Использовать неинтерактивный (пакетный) режим.
-o Позволяет указать файл, в который нужно перенаправить вывод.
-q Выполнить скрипт в quiet-режиме.
-r Обрабатывать папки и файлы рекурсивно.
-s Выполнить скрипт в silent-режиме.
-v Выполнить многословный вывод.
-x Исключить объект.
-y Ответить «yes» на все вопросы.
----------------------------------------------------------------------
Получение данных от пользователя
----------------------------------------------------------------------
#!/bin/bash
echo -n "Enter your name: "
read name
echo "Hello $name, welcome to my program."
----------------------------------------------------------------------
#!/bin/bash
read -p "Enter your name: " first last
echo "Your data for $last, $first…"
----------------------------------------------------------------------
Если, вызвав read, не указывать переменную, данные, введённые
пользователем, будут помещены в специальную переменную среды REPLY:
----------------------------------------------------------------------
#!/bin/bash
read -p "Enter your name: "
echo Hello $REPLY, welcome to my program.
----------------------------------------------------------------------
Если скрипт должен продолжать выполнение независимо от того, введёт
пользователь какие-то данные или нет, вызывая команду read можно
воспользоваться ключом -t. А именно, параметр ключа задаёт время
ожидания ввода в секундах:
----------------------------------------------------------------------
#!/bin/bash
if read -t 5 -p "Enter your name: " name
then
echo "Hello $name, welcome to my script"
else
echo "Sorry, too slow! "
fi
----------------------------------------------------------------------
Если данные не будут введены в течение 5 секунд, скрипт выполнит ветвь
условного оператора else, выведя извинения.
----------------------------------------------------------------------
Ввод паролей
----------------------------------------------------------------------
#!/bin/bash
read -s -p "Enter your password: " pass
echo "Is your password really $pass? "
----------------------------------------------------------------------
Чтение данных из файла
----------------------------------------------------------------------
Команда read может, при каждом вызове, читать одну строку текста из
файла. Когда в файле больше не останется непрочитанных строк, она
просто остановится. Если нужно получить в скрипте всё содержимое файла,
можно, с помощью конвейера, передать результаты вызова команды cat для
файла, конструкции while, которая содержит команду read
----------------------------------------------------------------------
#!/bin/bash
count=1
cat myfile | while read line
do
echo "Line $count: $line"
count=$(( $count + 1 ))
done
echo "Finished"
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 4, Input & Output — здесь речь идёт о дескрипторах
файлов и о работе с ними, о потоках ввода, вывода, ошибок, о перенаправлении
вывода.
########################################################################
----------------------------------------------------------------------
Стандартные дескрипторы файлов
----------------------------------------------------------------------
Всё в Linux — это файлы, в том числе — ввод и вывод. Операционная
система идентифицирует файлы с использованием дескрипторов.

Каждому процессу позволено иметь до девяти открытых дескрипторов файлов.
Оболочка bash резервирует первые три дескриптора с идентификаторами
0, 1 и 2. Вот что они означают.
----------------------------------------------------------------------

    0, STDIN — стандартный поток ввода.
    1, STDOUT — стандартный поток вывода.
    2, STDERR — стандартный поток ошибок.

----------------------------------------------------------------------
cat ./myfile
pwd >> myfile
ls -l xfile 2>myfile
----------------------------------------------------------------------
ls –l myfile xfile anotherfile 2> errorcontent 1> correctcontent
----------------------------------------------------------------------
Если надо, и STDERR, и STDOUT можно перенаправить в один и тот же файл,
воспользовавшись командой &>:
----------------------------------------------------------------------
Перенаправление вывода в скриптах
----------------------------------------------------------------------
Существует два метода перенаправления вывода в сценариях командной строки:

    Временное перенаправление, или перенаправление вывода одной строки.
    Постоянное перенаправление, или перенаправление всего вывода в
	скрипте либо в какой-то его части.

----------------------------------------------------------------------
Временное перенаправление вывода
----------------------------------------------------------------------
#!/bin/bash
echo "This is an error" >&2
echo "This is normal output"
----------------------------------------------------------------------
./myscript 2> myfile
----------------------------------------------------------------------
Постоянное перенаправление вывода
----------------------------------------------------------------------
#!/bin/bash
exec 1>outfile
echo "This is a test of redirecting all output"
echo "from a shell script to another file."
echo "without having to redirect every line"
----------------------------------------------------------------------
можно задать перенаправление вывода в определённый дескриптор на время
выполнения скрипта, воспользовавшись командой exec:
----------------------------------------------------------------------
Команду exec можно использовать не только в начале скрипта, но и в
других местах:
----------------------------------------------------------------------
#!/bin/bash
exec 2>myerror
echo "This is the start of the script"
echo "now redirecting all output to another location"
exec 1>myfile
echo "This should go to the myfile file"
echo "and this should go to the myerror file" >&2
----------------------------------------------------------------------
Перенаправление ввода в скриптах
----------------------------------------------------------------------
exec 0< myfile
----------------------------------------------------------------------
#!/bin/bash
exec 0< testfile
count=1
while read line
do
echo "Line #$count: $line"
count=$(( $count + 1 ))
done
----------------------------------------------------------------------
Создание собственного перенаправления вывода
----------------------------------------------------------------------
с номерами от 3 до 8, можно использовать для перенаправления ввода или
вывода. Любой из них можно назначить файлу и использовать в коде скрипта.
----------------------------------------------------------------------
#!/bin/bash
exec 3>myfile
echo "This should display on the screen"
echo "and this should be stored in the file" >&3
echo "And this should be back on the screen"
----------------------------------------------------------------------
Создание дескрипторов файлов для ввода данных
----------------------------------------------------------------------
#!/bin/bash
exec 6<&0
exec 0< myfile
count=1
while read line
do
echo "Line #$count: $line"
count=$(( $count + 1 ))
done
exec 0<&6
read -p "Are you done now? " answer
case $answer in
y) echo "Goodbye";;
n) echo "Sorry, this is the end.";;
esac
----------------------------------------------------------------------

Перенаправить ввод в скрипте можно точно так же, как и вывод. Сохраните
STDIN в другом дескрипторе, прежде чем перенаправлять ввод данных.

После окончания чтения файла можно восстановить STDIN и пользоваться
им как обычно:
----------------------------------------------------------------------
В этом примере дескриптор файла 6 использовался для хранения ссылки на
STDIN. Затем было сделано перенаправление ввода, источником данных для
STDIN стал файл. После этого входные данные для команды read поступали
из перенаправленного STDIN, то есть из файла.

После чтения файла мы возвращаем STDIN в исходное состояние,
перенаправляя его в дескриптор 6. Теперь, для того, чтобы проверить,
что всё работает правильно, скрипт задаёт пользователю вопрос, ожидает
ввода с клавиатуры и обрабатывает то, что введено.
----------------------------------------------------------------------
Закрытие дескрипторов файлов
----------------------------------------------------------------------
Оболочка автоматически закрывает дескрипторы файлов после завершения
работы скрипта. Однако, в некоторых случаях нужно закрывать дескрипторы
вручную, до того, как скрипт закончит работу. Для того, чтобы закрыть
дескриптор, его нужно перенаправить в &-.
----------------------------------------------------------------------
#!/bin/bash
exec 3> myfile
echo "This is a test line of data" >&3
exec 3>&-
echo "This won't work" >&3
----------------------------------------------------------------------
После исполнения скрипта мы получим сообщение об ошибке.
----------------------------------------------------------------------
Всё дело в том, что мы попытались обратиться к несуществующему дескриптору.

Будьте внимательны, закрывая дескрипторы файлов в сценариях. Если вы
отправляли данные в файл, потом закрыли дескриптор, потом — открыли снова,
оболочка заменит существующий файл новым. То есть всё то, что было
записано в этот файл ранее, будет утеряно.
----------------------------------------------------------------------
Получение сведений об открытых дескрипторах
----------------------------------------------------------------------
Для того, чтобы получить список всех открытых в Linux дескрипторов,
можно воспользоваться командой lsof.
----------------------------------------------------------------------
-p Позволяет указать ID процесса.
-d Позволяет указать номер дескриптора, о котором надо получить сведения.
----------------------------------------------------------------------
Для того, чтобы узнать PID текущего процесса, можно использовать
специальную переменную окружения $$, в которую оболочка записывает текущий PID.
----------------------------------------------------------------------
lsof -a -p $$ -d 0,1,2
----------------------------------------------------------------------
Тип файлов, связанных с STDIN, STDOUT и STDERR — CHR (character mode,
символьный режим). Так как все они указывают на терминал, имя файла
соответствует имени устройства, назначенного терминалу. Все три
стандартных файла доступны и для чтения, и для записи.
----------------------------------------------------------------------
#!/bin/bash
exec 3> myfile1
exec 6> myfile2
exec 7< myfile3
lsof -a -p $$ -d 0,1,2,3,6,7
----------------------------------------------------------------------
Скрипт открыл два дескриптора для вывода (3 и 6) и один — для ввода (7).
Тут же показаны и пути к файлам, использованных для настройки дескрипторов.

----------------------------------------------------------------------
Подавление вывода
----------------------------------------------------------------------
ls -al badfile anotherfile 2> /dev/null
----------------------------------------------------------------------
cat /dev/null > myfile
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 5, Sighals & Jobs — этот материал посвящён сигналам
Linux, их обработке в скриптах, запуску сценариев по расписанию.
########################################################################
----------------------------------------------------------------------
Сигналы Linux
----------------------------------------------------------------------
1
	SIGHUP
	Закрытие терминала
2
	SIGINT
	Сигнал остановки процесса пользователем с терминала (CTRL + C)
3
	SIGQUIT
	Сигнал остановки процесса пользователем с терминала (CTRL + \) с дампом памяти
9
	SIGKILL
	Безусловное завершение процесса
15
	SIGTERM
	Сигнал запроса завершения процесса
17
	SIGSTOP
	Принудительная приостановка выполнения процесса, но не завершение его работы
18
	SIGTSTP
	Приостановка процесса с терминала (CTRL + Z), но не завершение работы
19
	SIGCONT
	Продолжение выполнения ранее остановленного процесса
----------------------------------------------------------------------
Отправка сигналов скриптам
----------------------------------------------------------------------
	Завершение работы процесса
----------------------------------------------------------------------
CTRL + C генерирует сигнал SIGINT и отправляет его всем процессам
----------------------------------------------------------------------
	Временная остановка процесса
----------------------------------------------------------------------
CTRL + Z позволяет сгенерировать сигнал SIGTSTP, который
	приостанавливает работу процесса, но не завершает его выполнение.
----------------------------------------------------------------------
	Завершить работу приостановленного процесса
----------------------------------------------------------------------
kill processID
----------------------------------------------------------------------
Перехват сигналов
----------------------------------------------------------------------
Для того, чтобы включить в скрипте отслеживание сигналов Linux,
используется команда trap. Если скрипт получает сигнал, указанный при
вызове этой команды, он обрабатывает его самостоятельно, при этом
оболочка такой сигнал обрабатывать не будет.

----------------------------------------------------------------------
#!/bin/bash
trap "echo ' Trapped Ctrl-C'" SIGINT
echo This is a test script
count=1
while [ $count -le 10 ]
do
echo "Loop #$count"
sleep 1
count=$(( $count + 1 ))
done
----------------------------------------------------------------------
Перехват сигнала выхода из скрипта
----------------------------------------------------------------------
#!/bin/bash
trap "echo Goodbye..." EXIT
count=1
while [ $count -le 5 ]
do
echo "Loop #$count"
sleep 1
count=$(( $count + 1 ))
done
----------------------------------------------------------------------
При выходе из скрипта, будь то нормальное завершение его работы или
завершение, вызванное сигналом SIGINT, сработает перехват и оболочка
исполнит команду echo.

----------------------------------------------------------------------
Модификация перехваченных сигналов и отмена перехвата
----------------------------------------------------------------------
#!/bin/bash
trap "echo 'Ctrl-C is trapped.'" SIGINT
count=1
while [ $count -le 5 ]
do
echo "Loop #$count"
sleep 1
count=$(( $count + 1 ))
done
trap "echo ' I modified the trap!'" SIGINT
count=1
while [ $count -le 5 ]
do
echo "Second Loop #$count"
sleep 1
count=$(( $count + 1 ))
done
----------------------------------------------------------------------
Перехват сигналов можно и отменить, для этого достаточно выполнить
команду trap, передав ей двойное тире и имя сигнала:
----------------------------------------------------------------------
#!/bin/bash
trap "echo 'Ctrl-C is trapped.'" SIGINT
count=1
while [ $count -le 5 ]
do
echo "Loop #$count"
sleep 1
count=$(( $count + 1 ))
done
trap -- SIGINT
echo "I just removed the trap"
count=1
while [ $count -le 5 ]
do
echo "Second Loop #$count"
sleep 1
count=$(( $count + 1 ))
done
----------------------------------------------------------------------
Если скрипт получит сигнал до отмены перехвата, он обработает его так,
как задано в действующей команде trap. Запустим скрипт:

$ ./myscript


И нажмём CTRL + C на клавиатуре.
----------------------------------------------------------------------
Выполнение сценариев командной строки в фоновом режиме
----------------------------------------------------------------------
Иногда bash-скриптам требуется немало времени для выполнения некоей
задачи. При этом вам может понадобиться возможность нормально работать
в командной строке, не дожидаясь завершения скрипта. Реализовать это
не так уж и сложно.

Если вы видели список процессов, выводимый командой ps, вы могли
заметить процессы, которые выполняются в фоне и не привязаны к терминалу.
----------------------------------------------------------------------
#!/bin/bash
count=1
while [ $count -le 10 ]
do
sleep 1
count=$(( $count + 1 ))
done
----------------------------------------------------------------------
$ ./myscipt &

Это приведёт к тому, что он будет запущен как фоновый процесс.
При таком подходе, если выйти из терминала, скрипт, выполняющийся в фоне,
так же завершит работу.

----------------------------------------------------------------------
Выполнение скриптов, не завершающих работу при закрытии терминала
----------------------------------------------------------------------
nohup ./myscript &
----------------------------------------------------------------------
Команда nohup отвязывает процесс от терминала. Это означает, что процесс
потеряет ссылки на STDOUT и STDERR. Для того, чтобы не потерять данные,
выводимые скриптом, nohup автоматически перенаправляет сообщения,
поступающие в STDOUT и в STDERR, в файл nohup.out.

Обратите внимание на то, что при запуске нескольких скриптов из одной
и той же директории то, что они выводят, попадёт в один файл nohup.out.
----------------------------------------------------------------------
Просмотр заданий
----------------------------------------------------------------------
#!/bin/bash
count=1
while [ $count -le 10 ]
do
echo "Loop #$count"
sleep 10
count=$(( $count + 1 ))
done
----------------------------------------------------------------------
$ ./myscript
----------------------------------------------------------------------
И временно остановим комбинацией клавиш CTRL + Z.
----------------------------------------------------------------------
Запустим тот же скрипт в фоновом режиме, при этом перенаправим вывод
скрипта в файл так, чтобы он ничего не выводил на экране:

$ ./myscript > outfile &
----------------------------------------------------------------------
$ jobs -l
----------------------------------------------------------------------
Перезапуск приостановленных заданий
----------------------------------------------------------------------
Для того, чтобы перезапустить скрипт в фоновом режиме, можно
воспользоваться командой bg.

Запустим скрипт:

$ ./myscript


Нажмём CTRL + Z, что временно остановит его выполнение. Выполним
следующую команду:

$ bg

Теперь скрипт выполняется в фоновом режиме
----------------------------------------------------------------------
Для перезапуска задания в обычном режиме воспользуйтесь командой fg:

$ fg 1
----------------------------------------------------------------------
Планирование запуска скриптов
----------------------------------------------------------------------
at [-f filename] time
----------------------------------------------------------------------
Эта команда распознаёт множество форматов указания времени.

    Стандартный, с указанием часов и минут, например — 10:15.
    С использованием индикаторов AM/PM, до или после полудня,
например — 10:15PM.
    С использованием специальных имён, таких, как now, noon, midnight.

----------------------------------------------------------------------

    Стандартный формат указания даты, при котором дата записывается по
шаблонам MMDDYY, MM/DD/YY, или DD.MM.YY.
    Текстовое представление даты, например, Jul 4 или Dec 25, при этом
год можно указать, а можно обойтись и без него.
    Запись вида now + 25 minutes.
    Запись вида 10:15PM tomorrow.
    Запись вида 10:15 + 7 days.

----------------------------------------------------------------------
$ at -f ./myscript now
----------------------------------------------------------------------
Ключ -M при вызове at используется для отправки того, что выведет
скрипт, по электронной почте, если система соответствующим образом
настроена. Если отправка электронного письма невозможна, этот ключ
просто подавит вывод.
----------------------------------------------------------------------
$ atq
----------------------------------------------------------------------
Удаление заданий, ожидающих выполнения
----------------------------------------------------------------------
$ atrm 18
----------------------------------------------------------------------
Запуск скриптов по расписанию
----------------------------------------------------------------------
$ crontab –l
----------------------------------------------------------------------
минута, час, день месяца, месяц, день недели.
----------------------------------------------------------------------
30 10 * * * command
----------------------------------------------------------------------
Для того чтобы добавить запись в таблицу, нужно вызвать crontab с ключом -e:

crontab –e
----------------------------------------------------------------------
30 10 * * * /home/likegeeks/Desktop/myscript
----------------------------------------------------------------------
Благодаря этой команде скрипт будет вызываться ежедневно в 10:30.
Если вы столкнётесь с ошибкой «Resource temporarily unavailable»,
выполните нижеприведённую команду с правами root-пользователя:
----------------------------------------------------------------------
$ rm -f /var/run/crond.pid
----------------------------------------------------------------------
/etc/cron.hourly
/etc/cron.daily
/etc/cron.weekly
/etc/cron.monthly
----------------------------------------------------------------------
Запуск скриптов при входе в систему и при запуске оболочки
----------------------------------------------------------------------
$HOME/.bash_profile
$HOME/.bash_login
$HOME/.profile
----------------------------------------------------------------------
Для того, чтобы запускать скрипт при входе в систему, поместите его
вызов в файл .bash_profile.

А как насчёт запуска скриптов при открытии терминала? Организовать
это поможет файл .bashrc.
----------------------------------------------------------------------
https://likegeeks.com/linux-environment-variables/
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 6, Functions — тут можно узнать о создании и
использовании функций в скриптах, о разработке библиотек.
########################################################################
----------------------------------------------------------------------
Объявление функций
----------------------------------------------------------------------
functionName {
}
----------------------------------------------------------------------
functionName() {
}
----------------------------------------------------------------------
Функцию можно вызвать без аргументов и с аргументами.
----------------------------------------------------------------------
Использование функций
----------------------------------------------------------------------
#!/bin/bash
function myfunc {
echo "This is an example of using a function"
}
count=1
while [ $count -le 3 ]
do
myfunc
count=$(( $count + 1 ))
done
echo "This is the end of the loop"
myfunc
echo "End of the script"
----------------------------------------------------------------------
Функцию можно вызывать столько раз, сколько нужно. Обратите внимание
на то, что попытавшись использовать функцию до её объявления, вы
столкнётесь с ошибкой. Напишем демонстрирующий это скрипт:
----------------------------------------------------------------------
Если вы переопределите ранее объявленную функцию, новая функция будет
вызываться вместо старой без каких-либо уведомлений или сообщений об
ошибках. 
----------------------------------------------------------------------
Использование команды return
----------------------------------------------------------------------
Команда return позволяет задавать возвращаемый функцией целочисленный
код завершения. Есть два способа работы с тем, что является результатом
вызова функции. Вот первый:

----------------------------------------------------------------------
#!/bin/bash
function myfunc {
read -p "Enter a value: " value
echo "adding value"
return $(( $value + 10 ))
}
myfunc
echo "The new value is $?"


Команда echo вывела сумму введённого числа и числа 10.
----------------------------------------------------------------------
$? - переменная с возвращенным командой return результатом.
Если вы выполните любую другую команду до извлечения из переменной $? значения,
возвращённого функцией, это значение будет утеряно. Дело в том, что
данная переменная хранит код возврата последней выполненной команды.

Учтите, что максимальное число, которое может вернуть команда
return — 255. Если функция должна возвращать большее число или строку,
понадобится другой подход.
----------------------------------------------------------------------
Запись вывода функции в переменную
----------------------------------------------------------------------
#!/bin/bash
function myfunc {
read -p "Enter a value: " value
echo $(( $value + 10 ))
}
result=$( myfunc)
echo "The value is $result"
----------------------------------------------------------------------
Аргументы функций
----------------------------------------------------------------------
Функции могут использовать стандартные позиционные параметры, в которые
записывается то, что передаётся им при вызове.
----------------------------------------------------------------------
myfunc $val1 10 20
----------------------------------------------------------------------
Например, имя функции хранится в параметре $0
первый переданный ей аргумент — в $1
второй — в $2, и так далее.
Количество переданных функции аргументов можно узнать, обратившись к
переменной $#. 
----------------------------------------------------------------------
#!/bin/bash
function addnum {
if [ $# -eq 0 ] || [ $# -gt 2 ]
then
echo -1
elif [ $# -eq 1 ]
then
echo $(( $1 + $1 ))
else
echo $(( $1 + $2 ))
fi
}
echo -n "Adding 10 and 15: "
value=$(addnum 10 15)
echo $value
echo -n "Adding one number: "
value=$(addnum 10)
echo $value
echo -n "Adding no numbers: "
value=$(addnum)
echo $value
echo -n "Adding three numbers: "
value=$(addnum 10 15 20)
echo $value
----------------------------------------------------------------------
Обратите внимание на то, что функция не может напрямую работать с
параметрами, которые переданы скрипту при его запуске из командной
строки. Например, напишем такой сценарий:
----------------------------------------------------------------------
Вместо этого, если в функции планируется использовать параметры,
переданные скрипту при вызове из командной строки, надо передать их ей
при вызове:
----------------------------------------------------------------------
#!/bin/bash
function myfunc {
echo $(( $1 + $2 ))
}
if [ $# -eq 2 ]
then
value=$(myfunc $1 $2)
echo "The result is $value"
else
echo "Usage: myfunc a b"
fi
----------------------------------------------------------------------
Работа с переменными в функциях
----------------------------------------------------------------------
Существуют два вида переменных:

    Глобальные переменные.
    Локальные переменные.

----------------------------------------------------------------------
Глобальные переменные
----------------------------------------------------------------------
видны из любого места bash-скрипта. Если вы объявили глобальную
переменную в основном коде скрипта, к такой переменной можно обратиться
из функции.
----------------------------------------------------------------------
Почти то же самое справедливо и для глобальных переменных, объявленных
в функциях. Обращаться к ним можно и в основном коде скрипта после
вызова функций.
----------------------------------------------------------------------
По умолчанию все объявленные в скриптах переменные глобальны. Так, к
переменным, объявленным за пределами функций, можно без проблем
обращаться из функций:
----------------------------------------------------------------------
#!/bin/bash
function myfunc {
value=$(( $value + 10 ))
}
read -p "Enter a value: " value
myfunc
echo "The new value is: $value"
----------------------------------------------------------------------

Когда переменной присваивается новое значение в функции, это новое
значение не теряется когда скрипт обращается к ней после завершения
работы функции. Именно это можно видеть в предыдущем примере.
----------------------------------------------------------------------
Локальные переменные
----------------------------------------------------------------------
Переменные, которые объявляют и используют внутри функции, могут быть
объявлены локальными. Для того, чтобы это сделать, используется
ключевое слово local перед именем переменной:
----------------------------------------------------------------------
local temp=$(( $value + 5 ))
----------------------------------------------------------------------
Если за пределами функции есть переменная с таким же именем, это на неё
не повлияет. Ключевое слово local позволяет отделить переменные,
используемые внутри функции, от остальных переменных. 
----------------------------------------------------------------------
#!/bin/bash
function myfunc {
local temp=$[ $value + 5 ]
echo "The Temp from inside function is $temp"
}
temp=4
myfunc
echo "The temp from outside is $temp"
----------------------------------------------------------------------
Передача функциям массивов в качестве аргументов
----------------------------------------------------------------------
#!/bin/bash
function myfunc {
local newarray
newarray=("$@")
echo "The new array value is: ${newarray[*]}"
}
myarray=(1 2 3 4 5)
echo "The original array is ${myarray[*]}"
myfunc ${myarray[*]}
----------------------------------------------------------------------
Рекурсивные функции
----------------------------------------------------------------------
Рекурсия — это когда функция сама себя вызывает. Классический пример
рекурсии — функция для вычисления факториала. 
----------------------------------------------------------------------
5! = 1 * 2 * 3 * 4 * 5
x! = x * (x-1)!
----------------------------------------------------------------------
#!/bin/bash
function factorial {
if [ $1 -eq 1 ]
then
echo 1
else
local temp=$(( $1 - 1 ))
local result=$(factorial $temp)
echo $(( $result * $1 ))
fi
}
read -p "Enter value: " value
result=$(factorial $value)
echo "The factorial of $value is: $result"
----------------------------------------------------------------------
Создание и использование библиотек
----------------------------------------------------------------------
Ключ к использованию библиотек — в команде source. Эта команда
используется для подключения библиотек к скриптам. В результате функции,
объявленные в библиотеке, становятся доступными в скрипте, в противном
же случае функции из библиотек не будут доступны в области видимости
других скриптов.

У команды source есть псевдоним — оператор «точка». Для того, чтобы
подключить файл в скрипте, в скрипт надо добавить конструкцию такого вида:
----------------------------------------------------------------------
. ./myscript
----------------------------------------------------------------------
Предположим, что у нас имеется файл myfuncs, который содержит следующее:

function addnum {
echo $(( $1 + $2 ))
}
----------------------------------------------------------------------
Это — библиотека. Воспользуемся ей в сценарии:

#!/bin/bash
. ./myfuncs
result=$(addnum 10 20)
echo "The result is: $result"
----------------------------------------------------------------------
Вызов bash-функций из командной строки
----------------------------------------------------------------------
функцию из библиотеки можно подключить в файле .bashrc, используя
команду source. Как результат, вызывать функцию можно будет прямо из
командной строки.
----------------------------------------------------------------------
. /home/likegeeks/Desktop/myfuncs
----------------------------------------------------------------------
Теперь функцию можно вызывать прямо из командной строки:

$ addnum 10 20
----------------------------------------------------------------------
Ещё приятнее то, что такая вот библиотека оказывается доступной всем
дочерним процессам оболочки, то есть — ей можно пользоваться в
bash-скриптах, не заботясь о подключении к ним этой библиотеки.
----------------------------------------------------------------------
Тут стоит отметить, что для того, чтобы вышеприведённый пример
заработал, может понадобиться выйти из системы, а потом войти снова.
Кроме того, обратите внимание на то, что если имя функции из библиотеки
совпадёт с именем какой-нибудь стандартной команды, вместо этой команды
будет вызываться функция. 
----------------------------------------------------------------------
Массивы
----------------------------------------------------------------------
http://rus-linux.net/MyLDP/BOOKS/abs-guide/flat/abs-book.html#ARRAYS
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 7, Using sed — эта статья посвящена работе с 
потоковым текстовым редактором sed.
########################################################################
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 8, Using awk — данный материал посвящён
программированию на языке обработки данных awk.
########################################################################
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 9, Regular Expressions — тут можно почитать об
использовании регулярных выражений в bash-скриптах.
########################################################################
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 10, Practical Examples — здесь приведены приёмы
работы с сообщениями, которые можно отправлять пользователям, а так же
методика мониторинга диска.
########################################################################
----------------------------------------------------------------------
https://habrahabr.ru/company/ruvds/blog/328346/
----------------------------------------------------------------------
########################################################################
    Part 11, Expect Command — этот материал посвящён
средству Expect, с помощью которого можно автоматизировать взаимодействие
с интерактивными утилитами. В частности,
здесь идёт речь об expect-скриптах и об их взаимодействии с bash-скриптами
и другими программами.
########################################################################
----------------------------------------------------------------------
https://habrahabr.ru/company/ruvds/blog/328436/
----------------------------------------------------------------------
----------------------------------------------------------------------

----------------------------------------------------------------------

----------------------------------------------------------------------

----------------------------------------------------------------------

----------------------------------------------------------------------

----------------------------------------------------------------------

----------------------------------------------------------------------

----------------------------------------------------------------------

----------------------------------------------------------------------

----------------------------------------------------------------------

----------------------------------------------------------------------
