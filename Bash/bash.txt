
----------------------------------------------------------------------
			############
			#Оглавление#
			############
----------------------------------------------------------------------

########################################################################
    Part 1 — здесь речь идёт о том, как начать создание
bash-скриптов, рассмотрено использование переменных, описаны условные
конструкции, вычисления, сравнения чисел, строк, выяснение сведений о файлах.
########################################################################
----------------------------------------------------------------------
Использование переменных
----------------------------------------------------------------------
    Переменные среды
    Пользовательские переменные
----------------------------------------------------------------------
Подстановка команд
----------------------------------------------------------------------
    С помощью значка обратного апострофа «`»
    С помощью конструкции $()
----------------------------------------------------------------------
Математические операции
----------------------------------------------------------------------
Управляющая конструкция if-then
----------------------------------------------------------------------
Сравнение чисел
----------------------------------------------------------------------
Сравнение строк
----------------------------------------------------------------------
Проверки файлов
----------------------------------------------------------------------
########################################################################
    Part 2, Bash the awesome — тут раскрываются особенности
работы с циклами for и while.
########################################################################
----------------------------------------------------------------------
Циклы for
----------------------------------------------------------------------
Перебор простых значений
----------------------------------------------------------------------
Перебор сложных значений
----------------------------------------------------------------------
Инициализация цикла списком, полученным из результатов работы команды
----------------------------------------------------------------------
Разделители полей
----------------------------------------------------------------------
Internal Field Separator

    Пробел
    Знак табуляции
    Знак перевода строки
----------------------------------------------------------------------
Обход файлов, содержащихся в директории
----------------------------------------------------------------------
Циклы for в стиле C
----------------------------------------------------------------------
Цикл while
----------------------------------------------------------------------
Вложенные циклы
----------------------------------------------------------------------
Обработка содержимого файла
----------------------------------------------------------------------
Управление циклами
----------------------------------------------------------------------
    break
    continue
----------------------------------------------------------------------
Обработка вывода, выполняемого в цикле
----------------------------------------------------------------------
Пример: поиск исполняемых файлов
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 3, Parameters & options — этот материал посвящён
параметрам командной строки и ключам, которые можно передавать скриптам,
работе с данными, которые вводит пользователь, и которые можно читать из
файлов.
########################################################################
----------------------------------------------------------------------
Чтение параметров командной строки
----------------------------------------------------------------------
$0 — имя скрипта.
$1 — первый параметр.
$2 — второй параметр — и так далее, вплоть до переменной $9, в которую
попадает девятый параметр.
${10} — Если скрипту надо больше девяти параметров.
$# — содержит количество параметров, переданных сценарию при вызове.
$* —  содержит все параметры, введённые в командной строке, в виде единого «слова».
$@ — параметры разбиты на отдельные «слова». Эти параметры можно перебирать в циклах. 
$? - переменная с возвращенным командой return результатом. 
----------------------------------------------------------------------
Проверка параметров
----------------------------------------------------------------------
Подсчёт параметров
----------------------------------------------------------------------
Захват всех параметров командной строки
----------------------------------------------------------------------
Команда shift
----------------------------------------------------------------------
Ключи командной строки
----------------------------------------------------------------------
Как различать ключи и параметры
----------------------------------------------------------------------
    Эта последовательность — двойное тире (--).
----------------------------------------------------------------------
Обработка ключей со значениями
----------------------------------------------------------------------
Использование стандартных ключей
----------------------------------------------------------------------
Получение данных от пользователя
----------------------------------------------------------------------
Ввод паролей
----------------------------------------------------------------------
Чтение данных из файла
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 4, Input & Output — здесь речь идёт о дескрипторах
файлов и о работе с ними, о потоках ввода, вывода, ошибок, о перенаправлении
вывода.
########################################################################
----------------------------------------------------------------------
Стандартные дескрипторы файлов
----------------------------------------------------------------------
Перенаправление вывода в скриптах
----------------------------------------------------------------------

    Временное перенаправление, или перенаправление вывода одной строки.
    Постоянное перенаправление, или перенаправление всего вывода в
	скрипте либо в какой-то его части.

----------------------------------------------------------------------
Временное перенаправление вывода
----------------------------------------------------------------------
Постоянное перенаправление вывода
----------------------------------------------------------------------
Перенаправление ввода в скриптах
----------------------------------------------------------------------
Создание собственного перенаправления вывода
----------------------------------------------------------------------
Создание дескрипторов файлов для ввода данных
----------------------------------------------------------------------
Закрытие дескрипторов файлов
----------------------------------------------------------------------
Получение сведений об открытых дескрипторах
----------------------------------------------------------------------
Подавление вывода
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 5, Sighals & Jobs — этот материал посвящён сигналам
Linux, их обработке в скриптах, запуску сценариев по расписанию.
########################################################################
----------------------------------------------------------------------
Сигналы Linux
----------------------------------------------------------------------
Отправка сигналов скриптам
----------------------------------------------------------------------
	Завершение работы процесса
----------------------------------------------------------------------
	Временная остановка процесса
----------------------------------------------------------------------
	Завершить работу приостановленного процесса
----------------------------------------------------------------------
Перехват сигналов
----------------------------------------------------------------------
Перехват сигнала выхода из скрипта
----------------------------------------------------------------------
Модификация перехваченных сигналов и отмена перехвата
----------------------------------------------------------------------
Выполнение сценариев командной строки в фоновом режиме
----------------------------------------------------------------------
$ ./myscipt &
----------------------------------------------------------------------
Выполнение скриптов, не завершающих работу при закрытии терминала
----------------------------------------------------------------------
nohup ./myscript &
----------------------------------------------------------------------
Просмотр заданий
----------------------------------------------------------------------
Перезапуск приостановленных заданий
----------------------------------------------------------------------
Планирование запуска скриптов
----------------------------------------------------------------------
Удаление заданий, ожидающих выполнения
----------------------------------------------------------------------
Запуск скриптов по расписанию
----------------------------------------------------------------------
Запуск скриптов при входе в систему и при запуске оболочки
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 6, Functions — тут можно узнать о создании и
использовании функций в скриптах, о разработке библиотек.
########################################################################
----------------------------------------------------------------------
Объявление функций
----------------------------------------------------------------------
Использование функций
----------------------------------------------------------------------
Использование команды return
----------------------------------------------------------------------
Запись вывода функции в переменную
----------------------------------------------------------------------
Аргументы функций
----------------------------------------------------------------------
Работа с переменными в функциях
----------------------------------------------------------------------
Существуют два вида переменных:

    Глобальные переменные.
    Локальные переменные.

----------------------------------------------------------------------
Глобальные переменные
----------------------------------------------------------------------
Локальные переменные
----------------------------------------------------------------------
Передача функциям массивов в качестве аргументов
----------------------------------------------------------------------
Рекурсивные функции
----------------------------------------------------------------------
Создание и использование библиотек
----------------------------------------------------------------------
Вызов bash-функций из командной строки
----------------------------------------------------------------------
Массивы
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 7, Using sed — эта статья посвящена работе с 
потоковым текстовым редактором sed.
########################################################################
----------------------------------------------------------------------
Основы работы с sed
----------------------------------------------------------------------
	«s» — это сокращение слова «substitute», то есть — перед нами
	команда замены. 
----------------------------------------------------------------------
Выполнение наборов команд при вызове sed
----------------------------------------------------------------------
	Для выполнения нескольких действий с данными, используйте
	ключ -e при вызове sed. 
----------------------------------------------------------------------
Чтение команд из файла
----------------------------------------------------------------------
	Для того, чтобы указать sed файл, содержащий команды, используют
	ключ -f:
----------------------------------------------------------------------
Флаги команды замены
----------------------------------------------------------------------
	При передаче номера учитывается порядковый номер вхождения шаблона
	в строку, заменено будет именно это вхождение.
	Флаг g указывает на то, что нужно обработать все вхождения шаблона,
	имеющиеся в строке.
	Флаг p указывает на то, что нужно вывести содержимое исходной строки.
	Флаг вида w file указывает команде на то, что нужно записать
	результаты обработки текста в файл.
----------------------------------------------------------------------
	ключ -n, указанный при вызове sed, подавляет обычный вывод:
----------------------------------------------------------------------
Символы-разделители
----------------------------------------------------------------------
Выбор фрагментов текста для обработки
----------------------------------------------------------------------
Удаление строк
----------------------------------------------------------------------
	используя команду d, можно удалять строки из текстового потока.
----------------------------------------------------------------------
Вставка текста в поток
----------------------------------------------------------------------
	Команда i добавляет новую строку перед заданной.
	Команда a добавляет новую строку после заданной.
----------------------------------------------------------------------
Замена строк
----------------------------------------------------------------------
	Команда c позволяет изменить содержимое целой строки текста в потоке
	данных. При её вызове нужно указать номер строки, вместо которой в
	поток надо добавить новые данные:
----------------------------------------------------------------------
Замена символов
----------------------------------------------------------------------
	Команда y работает с отдельными символами, заменяя их в
	соответствии с переданными ей при вызове данными:
----------------------------------------------------------------------
Вывод номеров строк
----------------------------------------------------------------------
	Если вызвать sed, использовав команду =, утилита выведет номера строк
	в потоке данных:
----------------------------------------------------------------------
	Если передать этой команде шаблон и воспользоваться ключом sed -n,
	выведены будут только номера строк, соответствующих шаблону:
----------------------------------------------------------------------
Чтение данных для вставки из файла
----------------------------------------------------------------------
Пример
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 8, Using awk — данный материал посвящён
программированию на языке обработки данных awk.
########################################################################
----------------------------------------------------------------------
Язык программирования awk 
----------------------------------------------------------------------
Особенности вызова awk
----------------------------------------------------------------------
Чтение awk-скриптов из командной строки
----------------------------------------------------------------------
Позиционные переменные, хранящие данные полей
----------------------------------------------------------------------
Использование нескольких команд
----------------------------------------------------------------------
Чтение скрипта awk из файла
----------------------------------------------------------------------
Выполнение команд до начала обработки данных
----------------------------------------------------------------------
Выполнение команд после окончания обработки данных
----------------------------------------------------------------------
Встроенные переменные: настройка процесса обработки данных
----------------------------------------------------------------------
Встроенные переменные: сведения о данных и об окружении
----------------------------------------------------------------------
Пользовательские переменные
----------------------------------------------------------------------
Условный оператор
----------------------------------------------------------------------
Цикл while 
----------------------------------------------------------------------
Цикл for
----------------------------------------------------------------------
Форматированный вывод данных
----------------------------------------------------------------------
Спецификатор форматирования
----------------------------------------------------------------------
Встроенные математические функции
----------------------------------------------------------------------
Строковые функции
----------------------------------------------------------------------
Пользовательские функции
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 9, Regular Expressions — тут можно почитать об
использовании регулярных выражений в bash-скриптах.
########################################################################
----------------------------------------------------------------------
Что такое регулярные выражения
----------------------------------------------------------------------
Типы регулярных выражений
----------------------------------------------------------------------

    Движок, поддерживающий стандарт POSIX Basic Regular Expression (BRE).
    Движок, поддерживающий стандарт POSIX Extended Regular Expression (ERE).

----------------------------------------------------------------------
Регулярные выражения POSIX BRE
----------------------------------------------------------------------
Специальные символы
----------------------------------------------------------------------
Якорные символы
----------------------------------------------------------------------
Символ «точка»
----------------------------------------------------------------------
Классы символов
----------------------------------------------------------------------
Отрицание классов символов
----------------------------------------------------------------------
Диапазоны символов
----------------------------------------------------------------------
Специальные классы символов
----------------------------------------------------------------------
Символ «звёздочка»
----------------------------------------------------------------------
Звёздочку можно использовать и с классами символов:
----------------------------------------------------------------------
Регулярные выражения POSIX ERE
----------------------------------------------------------------------
	awk поддерживает этот стандарт, а вот sed — нет
----------------------------------------------------------------------
Вопросительный знак
----------------------------------------------------------------------
Вопросительный знак можно использовать и с классами символов:
----------------------------------------------------------------------
Символ «плюс»
----------------------------------------------------------------------
Символ «плюс» работает и с классами символов.
----------------------------------------------------------------------
Фигурные скобки
----------------------------------------------------------------------
Фигурные скобки можно применять и с классами символов.
----------------------------------------------------------------------
Символ логического «или»
----------------------------------------------------------------------
Группировка фрагментов регулярных выражений
----------------------------------------------------------------------
Практические примеры
----------------------------------------------------------------------
Подсчёт количества файлов
----------------------------------------------------------------------
Проверка адресов электронной почты
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 10, Practical Examples — здесь приведены приёмы
работы с сообщениями, которые можно отправлять пользователям, а так же
методика мониторинга диска.
########################################################################
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 11, Expect Command — этот материал посвящён
средству Expect, с помощью которого можно автоматизировать взаимодействие
с интерактивными утилитами. В частности,
здесь идёт речь об expect-скриптах и об их взаимодействии с bash-скриптами
и другими программами.
########################################################################
----------------------------------------------------------------------
########################################################################
Advanced Bash-Scripting Guide
Искусство программирования на языке сценариев командной оболочки
http://rus-linux.net/MyLDP/BOOKS/abs-guide/flat/abs-book.html
########################################################################
----------------------------------------------------------------------
			#########
			#Учебник#
			#########
----------------------------------------------------------------------

########################################################################
    Part 1 — здесь речь идёт о том, как начать создание
bash-скриптов, рассмотрено использование переменных, описаны условные
конструкции, вычисления, сравнения чисел, строк, выяснение сведений о файлах.
########################################################################
----------------------------------------------------------------------
Скрипт
----------------------------------------------------------------------
#!/bin/bash
# our comment is here
echo "The current directory is:"
pwd
echo "The user logged in is:"
whoami
----------------------------------------------------------------------
chmod +x ./myscript
----------------------------------------------------------------------
./myscript
----------------------------------------------------------------------
Использование переменных
----------------------------------------------------------------------
    Переменные среды
	https://likegeeks.com/linux-environment-variables/
----------------------------------------------------------------------
#!/bin/bash
# display user home
echo "Home for the current user is: $HOME"
echo "I have \$1 in my pocket"
----------------------------------------------------------------------
    Пользовательские переменные
----------------------------------------------------------------------
#!/bin/bash
# testing variables
grade=5
person="Oleg"
echo "$person is a good boy, he is in grade $grade"
----------------------------------------------------------------------
Подстановка команд
----------------------------------------------------------------------
Сделать это можно двумя способами.

    С помощью значка обратного апострофа «`»
    С помощью конструкции $()
----------------------------------------------------------------------
mydir=`pwd`
mydir=$(pwd)

#!/bin/bash
mydir=$(pwd)
echo $mydir
----------------------------------------------------------------------
Математические операции
----------------------------------------------------------------------
$((a+b))

#!/bin/bash
var1=$(( 5 + 5 ))
echo $var1
var2=$(( $var1 * 2 ))
echo $var2
----------------------------------------------------------------------
Управляющая конструкция if-then
----------------------------------------------------------------------
if команда
then
команды
fi
----------------------------------------------------------------------
#!/bin/bash
if pwd
then
echo "It works"
fi
----------------------------------------------------------------------
#!/bin/bash
user=likegeeks
if grep $user /etc/passwd
then
echo "The user $user Exists"
fi
----------------------------------------------------------------------
if команда
then
команды
else
команды
fi
----------------------------------------------------------------------
#!/bin/bash
user=anotherUser
if grep $user /etc/passwd
then
echo "The user $user Exists"
else
echo "The user $user doesn’t exist"
fi
----------------------------------------------------------------------
if команда1
then
команды
elif команда2
then
команды
fi
----------------------------------------------------------------------
#!/bin/bash
user=anotherUser
if grep $user /etc/passwd
then
echo "The user $user Exists"
elif ls /home
then
echo "The user doesn’t exist but anyway there is a directory under /home"
fi
----------------------------------------------------------------------
Сравнение чисел
----------------------------------------------------------------------
n1 -eq n2Возвращает истинное значение, если n1 равно n2.
n1 -ge n2 Возвращает истинное значение, если n1больше или равно n2.
n1 -gt n2Возвращает истинное значение, если n1 больше n2.
n1 -le n2Возвращает истинное значение, если n1меньше или равно n2.
n1 -lt n2Возвращает истинное значение, если n1 меньше n2.
n1 -ne n2Возвращает истинное значение, если n1не равно n2.
----------------------------------------------------------------------
#!/bin/bash
val1=6
if [ $val1 -gt 5 ]
then
echo "The test value $val1 is greater than 5"
else
echo "The test value $val1 is not greater than 5"
fi
----------------------------------------------------------------------
Сравнение строк
----------------------------------------------------------------------
str1 = str2 Проверяет строки на равенство, возвращает истину, если строки идентичны.
str1 != str2Возвращает истину, если строки не идентичны.
str1 < str2Возвращает истину, если str1меньше, чем str2.
str1 > str2 Возвращает истину, если str1больше, чем str2.
-n str1 Возвращает истину, если длина str1больше нуля.
-z str1Возвращает истину, если длина str1равна нулю.
----------------------------------------------------------------------
#!/bin/bash
user ="likegeeks"
if [$user = $USER]
then
echo "The user $user  is the current logged in user"
fi
----------------------------------------------------------------------
Вот одна особенность сравнения строк, о которой стоит упомянуть. А именно,
операторы «>» и «<» необходимо экранировать  помощью обратной косой черты,
иначе скрипт будет работать неправильно, хотя сообщений об ошибках и не
появится. Скрипт интерпретирует знак «>» как команду перенаправления вывода.
----------------------------------------------------------------------
#!/bin/bash
val1=text
val2="another text"
if [ $val1 \> "$val2" ]
then
echo "$val1 is greater than $val2"
else
echo "$val1 is less than $val2"
fi
----------------------------------------------------------------------
Ещё одна особенность операторов «>» и «<» заключается в том, как они
работают с символами в верхнем и нижнем регистрах. Для того, чтобы понять
эту особенность, подготовим текстовый файл с таким содержимым:
----------------------------------------------------------------------
Создадим файл

Likegeeks
likegeeks

дав имя myfile
----------------------------------------------------------------------
sort myfile

Команда sort, по умолчанию, сортирует строки по возрастанию, то есть
строчная буква в нашем примере меньше прописной. 
----------------------------------------------------------------------
likegeeks
Likegeeks
----------------------------------------------------------------------
#!/bin/bash
val1=Likegeeks
val2=likegeeks
if [ $val1 \> $val2 ]
then
echo "$val1 is greater than $val2"
else
echo "$val1 is less than $val2"
fi
----------------------------------------------------------------------
Likegeeks is less than likegeeks
----------------------------------------------------------------------
В командах сравнения прописные буквы меньше строчных. Сравнение строк
здесь выполняется путём сравнения ASCII-кодов символов, порядок сортировки,
таким образом, зависит от кодов символов.

Команда sort, в свою очередь, использует порядок сортировки, заданный в
настройках системного языка.
----------------------------------------------------------------------
Проверки файлов
----------------------------------------------------------------------
-d fileПроверяет, существует ли файл, и является ли он директорией.
-e fileПроверяет, существует ли файл.
-f file Проверяет, существует ли файл, и является ли он файлом.
-r fileПроверяет, существует ли файл, и доступен ли он для чтения.
-s file Проверяет, существует ли файл, и не является ли он пустым.
-w fileПроверяет, существует ли файл, и доступен ли он для записи.
-x fileПроверяет, существует ли файл, и является ли он исполняемым.
file1 -nt file2 Проверяет, новее ли file1, чем file2.
file1 -ot file2Проверяет, старше ли file1, чем file2.
-O file Проверяет, существует ли файл, и является ли его владельцем текущий пользователь.
-G fileПроверяет, существует ли файл, и соответствует ли его идентификатор группы идентификатору группы текущего пользователя.
----------------------------------------------------------------------
#!/bin/bash
mydir=/home/likegeeks
if [ -d $mydir ]
then
echo "The $mydir directory exists"
cd $ mydir
ls
else
echo "The $mydir directory does not exist"
fi

Этот скрипт, для существующей директории, выведет её содержимое.
----------------------------------------------------------------------
########################################################################
    Part 2, Bash the awesome — тут раскрываются особенности
работы с циклами for и while.
########################################################################
----------------------------------------------------------------------
Циклы for
----------------------------------------------------------------------
for var in list
do
команды
done
----------------------------------------------------------------------
Перебор простых значений
----------------------------------------------------------------------
#!/bin/bash
for var in first second third fourth fifth
do
echo The  $var item
done
----------------------------------------------------------------------
Перебор сложных значений
----------------------------------------------------------------------
#!/bin/bash
for var in first "the second" "the third" "I’ll do it"
do
echo "This is: $var"
done
----------------------------------------------------------------------
Инициализация цикла списком, полученным из результатов работы команды
----------------------------------------------------------------------
#!/bin/bash
file="myfile"
for var in $(cat $file)
do
echo " $var"
done
----------------------------------------------------------------------
Разделители полей
----------------------------------------------------------------------
Internal Field Separator

    Пробел
    Знак табуляции
    Знак перевода строки

----------------------------------------------------------------------
IFS=$'\n'
----------------------------------------------------------------------
#!/bin/bash
file="/etc/passwd"
IFS=$'\n'
for var in $(cat $file)
do
echo " $var"
done
----------------------------------------------------------------------
IFS=:
/etc/passwd
----------------------------------------------------------------------
Обход файлов, содержащихся в директории
----------------------------------------------------------------------
#!/bin/bash
for file in /home/likegeeks/*
do
if [ -d "$file" ]
then
echo "$file is a directory"
elif [ -f "$file" ]
then
echo "$file is a file"
fi
done
----------------------------------------------------------------------
Циклы for в стиле C
----------------------------------------------------------------------
for (( начальное значение переменной ; условие окончания цикла; изменение переменной ))
for (( a = 1; a < 10; a++ ))
----------------------------------------------------------------------
#!/bin/bash
for (( i=1; i <= 10; i++ ))
do
echo "number is $i"
done
----------------------------------------------------------------------
Цикл while
----------------------------------------------------------------------
while команда проверки условия
do
другие команды
done
----------------------------------------------------------------------
#!/bin/bash
var1=5
while [ $var1 -gt 0 ]
do
echo $var1
var1=$[ $var1 - 1 ]
done
----------------------------------------------------------------------
Вложенные циклы
----------------------------------------------------------------------
#!/bin/bash
for (( a = 1; a <= 3; a++ ))
do
echo "Start $a:"
for (( b = 1; b <= 3; b++ ))
do
echo " Inner loop: $b"
done
done
----------------------------------------------------------------------
Обработка содержимого файла
----------------------------------------------------------------------
#!/bin/bash
IFS=$'\n'
for entry in $(cat /etc/passwd)
do
echo "Values in $entry –"
IFS=:
for value in $entry
do
echo " $value"
done
done
----------------------------------------------------------------------
Управление циклами
----------------------------------------------------------------------

    break
    continue

----------------------------------------------------------------------
Команда break
----------------------------------------------------------------------
Эта команда позволяет прервать выполнение цикла. Её можно использовать
и для циклов for, и для циклов while:
----------------------------------------------------------------------
#!/bin/bash
for var1 in 1 2 3 4 5 6 7 8 9 10
do
if [ $var1 -eq 5 ]
then
break
fi
echo "Number: $var1"
done
----------------------------------------------------------------------
Команда continue
----------------------------------------------------------------------
Когда в теле цикла встречается эта команда, текущая итерация завершается
досрочно и начинается следующая, при этом выхода из цикла не происходит. 
----------------------------------------------------------------------
#!/bin/bash
for (( var1 = 1; var1 < 15; var1++ ))
do
if [ $var1 -gt 5 ] && [ $var1 -lt 10 ]
then
continue
fi
echo "Iteration number: $var1"
done
----------------------------------------------------------------------
Когда условие внутри цикла выполняется, то есть, когда $var1 больше 5
и меньше 10, оболочка исполняет команду continue. Это приводит к
пропуску оставшихся в теле цикла команд и переходу к следующей итерации.
----------------------------------------------------------------------
Обработка вывода, выполняемого в цикле
----------------------------------------------------------------------
#!/bin/bash
for (( a = 1; a < 10; a++ ))
do
echo "Number is $a"
done > myfile.txt
echo "finished."
----------------------------------------------------------------------
Пример: поиск исполняемых файлов
----------------------------------------------------------------------
#!/bin/bash
IFS=:
for folder in $PATH
do
echo "$folder:"
for file in $folder/*
do
if [ -x $file ]
then
echo " $file"
fi
done
done
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 3, Parameters & options — этот материал посвящён
параметрам командной строки и ключам, которые можно передавать скриптам,
работе с данными, которые вводит пользователь, и которые можно читать из
файлов.
########################################################################
----------------------------------------------------------------------
$ ./myscript 10 20
----------------------------------------------------------------------
Чтение параметров командной строки
----------------------------------------------------------------------
$0 — имя скрипта.
$1 — первый параметр.
$2 — второй параметр — и так далее, вплоть до переменной $9, в которую
попадает девятый параметр.
${10} — Если скрипту надо больше девяти параметров.
$# — содержит количество параметров, переданных сценарию при вызове.
$* —  содержит все параметры, введённые в командной строке, в виде единого «слова».
$@ — параметры разбиты на отдельные «слова». Эти параметры можно перебирать в циклах. 

$? - переменная с возвращенным командой return результатом.
Если вы выполните любую другую команду до извлечения из переменной $? значения,
возвращённого функцией, это значение будет утеряно. Дело в том, что
данная переменная хранит код возврата последней выполненной команды.

Учтите, что максимальное число, которое может вернуть команда
return — 255. Если функция должна возвращать большее число или строку,
понадобится другой подход.
----------------------------------------------------------------------
#!/bin/bash
echo $0
echo $1
echo $2
echo $3
----------------------------------------------------------------------
#!/bin/bash
total=$[ $1 + $2 ]
echo The first parameter is $1.
echo The second parameter is $2.
echo The sum is $total.
----------------------------------------------------------------------
Что если параметр содержит пробелы, а нам надо обрабатывать его как
самостоятельный фрагмент данных? Полагаем, если вы освоили предыдущие
части этого руководства, ответ вы уже знаете. Заключается он в
использовании кавычек.
----------------------------------------------------------------------
Проверка параметров
----------------------------------------------------------------------
#!/bin/bash
if [ -n "$1" ]
then
echo Hello $1.
else
echo "No parameters found. "
fi
----------------------------------------------------------------------
Подсчёт параметров
----------------------------------------------------------------------
#!/bin/bash
echo There were $# parameters passed.
----------------------------------------------------------------------
Эта переменная даёт необычный способ получения последнего из переданных
скрипту параметров, не требующий знания их количества. Вот как это выглядит:
----------------------------------------------------------------------
#!/bin/bash
echo The last parameter was ${!#}
----------------------------------------------------------------------
Захват всех параметров командной строки
----------------------------------------------------------------------
#!/bin/bash
count=1
for param in "$*"
do
echo "\$* Parameter #$count = $param"
count=$(( $count + 1 ))
done
count=1
for param in "$@"
do
echo "\$@ Parameter #$count = $param"
count=$(( $count + 1 ))
done
----------------------------------------------------------------------
Команда shift
----------------------------------------------------------------------
Использовать команду shift в bash-скриптах следует с осторожностью, так
как она, в прямом смысле слова, сдвигает значения позиционных параметров.
----------------------------------------------------------------------
Когда вы используете эту команду, она, по умолчанию, сдвигает значения
позиционных параметров влево. Например, значение переменной $3 становится
значением переменной $2, значение $2 переходит в $1, а то, что было до
этого в $1, теряется. Обратите внимание на то, что при этом значение
переменной $0, содержащей имя скрипта, не меняется.
----------------------------------------------------------------------
#!/bin/bash
count=1
while [ -n "$1" ]
do
echo "Parameter #$count = $1"
count=$(( $count + 1 ))
shift
done
----------------------------------------------------------------------
Скрипт задействует цикл while, проверяя длину значения первого параметра.
Когда длина станет равна нулю, происходит выход из цикла. После проверки
первого параметра и вывода его на экран, вызывается команда shift, которая
сдвигает значения параметров на одну позицию.
----------------------------------------------------------------------
Ключи командной строки
----------------------------------------------------------------------
Ключи командной строки обычно выглядят как буквы, перед которыми
ставится тире. Они служат для управления сценариями. 
----------------------------------------------------------------------
#!/bin/bash
echo
while [ -n "$1" ]
do
case "$1" in
-a) echo "Found the -a option" ;;
-b) echo "Found the -b option" ;;
-c) echo "Found the -c option" ;;
*) echo "$1 is not an option" ;;
esac
shift
done
----------------------------------------------------------------------
$ ./myscript –a –b –c –d
----------------------------------------------------------------------
Как различать ключи и параметры
----------------------------------------------------------------------
Стандартный способ это сделать заключается в применении специальной
последовательности символов, которая сообщает скрипту о том, когда
заканчиваются ключи и начинаются обычные параметры.
----------------------------------------------------------------------
Эта последовательность — двойное тире (--).

Оболочка использует её для указания позиции, на которой заканчивается
список ключей. После того, как скрипт обнаружит признак окончания
ключей, то, что осталось, можно, не опасаясь ошибок, обрабатывать как
параметры, а не как ключи. 
----------------------------------------------------------------------
#!/bin/bash
while [ -n "$1" ]
do
case "$1" in
-a) echo "Found the -a option" ;;
-b) echo "Found the -b option";;
-c) echo "Found the -c option" ;;
--) shift
break ;;
*) echo "$1 is not an option";;
esac
shift
done
count=1
for param in $@
do
echo "Parameter #$count: $param"
count=$(( $count + 1 ))
done
----------------------------------------------------------------------
$ ./myscript –a –b –c –d -- 5 10 15
----------------------------------------------------------------------
Обработка ключей со значениями
----------------------------------------------------------------------
./myscript -a test1 -b -c test2
----------------------------------------------------------------------
#!/bin/bash
while [ -n "$1" ]
do
case "$1" in
-a) echo "Found the -a option";;
-b) param="$2"
echo "Found the -b option, with parameter value $param"
shift ;;
-c) echo "Found the -c option";;
--) shift
break ;;
*) echo "$1 is not an option";;
esac
shift
done
count=1
for param in "$@"
do
echo "Parameter #$count: $param"
count=$(( $count + 1 ))
done
----------------------------------------------------------------------
В данном примере в конструкции case обрабатываются три ключа. Ключ -b
требует наличия дополнительного параметра. Так как обрабатываемый ключ
находится в переменной $1, соответствующий ему параметр будет
находиться в $2 (тут используется команда shift, поэтому, по мере
обработки, всё, что передано сценарию, сдвигается влево). Когда с этим
мы разобрались, осталось лишь извлечь значение переменной $2 и у нас
будет параметр нужного ключа. Конечно, тут понадобится ещё одна команда
shift для того, чтобы следующий ключ попал в $1
----------------------------------------------------------------------
Использование стандартных ключей
----------------------------------------------------------------------
Однако, в мире Linux значения некоторых ключей стали чем-то вроде
стандарта, которого полезно придерживаться. Вот список этих ключей:
----------------------------------------------------------------------
-a Вывести все объекты.
-c Произвести подсчёт.
-d Указать директорию.
-e Развернуть объект.
-f Указать файл, из которого нужно прочитать данные.
-h Вывести справку по команде.
-i Игнорировать регистр символов.
-l Выполнить полноформатный вывод данных.
-n Использовать неинтерактивный (пакетный) режим.
-o Позволяет указать файл, в который нужно перенаправить вывод.
-q Выполнить скрипт в quiet-режиме.
-r Обрабатывать папки и файлы рекурсивно.
-s Выполнить скрипт в silent-режиме.
-v Выполнить многословный вывод.
-x Исключить объект.
-y Ответить «yes» на все вопросы.
----------------------------------------------------------------------
Получение данных от пользователя
----------------------------------------------------------------------
#!/bin/bash
echo -n "Enter your name: "
read name
echo "Hello $name, welcome to my program."
----------------------------------------------------------------------
#!/bin/bash
read -p "Enter your name: " first last
echo "Your data for $last, $first…"
----------------------------------------------------------------------
Если, вызвав read, не указывать переменную, данные, введённые
пользователем, будут помещены в специальную переменную среды REPLY:
----------------------------------------------------------------------
#!/bin/bash
read -p "Enter your name: "
echo Hello $REPLY, welcome to my program.
----------------------------------------------------------------------
Если скрипт должен продолжать выполнение независимо от того, введёт
пользователь какие-то данные или нет, вызывая команду read можно
воспользоваться ключом -t. А именно, параметр ключа задаёт время
ожидания ввода в секундах:
----------------------------------------------------------------------
#!/bin/bash
if read -t 5 -p "Enter your name: " name
then
echo "Hello $name, welcome to my script"
else
echo "Sorry, too slow! "
fi
----------------------------------------------------------------------
Если данные не будут введены в течение 5 секунд, скрипт выполнит ветвь
условного оператора else, выведя извинения.
----------------------------------------------------------------------
Ввод паролей
----------------------------------------------------------------------
#!/bin/bash
read -s -p "Enter your password: " pass
echo "Is your password really $pass? "
----------------------------------------------------------------------
Чтение данных из файла
----------------------------------------------------------------------
Команда read может, при каждом вызове, читать одну строку текста из
файла. Когда в файле больше не останется непрочитанных строк, она
просто остановится. Если нужно получить в скрипте всё содержимое файла,
можно, с помощью конвейера, передать результаты вызова команды cat для
файла, конструкции while, которая содержит команду read
----------------------------------------------------------------------
#!/bin/bash
count=1
cat myfile | while read line
do
echo "Line $count: $line"
count=$(( $count + 1 ))
done
echo "Finished"
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 4, Input & Output — здесь речь идёт о дескрипторах
файлов и о работе с ними, о потоках ввода, вывода, ошибок, о перенаправлении
вывода.
########################################################################
----------------------------------------------------------------------
Стандартные дескрипторы файлов
----------------------------------------------------------------------
Всё в Linux — это файлы, в том числе — ввод и вывод. Операционная
система идентифицирует файлы с использованием дескрипторов.

Каждому процессу позволено иметь до девяти открытых дескрипторов файлов.
Оболочка bash резервирует первые три дескриптора с идентификаторами
0, 1 и 2. Вот что они означают.
----------------------------------------------------------------------

    0, STDIN — стандартный поток ввода.
    1, STDOUT — стандартный поток вывода.
    2, STDERR — стандартный поток ошибок.

----------------------------------------------------------------------
cat ./myfile
pwd >> myfile
ls -l xfile 2>myfile
----------------------------------------------------------------------
ls –l myfile xfile anotherfile 2> errorcontent 1> correctcontent
----------------------------------------------------------------------
Если надо, и STDERR, и STDOUT можно перенаправить в один и тот же файл,
воспользовавшись командой &>:
----------------------------------------------------------------------
Перенаправление вывода в скриптах
----------------------------------------------------------------------
Существует два метода перенаправления вывода в сценариях командной строки:

    Временное перенаправление, или перенаправление вывода одной строки.
    Постоянное перенаправление, или перенаправление всего вывода в
	скрипте либо в какой-то его части.

----------------------------------------------------------------------
Временное перенаправление вывода
----------------------------------------------------------------------
#!/bin/bash
echo "This is an error" >&2
echo "This is normal output"
----------------------------------------------------------------------
./myscript 2> myfile
----------------------------------------------------------------------
Постоянное перенаправление вывода
----------------------------------------------------------------------
#!/bin/bash
exec 1>outfile
echo "This is a test of redirecting all output"
echo "from a shell script to another file."
echo "without having to redirect every line"
----------------------------------------------------------------------
можно задать перенаправление вывода в определённый дескриптор на время
выполнения скрипта, воспользовавшись командой exec:
----------------------------------------------------------------------
Команду exec можно использовать не только в начале скрипта, но и в
других местах:
----------------------------------------------------------------------
#!/bin/bash
exec 2>myerror
echo "This is the start of the script"
echo "now redirecting all output to another location"
exec 1>myfile
echo "This should go to the myfile file"
echo "and this should go to the myerror file" >&2
----------------------------------------------------------------------
Перенаправление ввода в скриптах
----------------------------------------------------------------------
exec 0< myfile
----------------------------------------------------------------------
#!/bin/bash
exec 0< testfile
count=1
while read line
do
echo "Line #$count: $line"
count=$(( $count + 1 ))
done
----------------------------------------------------------------------
Создание собственного перенаправления вывода
----------------------------------------------------------------------
с номерами от 3 до 8, можно использовать для перенаправления ввода или
вывода. Любой из них можно назначить файлу и использовать в коде скрипта.
----------------------------------------------------------------------
#!/bin/bash
exec 3>myfile
echo "This should display on the screen"
echo "and this should be stored in the file" >&3
echo "And this should be back on the screen"
----------------------------------------------------------------------
Создание дескрипторов файлов для ввода данных
----------------------------------------------------------------------
#!/bin/bash
exec 6<&0
exec 0< myfile
count=1
while read line
do
echo "Line #$count: $line"
count=$(( $count + 1 ))
done
exec 0<&6
read -p "Are you done now? " answer
case $answer in
y) echo "Goodbye";;
n) echo "Sorry, this is the end.";;
esac
----------------------------------------------------------------------

Перенаправить ввод в скрипте можно точно так же, как и вывод. Сохраните
STDIN в другом дескрипторе, прежде чем перенаправлять ввод данных.

После окончания чтения файла можно восстановить STDIN и пользоваться
им как обычно:
----------------------------------------------------------------------
В этом примере дескриптор файла 6 использовался для хранения ссылки на
STDIN. Затем было сделано перенаправление ввода, источником данных для
STDIN стал файл. После этого входные данные для команды read поступали
из перенаправленного STDIN, то есть из файла.

После чтения файла мы возвращаем STDIN в исходное состояние,
перенаправляя его в дескриптор 6. Теперь, для того, чтобы проверить,
что всё работает правильно, скрипт задаёт пользователю вопрос, ожидает
ввода с клавиатуры и обрабатывает то, что введено.
----------------------------------------------------------------------
Закрытие дескрипторов файлов
----------------------------------------------------------------------
Оболочка автоматически закрывает дескрипторы файлов после завершения
работы скрипта. Однако, в некоторых случаях нужно закрывать дескрипторы
вручную, до того, как скрипт закончит работу. Для того, чтобы закрыть
дескриптор, его нужно перенаправить в &-.
----------------------------------------------------------------------
#!/bin/bash
exec 3> myfile
echo "This is a test line of data" >&3
exec 3>&-
echo "This won't work" >&3
----------------------------------------------------------------------
После исполнения скрипта мы получим сообщение об ошибке.
----------------------------------------------------------------------
Всё дело в том, что мы попытались обратиться к несуществующему дескриптору.

Будьте внимательны, закрывая дескрипторы файлов в сценариях. Если вы
отправляли данные в файл, потом закрыли дескриптор, потом — открыли снова,
оболочка заменит существующий файл новым. То есть всё то, что было
записано в этот файл ранее, будет утеряно.
----------------------------------------------------------------------
Получение сведений об открытых дескрипторах
----------------------------------------------------------------------
Для того, чтобы получить список всех открытых в Linux дескрипторов,
можно воспользоваться командой lsof.
----------------------------------------------------------------------
-p Позволяет указать ID процесса.
-d Позволяет указать номер дескриптора, о котором надо получить сведения.
----------------------------------------------------------------------
Для того, чтобы узнать PID текущего процесса, можно использовать
специальную переменную окружения $$, в которую оболочка записывает текущий PID.
----------------------------------------------------------------------
lsof -a -p $$ -d 0,1,2
----------------------------------------------------------------------
Тип файлов, связанных с STDIN, STDOUT и STDERR — CHR (character mode,
символьный режим). Так как все они указывают на терминал, имя файла
соответствует имени устройства, назначенного терминалу. Все три
стандартных файла доступны и для чтения, и для записи.
----------------------------------------------------------------------
#!/bin/bash
exec 3> myfile1
exec 6> myfile2
exec 7< myfile3
lsof -a -p $$ -d 0,1,2,3,6,7
----------------------------------------------------------------------
Скрипт открыл два дескриптора для вывода (3 и 6) и один — для ввода (7).
Тут же показаны и пути к файлам, использованных для настройки дескрипторов.

----------------------------------------------------------------------
Подавление вывода
----------------------------------------------------------------------
ls -al badfile anotherfile 2> /dev/null
----------------------------------------------------------------------
cat /dev/null > myfile
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 5, Sighals & Jobs — этот материал посвящён сигналам
Linux, их обработке в скриптах, запуску сценариев по расписанию.
########################################################################
----------------------------------------------------------------------
Сигналы Linux
----------------------------------------------------------------------
1
	SIGHUP
	Закрытие терминала
2
	SIGINT
	Сигнал остановки процесса пользователем с терминала (CTRL + C)
3
	SIGQUIT
	Сигнал остановки процесса пользователем с терминала (CTRL + \) с дампом памяти
9
	SIGKILL
	Безусловное завершение процесса
15
	SIGTERM
	Сигнал запроса завершения процесса
17
	SIGSTOP
	Принудительная приостановка выполнения процесса, но не завершение его работы
18
	SIGTSTP
	Приостановка процесса с терминала (CTRL + Z), но не завершение работы
19
	SIGCONT
	Продолжение выполнения ранее остановленного процесса
----------------------------------------------------------------------
Отправка сигналов скриптам
----------------------------------------------------------------------
	Завершение работы процесса
----------------------------------------------------------------------
CTRL + C генерирует сигнал SIGINT и отправляет его всем процессам
----------------------------------------------------------------------
	Временная остановка процесса
----------------------------------------------------------------------
CTRL + Z позволяет сгенерировать сигнал SIGTSTP, который
	приостанавливает работу процесса, но не завершает его выполнение.
----------------------------------------------------------------------
	Завершить работу приостановленного процесса
----------------------------------------------------------------------
kill processID
----------------------------------------------------------------------
Перехват сигналов
----------------------------------------------------------------------
Для того, чтобы включить в скрипте отслеживание сигналов Linux,
используется команда trap. Если скрипт получает сигнал, указанный при
вызове этой команды, он обрабатывает его самостоятельно, при этом
оболочка такой сигнал обрабатывать не будет.

----------------------------------------------------------------------
#!/bin/bash
trap "echo ' Trapped Ctrl-C'" SIGINT
echo This is a test script
count=1
while [ $count -le 10 ]
do
echo "Loop #$count"
sleep 1
count=$(( $count + 1 ))
done
----------------------------------------------------------------------
Перехват сигнала выхода из скрипта
----------------------------------------------------------------------
#!/bin/bash
trap "echo Goodbye..." EXIT
count=1
while [ $count -le 5 ]
do
echo "Loop #$count"
sleep 1
count=$(( $count + 1 ))
done
----------------------------------------------------------------------
При выходе из скрипта, будь то нормальное завершение его работы или
завершение, вызванное сигналом SIGINT, сработает перехват и оболочка
исполнит команду echo.

----------------------------------------------------------------------
Модификация перехваченных сигналов и отмена перехвата
----------------------------------------------------------------------
#!/bin/bash
trap "echo 'Ctrl-C is trapped.'" SIGINT
count=1
while [ $count -le 5 ]
do
echo "Loop #$count"
sleep 1
count=$(( $count + 1 ))
done
trap "echo ' I modified the trap!'" SIGINT
count=1
while [ $count -le 5 ]
do
echo "Second Loop #$count"
sleep 1
count=$(( $count + 1 ))
done
----------------------------------------------------------------------
Перехват сигналов можно и отменить, для этого достаточно выполнить
команду trap, передав ей двойное тире и имя сигнала:
----------------------------------------------------------------------
#!/bin/bash
trap "echo 'Ctrl-C is trapped.'" SIGINT
count=1
while [ $count -le 5 ]
do
echo "Loop #$count"
sleep 1
count=$(( $count + 1 ))
done
trap -- SIGINT
echo "I just removed the trap"
count=1
while [ $count -le 5 ]
do
echo "Second Loop #$count"
sleep 1
count=$(( $count + 1 ))
done
----------------------------------------------------------------------
Если скрипт получит сигнал до отмены перехвата, он обработает его так,
как задано в действующей команде trap. Запустим скрипт:

$ ./myscript


И нажмём CTRL + C на клавиатуре.
----------------------------------------------------------------------
Выполнение сценариев командной строки в фоновом режиме
----------------------------------------------------------------------
Иногда bash-скриптам требуется немало времени для выполнения некоей
задачи. При этом вам может понадобиться возможность нормально работать
в командной строке, не дожидаясь завершения скрипта. Реализовать это
не так уж и сложно.

Если вы видели список процессов, выводимый командой ps, вы могли
заметить процессы, которые выполняются в фоне и не привязаны к терминалу.
----------------------------------------------------------------------
#!/bin/bash
count=1
while [ $count -le 10 ]
do
sleep 1
count=$(( $count + 1 ))
done
----------------------------------------------------------------------
$ ./myscipt &

Это приведёт к тому, что он будет запущен как фоновый процесс.
При таком подходе, если выйти из терминала, скрипт, выполняющийся в фоне,
так же завершит работу.

----------------------------------------------------------------------
Выполнение скриптов, не завершающих работу при закрытии терминала
----------------------------------------------------------------------
nohup ./myscript &
----------------------------------------------------------------------
Команда nohup отвязывает процесс от терминала. Это означает, что процесс
потеряет ссылки на STDOUT и STDERR. Для того, чтобы не потерять данные,
выводимые скриптом, nohup автоматически перенаправляет сообщения,
поступающие в STDOUT и в STDERR, в файл nohup.out.

Обратите внимание на то, что при запуске нескольких скриптов из одной
и той же директории то, что они выводят, попадёт в один файл nohup.out.
----------------------------------------------------------------------
Просмотр заданий
----------------------------------------------------------------------
#!/bin/bash
count=1
while [ $count -le 10 ]
do
echo "Loop #$count"
sleep 10
count=$(( $count + 1 ))
done
----------------------------------------------------------------------
$ ./myscript
----------------------------------------------------------------------
И временно остановим комбинацией клавиш CTRL + Z.
----------------------------------------------------------------------
Запустим тот же скрипт в фоновом режиме, при этом перенаправим вывод
скрипта в файл так, чтобы он ничего не выводил на экране:

$ ./myscript > outfile &
----------------------------------------------------------------------
$ jobs -l
----------------------------------------------------------------------
Перезапуск приостановленных заданий
----------------------------------------------------------------------
Для того, чтобы перезапустить скрипт в фоновом режиме, можно
воспользоваться командой bg.

Запустим скрипт:

$ ./myscript


Нажмём CTRL + Z, что временно остановит его выполнение. Выполним
следующую команду:

$ bg

Теперь скрипт выполняется в фоновом режиме
----------------------------------------------------------------------
Для перезапуска задания в обычном режиме воспользуйтесь командой fg:

$ fg 1
----------------------------------------------------------------------
Планирование запуска скриптов
----------------------------------------------------------------------
at [-f filename] time
----------------------------------------------------------------------
Эта команда распознаёт множество форматов указания времени.

    Стандартный, с указанием часов и минут, например — 10:15.
    С использованием индикаторов AM/PM, до или после полудня,
например — 10:15PM.
    С использованием специальных имён, таких, как now, noon, midnight.

----------------------------------------------------------------------

    Стандартный формат указания даты, при котором дата записывается по
шаблонам MMDDYY, MM/DD/YY, или DD.MM.YY.
    Текстовое представление даты, например, Jul 4 или Dec 25, при этом
год можно указать, а можно обойтись и без него.
    Запись вида now + 25 minutes.
    Запись вида 10:15PM tomorrow.
    Запись вида 10:15 + 7 days.

----------------------------------------------------------------------
$ at -f ./myscript now
----------------------------------------------------------------------
Ключ -M при вызове at используется для отправки того, что выведет
скрипт, по электронной почте, если система соответствующим образом
настроена. Если отправка электронного письма невозможна, этот ключ
просто подавит вывод.
----------------------------------------------------------------------
$ atq
----------------------------------------------------------------------
Удаление заданий, ожидающих выполнения
----------------------------------------------------------------------
$ atrm 18
----------------------------------------------------------------------
Запуск скриптов по расписанию
----------------------------------------------------------------------
$ crontab –l
----------------------------------------------------------------------
минута, час, день месяца, месяц, день недели.
----------------------------------------------------------------------
30 10 * * * command
----------------------------------------------------------------------
Для того чтобы добавить запись в таблицу, нужно вызвать crontab с ключом -e:

crontab –e
----------------------------------------------------------------------
30 10 * * * /home/likegeeks/Desktop/myscript
----------------------------------------------------------------------
Благодаря этой команде скрипт будет вызываться ежедневно в 10:30.
Если вы столкнётесь с ошибкой «Resource temporarily unavailable»,
выполните нижеприведённую команду с правами root-пользователя:
----------------------------------------------------------------------
$ rm -f /var/run/crond.pid
----------------------------------------------------------------------
/etc/cron.hourly
/etc/cron.daily
/etc/cron.weekly
/etc/cron.monthly
----------------------------------------------------------------------
Запуск скриптов при входе в систему и при запуске оболочки
----------------------------------------------------------------------
$HOME/.bash_profile
$HOME/.bash_login
$HOME/.profile
----------------------------------------------------------------------
Для того, чтобы запускать скрипт при входе в систему, поместите его
вызов в файл .bash_profile.

А как насчёт запуска скриптов при открытии терминала? Организовать
это поможет файл .bashrc.
----------------------------------------------------------------------
https://likegeeks.com/linux-environment-variables/
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 6, Functions — тут можно узнать о создании и
использовании функций в скриптах, о разработке библиотек.
########################################################################
----------------------------------------------------------------------
Объявление функций
----------------------------------------------------------------------
functionName {
}
----------------------------------------------------------------------
functionName() {
}
----------------------------------------------------------------------
Функцию можно вызвать без аргументов и с аргументами.
----------------------------------------------------------------------
Использование функций
----------------------------------------------------------------------
#!/bin/bash
function myfunc {
echo "This is an example of using a function"
}
count=1
while [ $count -le 3 ]
do
myfunc
count=$(( $count + 1 ))
done
echo "This is the end of the loop"
myfunc
echo "End of the script"
----------------------------------------------------------------------
Функцию можно вызывать столько раз, сколько нужно. Обратите внимание
на то, что попытавшись использовать функцию до её объявления, вы
столкнётесь с ошибкой. Напишем демонстрирующий это скрипт:
----------------------------------------------------------------------
Если вы переопределите ранее объявленную функцию, новая функция будет
вызываться вместо старой без каких-либо уведомлений или сообщений об
ошибках. 
----------------------------------------------------------------------
Использование команды return
----------------------------------------------------------------------
Команда return позволяет задавать возвращаемый функцией целочисленный
код завершения. Есть два способа работы с тем, что является результатом
вызова функции. Вот первый:

----------------------------------------------------------------------
#!/bin/bash
function myfunc {
read -p "Enter a value: " value
echo "adding value"
return $(( $value + 10 ))
}
myfunc
echo "The new value is $?"


Команда echo вывела сумму введённого числа и числа 10.
----------------------------------------------------------------------
$? - переменная с возвращенным командой return результатом.
Если вы выполните любую другую команду до извлечения из переменной $? значения,
возвращённого функцией, это значение будет утеряно. Дело в том, что
данная переменная хранит код возврата последней выполненной команды.

Учтите, что максимальное число, которое может вернуть команда
return — 255. Если функция должна возвращать большее число или строку,
понадобится другой подход.
----------------------------------------------------------------------
Запись вывода функции в переменную
----------------------------------------------------------------------
#!/bin/bash
function myfunc {
read -p "Enter a value: " value
echo $(( $value + 10 ))
}
result=$( myfunc)
echo "The value is $result"
----------------------------------------------------------------------
Аргументы функций
----------------------------------------------------------------------
Функции могут использовать стандартные позиционные параметры, в которые
записывается то, что передаётся им при вызове.
----------------------------------------------------------------------
myfunc $val1 10 20
----------------------------------------------------------------------
Например, имя функции хранится в параметре $0
первый переданный ей аргумент — в $1
второй — в $2, и так далее.
Количество переданных функции аргументов можно узнать, обратившись к
переменной $#. 
----------------------------------------------------------------------
#!/bin/bash
function addnum {
if [ $# -eq 0 ] || [ $# -gt 2 ]
then
echo -1
elif [ $# -eq 1 ]
then
echo $(( $1 + $1 ))
else
echo $(( $1 + $2 ))
fi
}
echo -n "Adding 10 and 15: "
value=$(addnum 10 15)
echo $value
echo -n "Adding one number: "
value=$(addnum 10)
echo $value
echo -n "Adding no numbers: "
value=$(addnum)
echo $value
echo -n "Adding three numbers: "
value=$(addnum 10 15 20)
echo $value
----------------------------------------------------------------------
Обратите внимание на то, что функция не может напрямую работать с
параметрами, которые переданы скрипту при его запуске из командной
строки. Например, напишем такой сценарий:
----------------------------------------------------------------------
Вместо этого, если в функции планируется использовать параметры,
переданные скрипту при вызове из командной строки, надо передать их ей
при вызове:
----------------------------------------------------------------------
#!/bin/bash
function myfunc {
echo $(( $1 + $2 ))
}
if [ $# -eq 2 ]
then
value=$(myfunc $1 $2)
echo "The result is $value"
else
echo "Usage: myfunc a b"
fi
----------------------------------------------------------------------
Работа с переменными в функциях
----------------------------------------------------------------------
Существуют два вида переменных:

    Глобальные переменные.
    Локальные переменные.

----------------------------------------------------------------------
Глобальные переменные
----------------------------------------------------------------------
видны из любого места bash-скрипта. Если вы объявили глобальную
переменную в основном коде скрипта, к такой переменной можно обратиться
из функции.
----------------------------------------------------------------------
Почти то же самое справедливо и для глобальных переменных, объявленных
в функциях. Обращаться к ним можно и в основном коде скрипта после
вызова функций.
----------------------------------------------------------------------
По умолчанию все объявленные в скриптах переменные глобальны. Так, к
переменным, объявленным за пределами функций, можно без проблем
обращаться из функций:
----------------------------------------------------------------------
#!/bin/bash
function myfunc {
value=$(( $value + 10 ))
}
read -p "Enter a value: " value
myfunc
echo "The new value is: $value"
----------------------------------------------------------------------

Когда переменной присваивается новое значение в функции, это новое
значение не теряется когда скрипт обращается к ней после завершения
работы функции. Именно это можно видеть в предыдущем примере.
----------------------------------------------------------------------
Локальные переменные
----------------------------------------------------------------------
Переменные, которые объявляют и используют внутри функции, могут быть
объявлены локальными. Для того, чтобы это сделать, используется
ключевое слово local перед именем переменной:
----------------------------------------------------------------------
local temp=$(( $value + 5 ))
----------------------------------------------------------------------
Если за пределами функции есть переменная с таким же именем, это на неё
не повлияет. Ключевое слово local позволяет отделить переменные,
используемые внутри функции, от остальных переменных. 
----------------------------------------------------------------------
#!/bin/bash
function myfunc {
local temp=$[ $value + 5 ]
echo "The Temp from inside function is $temp"
}
temp=4
myfunc
echo "The temp from outside is $temp"
----------------------------------------------------------------------
Передача функциям массивов в качестве аргументов
----------------------------------------------------------------------
#!/bin/bash
function myfunc {
local newarray
newarray=("$@")
echo "The new array value is: ${newarray[*]}"
}
myarray=(1 2 3 4 5)
echo "The original array is ${myarray[*]}"
myfunc ${myarray[*]}
----------------------------------------------------------------------
Рекурсивные функции
----------------------------------------------------------------------
Рекурсия — это когда функция сама себя вызывает. Классический пример
рекурсии — функция для вычисления факториала. 
----------------------------------------------------------------------
5! = 1 * 2 * 3 * 4 * 5
x! = x * (x-1)!
----------------------------------------------------------------------
#!/bin/bash
function factorial {
if [ $1 -eq 1 ]
then
echo 1
else
local temp=$(( $1 - 1 ))
local result=$(factorial $temp)
echo $(( $result * $1 ))
fi
}
read -p "Enter value: " value
result=$(factorial $value)
echo "The factorial of $value is: $result"
----------------------------------------------------------------------
Создание и использование библиотек
----------------------------------------------------------------------
Ключ к использованию библиотек — в команде source. Эта команда
используется для подключения библиотек к скриптам. В результате функции,
объявленные в библиотеке, становятся доступными в скрипте, в противном
же случае функции из библиотек не будут доступны в области видимости
других скриптов.

У команды source есть псевдоним — оператор «точка». Для того, чтобы
подключить файл в скрипте, в скрипт надо добавить конструкцию такого вида:
----------------------------------------------------------------------
. ./myscript
----------------------------------------------------------------------
Предположим, что у нас имеется файл myfuncs, который содержит следующее:

function addnum {
echo $(( $1 + $2 ))
}
----------------------------------------------------------------------
Это — библиотека. Воспользуемся ей в сценарии:

#!/bin/bash
. ./myfuncs
result=$(addnum 10 20)
echo "The result is: $result"
----------------------------------------------------------------------
Вызов bash-функций из командной строки
----------------------------------------------------------------------
функцию из библиотеки можно подключить в файле .bashrc, используя
команду source. Как результат, вызывать функцию можно будет прямо из
командной строки.
----------------------------------------------------------------------
. /home/likegeeks/Desktop/myfuncs
----------------------------------------------------------------------
Теперь функцию можно вызывать прямо из командной строки:

$ addnum 10 20
----------------------------------------------------------------------
Ещё приятнее то, что такая вот библиотека оказывается доступной всем
дочерним процессам оболочки, то есть — ей можно пользоваться в
bash-скриптах, не заботясь о подключении к ним этой библиотеки.
----------------------------------------------------------------------
Тут стоит отметить, что для того, чтобы вышеприведённый пример
заработал, может понадобиться выйти из системы, а потом войти снова.
Кроме того, обратите внимание на то, что если имя функции из библиотеки
совпадёт с именем какой-нибудь стандартной команды, вместо этой команды
будет вызываться функция. 
----------------------------------------------------------------------
Массивы
----------------------------------------------------------------------
http://rus-linux.net/MyLDP/BOOKS/abs-guide/flat/abs-book.html#ARRAYS
Примеры класные https://rtfm.co.ua/bash-ispolzovanie-massivov/
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 7, Using sed — эта статья посвящена работе с 
потоковым текстовым редактором sed.
########################################################################
----------------------------------------------------------------------
Спавка и много Примеров

http://rus-linux.net/MyLDP/consol/sed.html
----------------------------------------------------------------------
Основы работы с sed
----------------------------------------------------------------------
Утилиту sed называют потоковым текстовым редактором.
----------------------------------------------------------------------
$ sed options file
----------------------------------------------------------------------
По умолчанию sed применяет указанные при вызове правила, выраженные в
виде набора команд, к STDIN. 
----------------------------------------------------------------------
$ echo "This is a test" | sed 's/test/another test/'
$ sed 's/test/another test' ./myfile
----------------------------------------------------------------------
«s» — это сокращение слова «substitute», то есть — перед нами команда
замены. 
----------------------------------------------------------------------
Выполнение наборов команд при вызове sed
----------------------------------------------------------------------
Для выполнения нескольких действий с данными, используйте ключ -e при
вызове sed. Например, вот как организовать замену двух фрагментов текста:
----------------------------------------------------------------------
$ sed -e 's/This/That/; s/test/another test/' ./myfile
----------------------------------------------------------------------
$ sed -e '
> s/This/That/
> s/test/another test/' ./myfile
----------------------------------------------------------------------
Чтение команд из файла
----------------------------------------------------------------------
Для того, чтобы указать sed файл, содержащий команды, используют ключ -f:
----------------------------------------------------------------------
Вот содержимое файла mycommands:

s/This/That/
s/test/another test/
----------------------------------------------------------------------
$ sed -f mycommands myfile
----------------------------------------------------------------------
Флаги команды замены
----------------------------------------------------------------------
$ sed 's/test/another test/' myfile
----------------------------------------------------------------------
s/pattern/replacement/flags
----------------------------------------------------------------------
Выполнение этой команды можно модифицировать несколькими способами.

    При передаче номера учитывается порядковый номер вхождения шаблона
в строку, заменено будет именно это вхождение.
    Флаг g указывает на то, что нужно обработать все вхождения шаблона,
имеющиеся в строке.
    Флаг p указывает на то, что нужно вывести содержимое исходной строки.
    Флаг вида w file указывает команде на то, что нужно записать
результаты обработки текста в файл.
----------------------------------------------------------------------
$ sed 's/test/another test/2' myfile
----------------------------------------------------------------------
$ sed 's/test/another test/g' myfile
----------------------------------------------------------------------
при этом ключ -n, указанный при вызове sed, подавляет обычный вывод:

$ sed -n 's/test/another test/p' myfile
----------------------------------------------------------------------
$ sed 's/test/another test/w output' myfile
----------------------------------------------------------------------
Символы-разделители
----------------------------------------------------------------------
нужно заменить /bin/bash на /bin/csh в файле /etc/passwd. Задача не
такая уж и сложная:

$ sed 's/\/bin\/bash/\/bin\/csh/' /etc/passwd
----------------------------------------------------------------------
sed позволяет нам самостоятельно задавать символы-разделители для
использования их в команде замены. Разделителем считается первый символ,
который будет встречен после s:
----------------------------------------------------------------------
$ sed 's!/bin/bash!/bin/csh!' /etc/passwd
----------------------------------------------------------------------
Выбор фрагментов текста для обработки
----------------------------------------------------------------------
В некоторых случаях с помощью sed надо обработать лишь какую-то часть
текста — некую конкретную строку или группу строк. Для достижения такой
цели можно воспользоваться двумя подходами:
----------------------------------------------------------------------
	Задать ограничение на номера обрабатываемых строк.
	Указать фильтр, соответствующие которому строки нужно обработать.
----------------------------------------------------------------------
Первый, рассмотренный ниже, предусматривает указание номера одной
строки, которую нужно обработать:

$ sed '2s/test/another test/' myfile
----------------------------------------------------------------------
Второй вариант — диапазон строк:

$ sed '2,3s/test/another test/' myfile
----------------------------------------------------------------------
Кроме того, можно вызвать команду замены так, чтобы файл был обработан
начиная с некоей строки и до конца:

$ sed '2,$s/test/another test/' myfile
----------------------------------------------------------------------
Для того, чтобы обрабатывать с помощью команды замены только строки,
соответствующие заданному фильтру, команду надо вызвать так:

$ sed '/likegeeks/s/bash/csh/' /etc/passwd


По аналогии с тем, что было рассмотрено выше, шаблон передаётся перед
именем команды s.
----------------------------------------------------------------------
Удаление строк
----------------------------------------------------------------------
используя команду d, можно удалять строки из текстового потока.
----------------------------------------------------------------------
$ sed '3d' myfile
----------------------------------------------------------------------
Мы хотим, чтобы из текста была удалена третья строка. Обратите внимание
на то, что речь не идёт о файле. Файл останется неизменным, удаление
отразится лишь на выводе, который сформирует sed.
----------------------------------------------------------------------
 Если при вызове команды d не указать номер удаляемой строки, удалены
будут все строки потока.
----------------------------------------------------------------------
Вот как применить команду d к диапазону строк:

$ sed '2,3d' myfile
----------------------------------------------------------------------
А вот как удалить строки, начиная с заданной — и до конца файла:

$ sed '3,$d' myfile
----------------------------------------------------------------------
Строки можно удалять и по шаблону:

$ sed '/test/d' myfile
----------------------------------------------------------------------
При вызове d можно указывать пару шаблонов — будут удалены строки, в
которых встретится шаблон, и те строки, которые находятся между ними:

$ sed '/second/,/fourth/d' myfile
----------------------------------------------------------------------
Вставка текста в поток
----------------------------------------------------------------------
С помощью sed можно вставлять данные в текстовый поток, используя команды i и a:

    Команда i добавляет новую строку перед заданной.
    Команда a добавляет новую строку после заданной.
----------------------------------------------------------------------
$ echo "Another test" | sed 'i\First test '
----------------------------------------------------------------------
$ echo "Another test" | sed 'a\First test '
----------------------------------------------------------------------
Как видно, эти команды добавляют текст до или после данных из потока.
Что если надо добавить строку где-нибудь посередине?

----------------------------------------------------------------------
Тут нам поможет указание номера опорной строки в потоке, или шаблона.
Учтите, что адресация строк в виде диапазона тут не подойдёт. Вызовем
команду i, указав номер строки, перед которой надо вставить новую строку:
----------------------------------------------------------------------
$ sed '2i\This is the inserted line.' myfile
----------------------------------------------------------------------
$ sed '2a\This is the appended line.' myfile
----------------------------------------------------------------------
Обратите внимание на разницу в работе команд i и a. Первая вставляет
новую строку до указанной, вторая — после.
----------------------------------------------------------------------
Замена строк
----------------------------------------------------------------------
Команда c позволяет изменить содержимое целой строки текста в потоке
данных. При её вызове нужно указать номер строки, вместо которой в
поток надо добавить новые данные:
----------------------------------------------------------------------
$ sed '3c\This is a modified line.' myfile
----------------------------------------------------------------------
Если воспользоваться при вызове команды шаблоном в виде обычного текста
или регулярного выражения, заменены будут все соответствующие шаблону строки:
----------------------------------------------------------------------
$ sed '/This is/c This is a changed line of text.' myfile
----------------------------------------------------------------------
Замена символов
----------------------------------------------------------------------
Команда y работает с отдельными символами, заменяя их в соответствии с
переданными ей при вызове данными:
----------------------------------------------------------------------
$ sed 'y/123/567/' myfile
----------------------------------------------------------------------
Используя эту команду, нужно учесть, что она применяется ко всему
текстовому потоку, ограничить её конкретными вхождениями символов нельзя.

----------------------------------------------------------------------
Вывод номеров строк
----------------------------------------------------------------------
Если вызвать sed, использовав команду =, утилита выведет номера строк
в потоке данных:

$ sed '=' myfile
----------------------------------------------------------------------
Если передать этой команде шаблон и воспользоваться ключом sed -n,
выведены будут только номера строк, соответствующих шаблону:

$ sed -n '/test/=' myfile
----------------------------------------------------------------------
Чтение данных для вставки из файла
----------------------------------------------------------------------
Выше мы рассматривали приёмы вставки данных в поток, указывая то, что
надо вставить, прямо при вызове sed. В качестве источника данных можно
воспользоваться и файлом. Для этого служит команда r, которая позволяет
вставлять в поток данные из указанного файла. При её вызове можно
указать номер строки, после которой надо вставить содержимое файла,
или шаблон.
----------------------------------------------------------------------
$ sed '3r newfile' myfile
----------------------------------------------------------------------
Тут содержимое файла newfile было вставлено после третьей строки файла myfile.
----------------------------------------------------------------------
Вот что произойдёт, если применить при вызове команды r шаблон:

$ sed '/test/r newfile' myfile
----------------------------------------------------------------------
Пример
----------------------------------------------------------------------
Есть файл, в котором имеется некая последовательность символов, сама
по себе бессмысленная, которую надо заменить на данные, взятые из
другого файла. А именно, пусть это будет файл newfile, в котором роль
указателя места заполнения играет последовательность символов DATA.
Данные, которые нужно подставить вместо DATA, хранятся в файле data.

Решить эту задачу можно, воспользовавшись командами r и d потокового
редактора sed:
----------------------------------------------------------------------
$ Sed '/DATA>/ {
r newfile
d}' myfile
----------------------------------------------------------------------
 Как видите, вместо заполнителя DATA sed добавил в выходной поток две
строки из файла data.
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 8, Using awk — данный материал посвящён
программированию на языке обработки данных awk.
########################################################################
----------------------------------------------------------------------
Язык программирования awk 
----------------------------------------------------------------------

    Объявлять переменные для хранения данных.
    Использовать арифметические и строковые операторы для работы с данными.
    Использовать структурные элементы и управляющие конструкции языка,
	такие, как оператор if-then и циклы, что позволяет реализовать
	сложные алгоритмы обработки данных.
    Создавать форматированные отчёты.

----------------------------------------------------------------------
Особенности вызова awk
----------------------------------------------------------------------
$ awk options program file
----------------------------------------------------------------------
Awk воспринимает поступающие к нему данные в виде набора записей. Записи
представляют собой наборы полей. Упрощенно, если не учитывать возможности
настройки awk и говорить о некоем вполне обычном тексте, строки которого
разделены символами перевода строки, запись — это строка. Поле — это
слово в строке.
----------------------------------------------------------------------
	-F fs — позволяет указать символ-разделитель для полей в записи.
	-f file — указывает имя файла, из которого нужно прочесть awk-скрипт.
	-v var=value — позволяет объявить переменную и задать её значение по
	умолчанию, которое будет использовать awk.
	-mf N — задаёт максимальное число полей для обработки в файле данных.
	-mr N — задаёт максимальный размер записи в файле данных.
	-W keyword — позволяет задать режим совместимости или уровень выдачи
	предупреждений awk.
----------------------------------------------------------------------
Настоящая мощь awk скрывается в той части команды его вызова, которая
помечена выше как program. Она указывает на файл awk-скрипта, написанный
программистом и предназначенный для чтения данных, их обработки и
вывода результатов.
----------------------------------------------------------------------
Чтение awk-скриптов из командной строки
----------------------------------------------------------------------
$ awk '{print "Welcome to awk command tutorial"}'
----------------------------------------------------------------------
Если теперь ввести что-нибудь в консоль и нажать Enter, awk обработает
введённые данные с помощью скрипта, заданного при его запуске. Awk
обрабатывает текст из потока ввода построчно, этим он похож на sed. 
----------------------------------------------------------------------
Для того, чтобы завершить работу awk, нужно передать ему символ конца
файла (EOF, End-of-File). Сделать это можно, воспользовавшись сочетанием
клавиш CTRL + D.
----------------------------------------------------------------------
Позиционные переменные, хранящие данные полей
----------------------------------------------------------------------
Одна из основных функций awk заключается в возможности манипулировать
данными в текстовых файлах. Делается это путём автоматического
назначения переменной каждому элементу в строке. По умолчанию awk
назначает следующие переменные каждому полю данных, обнаруженному им
в записи:
----------------------------------------------------------------------

    $0 — представляет всю строку текста (запись).
    $1 — первое поле.
    $2 — второе поле.
    $n — n-ное поле.

----------------------------------------------------------------------
Поля выделяются из текста с использованием символа-разделителя. По
умолчанию — это пробельные символы вроде пробела или символа табуляции.
----------------------------------------------------------------------
$ awk '{print $1}' myfile
----------------------------------------------------------------------
Здесь использована переменная $1, которая позволяет получить доступ к
первому полю каждой строки и вывести его на экран.
----------------------------------------------------------------------
$ awk -F: '{print $1}' /etc/passwd
----------------------------------------------------------------------
Использование нескольких команд
----------------------------------------------------------------------
Для того, чтобы передать awk многострочную команду при вызове его из
консоли, нужно разделить её части точкой с запятой:
----------------------------------------------------------------------
$ echo "My name is Tom" | awk '{$4="Adam"; print $0}'
----------------------------------------------------------------------
Чтение скрипта awk из файла
----------------------------------------------------------------------
Подготовим файл testfile, в который запишем следующее:

{print $1 " has a  home directory at " $6}
----------------------------------------------------------------------
$ awk -F: -f testfile /etc/passwd
----------------------------------------------------------------------
{
text = " has a  home directory at "
print $1 text $6
}
----------------------------------------------------------------------
Выполнение команд до начала обработки данных
----------------------------------------------------------------------
Команды, которые следуют за BEGIN, будут исполнены до начала обработки
данных. В простейшем виде это выглядит так:
----------------------------------------------------------------------
$ awk 'BEGIN {print "Hello World!"}'
----------------------------------------------------------------------
А вот — немного более сложный пример:

$ awk 'BEGIN {print "The File Contents:"}
{print $0}' myfile
----------------------------------------------------------------------
Сначала awk исполняет блок BEGIN, после чего выполняется обработка данных.
----------------------------------------------------------------------
Выполнение команд после окончания обработки данных
----------------------------------------------------------------------
$ awk 'BEGIN {print "The File Contents:"}
{print $0}
END {print "End of File"}' myfile
----------------------------------------------------------------------
Теперь напишем скрипт следующего содержания и сохраним его в файле myscript:

BEGIN {
print "The latest list of users and shells"
print " UserName \t HomePath"
print "-------- \t -------"
FS=":"
}
{
print $1 " \t " $6
}
END {
print "The end"
}
----------------------------------------------------------------------
Запустим скрипт:

$ awk -f myscript  /etc/passwd
----------------------------------------------------------------------
Встроенные переменные: настройка процесса обработки данных
----------------------------------------------------------------------
Вот некоторые из наиболее часто используемых:

	FIELDWIDTHS — разделённый пробелами список чисел, определяющий
	точную ширину каждого поля данных с учётом разделителей полей.
	FS — уже знакомая вам переменная, позволяющая задавать
	символ-разделитель полей.
	RS — переменная, которая позволяет задавать символ-разделитель
	записей.
	OFS — разделитель полей на выводе awk-скрипта.
	ORS — разделитель записей на выводе awk-скрипта.
----------------------------------------------------------------------
По умолчанию переменная OFS настроена на использование пробела. Её
можно установить так, как нужно для целей вывода данных:
----------------------------------------------------------------------
$ awk 'BEGIN{FS=":"; OFS="-"} {print $1,$6,$7}' /etc/passwd
----------------------------------------------------------------------
Переменная FIELDWIDTHS позволяет читать записи без использования
символа-разделителя полей.
----------------------------------------------------------------------
В некоторых случаях, вместо использования разделителя полей, данные в
пределах записей расположены в колонках постоянной ширины. В подобных
случаях необходимо задать переменную FIELDWIDTHS таким образом, чтобы
её содержимое соответствовало особенностям представления данных.
----------------------------------------------------------------------
При установленной переменной FIELDWIDTHS awk будет игнорировать
переменную FS и находить поля данных в соответствии со сведениями об
их ширине, заданными в FIELDWIDTHS.
----------------------------------------------------------------------
Предположим, имеется файл testfile, содержащий такие данные:

1235.9652147.91
927-8.365217.27
36257.8157492.5
----------------------------------------------------------------------
Известно, что внутренняя организация этих данных соответствует шаблону
3-5-2-5, то есть, первое поле имеет ширину 3 символа, второе — 5, и
так далее. Вот скрипт, который позволит разобрать такие записи:
----------------------------------------------------------------------
$ awk 'BEGIN{FIELDWIDTHS="3 5 2 5"}{print $1,$2,$3,$4}' testfile
----------------------------------------------------------------------
Переменные RS и ORS задают порядок обработки записей. По умолчанию
RS и ORS установлены на символ перевода строки. Это означает, что awk
воспринимает каждую новую строку текста как новую запись и выводит
каждую запись с новой строки.
----------------------------------------------------------------------
Иногда случается так, что поля в потоке данных распределены по
нескольким строкам. Например, пусть имеется такой файл с именем addresses:

Person Name
123 High Street
(222) 466-1234

Another person
487 High Street
(523) 643-8754
----------------------------------------------------------------------
Для того, чтобы решить эту проблему, в FS надо записать символ перевода
строки. Это укажет awk на то, что каждая строка в потоке данных является
отдельным полем.
----------------------------------------------------------------------
Кроме того, в данном примере понадобится записать в переменную RS пустую
строку. Обратите внимание на то, что в файле блоки данных о разных людях
разделены пустой строкой. В результате awk будет считать пустые строки
разделителями записей. Вот как всё это сделать:
----------------------------------------------------------------------
$ awk 'BEGIN{FS="\n"; RS=""} {print $1,$3}' addresses
----------------------------------------------------------------------
Как видите, awk, благодаря таким настройкам переменных, воспринимает
строки из файла как поля, а разделителями записей становятся пустые строки.
----------------------------------------------------------------------
Встроенные переменные: сведения о данных и об окружении
----------------------------------------------------------------------
	ARGC — количество аргументов командной строки.
	ARGV — массив с аргументами командной строки.
	ARGIND — индекс текущего обрабатываемого файла в массиве ARGV.
	ENVIRON — ассоциативный массив с переменными окружения и их значениями.
	ERRNO — код системной ошибки, которая может возникнуть при чтении
	или закрытии входных файлов.
	FILENAME — имя входного файла с данными.
	FNR — номер текущей записи в файле данных.
	IGNORECASE — если эта переменная установлена в ненулевое значение,
	при обработке игнорируется регистр 	символов.
	NF — общее число полей данных в текущей записи.
	NR — общее число обработанных записей.
----------------------------------------------------------------------
Переменные ARGC и ARGV позволяют работать с аргументами командной строки.
При этом скрипт, переданный awk, не попадает в массив аргументов ARGV.
Напишем такой скрипт:
----------------------------------------------------------------------
$ awk 'BEGIN{print ARGC,ARGV[1]}' myfile
----------------------------------------------------------------------
После его запуска можно узнать, что общее число аргументов командной
строки — 2, а под индексом 1 в массиве ARGV записано имя обрабатываемого
файла. В элементе массива с индексом 0 в данном случае будет «awk».
----------------------------------------------------------------------
Переменная ENVIRON представляет собой ассоциативный массив с переменными
среды. Опробуем её:

$ awk '
BEGIN{
print ENVIRON["HOME"]
print ENVIRON["PATH"]
}'
----------------------------------------------------------------------
Переменные среды можно использовать и без обращения к ENVIRON. Сделать
это, например, можно так:

$  echo | awk -v home=$HOME '{print "My home is " home}'
----------------------------------------------------------------------
Переменная NF позволяет обращаться к последнему полю данных в записи,
не зная его точной позиции:

$ awk 'BEGIN{FS=":"; OFS=":"} {print $1,$NF}' /etc/passwd
----------------------------------------------------------------------
Эта переменная содержит числовой индекс последнего поля данных в записи.
Обратиться к данному полю можно, поместив перед NF знак $.
----------------------------------------------------------------------
Переменные FNR и NR, хотя и могут показаться похожими, на самом деле
различаются. Так, переменная FNR хранит число записей, обработанных в
текущем файле. Переменная NR хранит общее число обработанных записей.
Рассмотрим пару примеров, передав awk один и тот же файл дважды:
----------------------------------------------------------------------
$ awk 'BEGIN{FS=","}{print $1,"FNR="FNR}' myfile myfile
----------------------------------------------------------------------
Передача одного и того же файла дважды равносильна передаче двух разных
файлов. Обратите внимание на то, что FNR сбрасывается в начале обработки
каждого файла.
----------------------------------------------------------------------
Взглянем теперь на то, как ведёт себя в подобной ситуации переменная NR:

$ awk '
BEGIN {FS=","}
{print $1,"FNR="FNR,"NR="NR}
END{print "There were",NR,"records processed"}' myfile myfile
----------------------------------------------------------------------
Как видно, FNR, как и в предыдущем примере, сбрасывается в начале
обработки каждого файла, а вот NR, при переходе к следующему файлу,
сохраняет значение.
----------------------------------------------------------------------
Пользовательские переменные
----------------------------------------------------------------------
они не могут начинаться с цифры. 
$ awk '
BEGIN{
test="This is a test"
print test
}'
----------------------------------------------------------------------
Условный оператор
----------------------------------------------------------------------
Например, есть такой файл с именем testfile:

10
15
6
33
45
----------------------------------------------------------------------
$ awk '{if ($1 > 20) print $1}' testfile
----------------------------------------------------------------------
Если нужно выполнить в блоке if несколько операторов, их нужно
заключить в фигурные скобки:
----------------------------------------------------------------------
$ awk '{
if ($1 > 20)
{
x = $1 * 2
print x
}
}' testfile
----------------------------------------------------------------------
Как уже было сказано, условный оператор awk может содержать блок else:
----------------------------------------------------------------------
$ awk '{
if ($1 > 20)
{
x = $1 * 2
print x
} else
{
x = $1 / 2
print x
}}' testfile
----------------------------------------------------------------------
Ветвь else может быть частью однострочной записи условного оператора,
включая в себя лишь одну строку с командой. В подобном случае после
ветви if, сразу перед else, надо поставить точку с запятой:
----------------------------------------------------------------------
$ awk '{if ($1 > 20) print $1 * 2; else print $1 / 2}' testfile
----------------------------------------------------------------------
Вот файл myfile, обработку которого мы хотим организовать с помощью цикла:

124 127 130
112 142 135
175 158 245
----------------------------------------------------------------------
$ awk '{
total = 0
i = 1
while (i < 4)
{
total += $i
i++
}
avg = total / 3
print "Average:",avg
}' testfile
----------------------------------------------------------------------
Цикл while 
----------------------------------------------------------------------
Цикл while перебирает поля каждой записи, накапливая их сумму в
переменной total и увеличивая в каждой итерации на 1 переменную-счётчик i.
Когда i достигнет 4, условие на входе в цикл окажется ложным и цикл
завершится, после чего будут выполнены остальные команды — подсчёт
среднего значения для числовых полей текущей записи и вывод найденного
значения.
----------------------------------------------------------------------
В циклах while можно использовать команды break и continue. Первая
позволяет досрочно завершить цикл и приступить к выполнению команд,
расположенных после него. Вторая позволяет, не завершая до конца текущую
итерацию, перейти к следующей.

----------------------------------------------------------------------
$ awk '{
total = 0
i = 1
while (i < 4)
{
total += $i
if (i == 2)
break
i++
}
avg = total / 2
print "The average of the first two elements is:",avg
}' testfile
----------------------------------------------------------------------
Цикл for
----------------------------------------------------------------------
$ awk '{
total = 0
for (i = 1; i < 4; i++)
{
total += $i
}
avg = total / 3
print "Average:",avg
}' testfile
----------------------------------------------------------------------
Форматированный вывод данных
----------------------------------------------------------------------
Спецификатор форматирования — это специальный символ, который задаё
тип выводимых данных и то, как именно их нужно выводить. Awk использует
спецификаторы форматирования как указатели мест вставки данных из
переменных, передаваемых printf.

----------------------------------------------------------------------
Первый спецификатор соответствует первой переменной, второй
спецификатор — второй, и так далее.

Спецификаторы форматирования записывают в таком виде:

%[modifier]control-letter
----------------------------------------------------------------------
Вот некоторые из них:

    c — воспринимает переданное ему число как код ASCII-символа и выводит этот символ.
    d — выводит десятичное целое число.
    i — то же самое, что и d.
    e — выводит число в экспоненциальной форме.
    f — выводит число с плавающей запятой.
    g — выводит число либо в экспоненциальной записи, либо в формате с
плавающей запятой, в зависимости от того, как получается короче.
    o — выводит восьмеричное представление числа.
    s — выводит текстовую строку.
----------------------------------------------------------------------
$ awk 'BEGIN{
x = 100 * 100
printf "The result is: %e\n", x
}'
----------------------------------------------------------------------
Встроенные математические функции
----------------------------------------------------------------------
При работе с awk программисту доступны встроенные функции. В частности,
это математические и строковые функции, функции для работы со временем.
----------------------------------------------------------------------
cos(x) — косинус x (x выражено в радианах).
sin(x) — синус x.
exp(x) — экспоненциальная функция.
int(x) — возвращает целую часть аргумента.
log(x) — натуральный логарифм.
rand() — возвращает случайное число с плавающей запятой в диапазоне 0 — 1.
sqrt(x) — квадратный корень из x.
----------------------------------------------------------------------
$ awk 'BEGIN{x=exp(5); print x}'
----------------------------------------------------------------------
Строковые функции
----------------------------------------------------------------------
$ awk 'BEGIN{x = "likegeeks"; print toupper(x)}'
----------------------------------------------------------------------
Эта функция преобразует символы, хранящиеся в переданной ей строковой
переменной, к верхнему регистру.
----------------------------------------------------------------------
Пользовательские функции
----------------------------------------------------------------------
При необходимости вы можете создавать собственные функции awk. Такие
функции можно использовать так же, как встроенные:

$ awk '
function myprint()
{
printf "The user %s has home path at %s\n", $1,$6
}
BEGIN{FS=":"}
{
myprint()
}' /etc/passwd
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 9, Regular Expressions — тут можно почитать об
использовании регулярных выражений в bash-скриптах.
########################################################################
----------------------------------------------------------------------
Что такое регулярные выражения
----------------------------------------------------------------------
^([a-zA-Z0-9_\-\.\+]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]{2,5})$
----------------------------------------------------------------------
Шаблоны, которые используют обычные ASCII-символы, представляющие сами
себя, и так называемые метасимволы, которые играют особую роль, например,
позволяя ссылаться на некие группы символов.
----------------------------------------------------------------------
Типы регулярных выражений
----------------------------------------------------------------------

    Движок, поддерживающий стандарт POSIX Basic Regular Expression (BRE).
    Движок, поддерживающий стандарт POSIX Extended Regular Expression (ERE).

----------------------------------------------------------------------
Большинство утилит Linux соответствуют, как минимум, стандарту POSIX BRE,
но некоторые утилиты (в их числе — sed) понимают лишь некое подмножество
стандарта BRE.

Awk поддерживает стандарт ERE.
----------------------------------------------------------------------
Регулярные выражения POSIX BRE
----------------------------------------------------------------------
$ echo "This is a test" | sed -n '/test/p'
$ echo "This is a test" | awk '/test/{print $0}'
----------------------------------------------------------------------
Работая с регулярными выражениями нужно учитывать то, что они
чувствительны к регистру символов:
----------------------------------------------------------------------
В регулярных выражениях можно использовать не только буквы, но и
пробелы, и цифры:
----------------------------------------------------------------------
$ echo "This is a test 2 again" | awk '/test 2/{print $0}'
----------------------------------------------------------------------
Пробелы воспринимаются движком регулярных выражений как обычные символы.
----------------------------------------------------------------------
Специальные символы
----------------------------------------------------------------------
Так, существуют некоторые специальные символы, или метасимволы,
использование которых в шаблоне требует особого подхода. Вот они:
----------------------------------------------------------------------
.*[]^${}\+?|()
----------------------------------------------------------------------
Если один из них нужен в шаблоне, его нужно будет экранировать с
помощью обратной косой черты (обратного слэша) — \.
----------------------------------------------------------------------
Например, если в тексте нужно найти знак доллара, его надо включить в
шаблон, предварив символом экранирования. Скажем, имеется файл myfile
с таким текстом:

There is 10$ on my pocket


Знак доллара можно обнаружить с помощью такого шаблона:

$ awk '/\$/{print $0}' myfile
----------------------------------------------------------------------
Кроме того, обратная косая черта — это тоже специальный символ,
поэтому, если нужно использовать его в шаблоне, его тоже надо будет
экранировать. Выглядит это как два слэша, идущих друг за другом:

$ echo "\ is a special character" | awk '/\\/{print $0}'
----------------------------------------------------------------------
Хотя прямой слэш и не входит в приведённый выше список специальных
символов, попытка воспользоваться им в регулярном выражении, написанном
для sed или awk, приведёт к ошибке.
----------------------------------------------------------------------
Если он нужен, его тоже надо экранировать:

$ echo "3 / 2" | awk '/\//{print $0}'
----------------------------------------------------------------------
Якорные символы
----------------------------------------------------------------------
Существуют два специальных символа для привязки шаблона к началу или к
концу текстовой строки. Символ «крышка» — ^ позволяет описывать
последовательности символов, которые находятся в начале текстовых
строк. Если искомый шаблон окажется в другом месте строки, регулярное
выражение на него не отреагирует. Выглядит использование этого символа
так:
----------------------------------------------------------------------
$ echo "welcome to likegeeks website" | awk '/^likegeeks/{print $0}'
$ echo "likegeeks website" | awk '/^likegeeks/{print $0}'
----------------------------------------------------------------------
$ awk '/^this/{print $0}' myfile
----------------------------------------------------------------------
При использовании sed, если поместить крышку где-нибудь внутри шаблона,
она будет восприниматься как любой другой обычный символ:
----------------------------------------------------------------------
$ echo "This ^ is a test" | sed -n '/s ^/p'
----------------------------------------------------------------------
В awk, при использовании такого же шаблона, данный символ надо экранировать:
----------------------------------------------------------------------
$ echo "This ^ is a test" | awk '/s \^/{print $0}'
----------------------------------------------------------------------
Знак доллара — $, являющийся якорным символом конца строки:
----------------------------------------------------------------------
$ echo "This is a test" | awk '/test$/{print $0}'
----------------------------------------------------------------------
$ awk '/^this is a test$/{print $0}' myfile
----------------------------------------------------------------------
шаблон среагировал лишь на строку, полностью соответствующую заданной
последовательности символов и их расположению.
----------------------------------------------------------------------
Вот как, пользуясь якорными символами, отфильтровать пустые строки:
----------------------------------------------------------------------
$ awk '!/^$/{print $0}' myfile
----------------------------------------------------------------------
В данном шаблоне использовал символ отрицания, восклицательный знак — !.
Благодаря использованию такого шаблона выполняется поиск строк, не
содержащих ничего между началом и концом строки, а благодаря
восклицательному знаку на печать выводятся лишь строки, которые не
соответствуют этому шаблону.
----------------------------------------------------------------------
Символ «точка»
----------------------------------------------------------------------
Точка используется для поиска любого одиночного символа, за исключением
символа перевода строки. Передадим такому регулярному выражению файл
myfile, содержимое которого приведено ниже:
----------------------------------------------------------------------
$ awk '/.st/{print $0}' myfile
----------------------------------------------------------------------
Классы символов
----------------------------------------------------------------------
Благодаря такому подходу можно организовать поиск любого символа из
заданного набора. Для описания класса символов используются квадратные
скобки — []:
----------------------------------------------------------------------
$ awk '/[oi]th/{print $0}' myfile
$ echo "this is a test" | awk '/[Tt]his is a test/{print $0}'
$ echo "This is a test" | awk '/[Tt]his is a test/{print $0}'
----------------------------------------------------------------------
Тут можно использовать и другие символы.
----------------------------------------------------------------------
Отрицание классов символов
----------------------------------------------------------------------
можно организовать поиск всего, что в класс не входит.
----------------------------------------------------------------------
$ awk '/[^oi]th/{print $0}' myfile
----------------------------------------------------------------------
 В данном случае будут найдены последовательности символов «th», перед
которыми нет ни «o», ни «i».
----------------------------------------------------------------------
Диапазоны символов
----------------------------------------------------------------------
$ awk '/[e-p]st/{print $0}' myfile
----------------------------------------------------------------------
$ echo "123" | awk '/[0-9][0-9][0-9]/'
$ echo "12a" | awk '/[0-9][0-9][0-9]/'
----------------------------------------------------------------------
$ awk '/[a-fm-z]st/{print $0}' myfile
----------------------------------------------------------------------
Данное регулярное выражение найдёт все последовательности «st», перед
которыми есть символы из диапазонов a-f и m-z.
----------------------------------------------------------------------
Специальные классы символов
----------------------------------------------------------------------

    [[:alpha:]] — соответствует любому алфавитному символу, записанному в верхнем или нижнем регистре.
    [[:alnum:]] — соответствует любому алфавитно-цифровому символу, а именно — символам в диапазонах 0-9, A-Z, a-z.
    [[:blank:]] — соответствует пробелу и знаку табуляции.
    [[:digit:]] — любой цифровой символ от 0 до 9.
    [[:upper:]] — алфавитные символы в верхнем регистре — A-Z.
    [[:lower:]] — алфавитные символы в нижнем регистре — a-z.
    [[:print:]] — соответствует любому печатаемому символу.
    [[:punct:]] — соответствует знакам препинания.
    [[:space:]] — пробельные символы, в частности — пробел, знак табуляции, символы NL, FF, VT, CR.

----------------------------------------------------------------------
$ echo "abc" | awk '/[[:alpha:]]/{print $0}'
$ echo "abc" | awk '/[[:digit:]]/{print $0}'
$ echo "abc123" | awk '/[[:digit:]]/{print $0}'
----------------------------------------------------------------------
Символ «звёздочка»
----------------------------------------------------------------------
Если в шаблоне после символа поместить звёздочку, это будет означать,
что регулярное выражение сработает, если символ появляется в строке
любое количество раз — включая и ситуацию, когда символ в строке
отсутствует.
----------------------------------------------------------------------
$ echo "test" | awk '/tes*t/{print $0}'
$ echo "tessst" | awk '/tes*t/{print $0}'
----------------------------------------------------------------------
Этот шаблонный символ обычно используют для работы со словами, в
которых постоянно встречаются опечатки, или для слов, допускающих
разные варианты корректного написания:
----------------------------------------------------------------------
$ echo "I like green color" | awk '/colou*r/{print $0}'
$ echo "I like green colour " | awk '/colou*r/{print $0}'
----------------------------------------------------------------------
В этом примере одно и то же регулярное выражение реагирует и на слово
«color», и на слово «colour». Это так благодаря тому, что символ «u»,
после которого стоит звёздочка, может либо отсутствовать, либо
встречаться несколько раз подряд.
----------------------------------------------------------------------
Ещё одна полезная возможность, вытекающая из особенностей символа
звёздочки, заключается в комбинировании его с точкой. Такая комбинация
позволяет регулярному выражению реагировать на любое количество любых
символов:
----------------------------------------------------------------------
$ awk '/this.*test/{print $0}' myfile
----------------------------------------------------------------------
Звёздочку можно использовать и с классами символов:
----------------------------------------------------------------------
$ echo "st" | awk '/s[ae]*t/{print $0}'
$ echo "sat" | awk '/s[ae]*t/{print $0}'
$ echo "set" | awk '/s[ae]*t/{print $0}'
----------------------------------------------------------------------
звёздочка после класса символов означает, что если будет найдено любое
количество символов «a» или «e», а также если их найти не удастся,
строка будет соответствовать заданному шаблону.
----------------------------------------------------------------------
Регулярные выражения POSIX ERE
----------------------------------------------------------------------
	awk поддерживает этот стандарт, а вот sed — нет
----------------------------------------------------------------------
Вопросительный знак
----------------------------------------------------------------------
Вопросительный знак указывает на то, что предшествующий символ может
встретиться в тексте один раз или не встретиться вовсе. Этот символ —
один из метасимволов повторений.
----------------------------------------------------------------------
$ echo "tet" | awk '/tes?t/{print $0}'
$ echo "test" | awk '/tes?t/{print $0}'
$ echo "tesst" | awk '/tes?t/{print $0}'
----------------------------------------------------------------------
Как видно, в третьем случае буква «s» встречается дважды, поэтому на
слово «tesst» регулярное выражение не реагирует.
----------------------------------------------------------------------
Вопросительный знак можно использовать и с классами символов:
----------------------------------------------------------------------
$ echo "tst" | awk '/t[ae]?st/{print $0}'
$ echo "test" | awk '/t[ae]?st/{print $0}'
$ echo "tast" | awk '/t[ae]?st/{print $0}'
$ echo "taest" | awk '/t[ae]?st/{print $0}'
$ echo "teest" | awk '/t[ae]?st/{print $0}'
----------------------------------------------------------------------
Символ «плюс»
----------------------------------------------------------------------
Символ «плюс» в шаблоне указывает на то, что регулярное выражение
обнаружит искомое в том случае, если предшествующий символ встретится
в тексте один или более раз. При этом на отсутствие символа такая
конструкция реагировать не будет:
----------------------------------------------------------------------
$ echo "test" | awk '/te+st/{print $0}'
$ echo "teest" | awk '/te+st/{print $0}'
$ echo "tst" | awk '/te+st/{print $0}'
----------------------------------------------------------------------
В данном примере, если символа «e» в слове нет, движок регулярных
выражений не найдёт в тексте соответствий шаблону. Символ «плюс»
работает и с классами символов — этим он похож на звёздочку и
вопросительный знак:
----------------------------------------------------------------------
$ echo "tst" | awk '/t[ae]+st/{print $0}'
$ echo "test" | awk '/t[ae]+st/{print $0}'
$ echo "teast" | awk '/t[ae]+st/{print $0}'
$ echo "teeast" | awk '/t[ae]+st/{print $0}'
----------------------------------------------------------------------
Фигурные скобки
----------------------------------------------------------------------
Фигурные скобки, которыми можно пользоваться в ERE-шаблонах, похожи на
символы, рассмотренные выше, но они позволяют точнее задавать
необходимое число вхождений предшествующего им символа. Указывать
ограничение можно в двух форматах:
----------------------------------------------------------------------
	n — число, задающее точное число искомых вхождений
	n, m — два числа, которые трактуются так: «как минимум n раз,
		но не больше чем m».
----------------------------------------------------------------------
$ echo "tst" | awk '/te{1}st/{print $0}'
$ echo "test" | awk '/te{1}st/{print $0}'
----------------------------------------------------------------------
$ echo "tst" | awk '/te{1,2}st/{print $0}'
$ echo "test" | awk '/te{1,2}st/{print $0}'
$ echo "teest" | awk '/te{1,2}st/{print $0}'
$ echo "teeest" | awk '/te{1,2}st/{print $0}'
----------------------------------------------------------------------
В данном примере символ «e» должен встретиться в строке 1 или 2 раза,
тогда регулярное выражение отреагирует на текст.
----------------------------------------------------------------------
Фигурные скобки можно применять и с классами символов. Тут действуют
уже знакомые вам принципы:
----------------------------------------------------------------------
$ echo "tst" | awk  '/t[ae]{1,2}st/{print $0}'
$ echo "test" | awk  '/t[ae]{1,2}st/{print $0}'
$ echo "teest" | awk  '/t[ae]{1,2}st/{print $0}'
$ echo "teeast" | awk  '/t[ae]{1,2}st/{print $0}'
----------------------------------------------------------------------
Символ логического «или»
----------------------------------------------------------------------
Символ | — вертикальная черта, означает в регулярных выражениях
логическое «или». Обрабатывая регулярное выражение, содержащее несколько
фрагментов, разделённых таким знаком, движок сочтёт анализируемый текст
подходящим в том случае, если он будет соответствовать любому из фрагментов. 
----------------------------------------------------------------------
$ echo "This is a test" | awk '/test|exam/{print $0}'
$ echo "This is an exam" | awk '/test|exam/{print $0}'
$ echo "This is something else" | awk '/test|exam/{print $0}'
----------------------------------------------------------------------
Обратите внимание на то, что между фрагментами шаблона и разделяющим
их символом | не должно быть пробелов.
----------------------------------------------------------------------
Группировка фрагментов регулярных выражений
----------------------------------------------------------------------
Фрагменты регулярных выражений можно группировать, пользуясь круглыми
скобками. Если сгруппировать некую последовательность символов, она
будет восприниматься системой как обычный символ. То есть, например,
к ней можно будет применить метасимволы повторений. Вот как это выглядит:
----------------------------------------------------------------------
$ echo "Like" | awk '/Like(Geeks)?/{print $0}'
$ echo "LikeGeeks" | awk '/Like(Geeks)?/{print $0}'
----------------------------------------------------------------------
В данных примерах слово «Geeks» заключено в круглые скобки, после этой
конструкции идёт знак вопроса. Напомним, что вопросительный знак
означает «0 или 1 повторение», в результате регулярное выражение
отреагирует и на строку «Like», и на строку «LikeGeeks».
----------------------------------------------------------------------
Практические примеры
----------------------------------------------------------------------
Подсчёт количества файлов
----------------------------------------------------------------------
Напишем bash-скрипт, который подсчитывает файлы, находящиеся в
директориях, которые записаны в переменную окружения PATH. Для того,
чтобы это сделать, понадобится, для начала, сформировать список путей
к директориям. Сделаем это с помощью sed, заменив двоеточия на пробелы:
----------------------------------------------------------------------
$ echo $PATH | sed 's/:/ /g'
----------------------------------------------------------------------
еперь надо пройтись по полученному списку в цикле и выполнить там
необходимые для подсчёта количества файлов действия. 
----------------------------------------------------------------------
#!/bin/bash
mypath=$(echo $PATH | sed 's/:/ /g')
count=0
for directory in $mypath
do
check=$(ls $directory)
for item in $check
do
count=$[ $count + 1 ]
done
echo "$directory - $count"
count=0
done
----------------------------------------------------------------------
Проверка адресов электронной почты
----------------------------------------------------------------------
username@hostname.com
----------------------------------------------------------------------
Имя пользователя, username, может состоять из алфавитно-цифровых и
некоторых других символов. А именно, это точка, тире, символ
подчёркивания, знак «плюс». За именем пользователя следует знак @.
----------------------------------------------------------------------
^([a-zA-Z0-9_\-\.\+]+)@([a-zA-Z0-9_\-\.]+)
----------------------------------------------------------------------
Имя домена верхнего уровня подчиняется особым правилам. Тут могут быть
лишь алфавитные символы, которых должно быть не меньше двух (например,
такие домены обычно содержат код страны), и не больше пяти. Всё это
значит, что шаблон для проверки последней части адреса будет таким:
----------------------------------------------------------------------
\.([a-zA-Z]{2,5})$
----------------------------------------------------------------------
^([a-zA-Z0-9_\-\.\+]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]{2,5})$
----------------------------------------------------------------------
$ echo "name@host.com" | awk '/^([a-zA-Z0-9_\-\.\+]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]{2,5})$/{print $0}'
$ echo "name@host.com.us" | awk '/^([a-zA-Z0-9_\-\.\+]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]{2,5})$/{print $0}'
----------------------------------------------------------------------

----------------------------------------------------------------------
########################################################################
    Part 10, Practical Examples — здесь приведены приёмы
работы с сообщениями, которые можно отправлять пользователям, а так же
методика мониторинга диска.
########################################################################
----------------------------------------------------------------------
https://habrahabr.ru/company/ruvds/blog/328346/
----------------------------------------------------------------------
########################################################################
    Part 11, Expect Command — этот материал посвящён
средству Expect, с помощью которого можно автоматизировать взаимодействие
с интерактивными утилитами. В частности, здесь идёт речь об expect-скриптах
и об их взаимодействии с bash-скриптами
и другими программами.
########################################################################
----------------------------------------------------------------------
https://habrahabr.ru/company/ruvds/blog/328436/
----------------------------------------------------------------------
----------------------------------------------------------------------
Linux Shell - du сортировка вывода по размеру файлов

    du -k /var/log/* | sort -nr | cut -f2 | xargs -d '\n' du -sh
----------------------------------------------------------------------
Инкремент
i++
->
i=`expr $i + 1`
или
((i++))
----------------------------------------------------------------------
Random number between 0 and 9 inclusive.

$((RANDOM%10))
----------------------------------------------------------------------
использованием переменных в скрипте. Решение вот такое:
1) кавычки не одинарные, а двойные.
2) имя переменной заключается в фигурные скобки

S1=bla_bla
S2=zlo_zlo

sed -i "s/${S1}/${S2}/g" path_to_my_file
----------------------------------------------------------------------

----------------------------------------------------------------------

----------------------------------------------------------------------

----------------------------------------------------------------------

----------------------------------------------------------------------

----------------------------------------------------------------------

----------------------------------------------------------------------
